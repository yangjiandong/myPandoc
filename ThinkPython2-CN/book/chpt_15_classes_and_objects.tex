

%ğŸ% \chapter{Classes and objects  |  ç±»å’Œå¯¹è±¡}
\chapter{ç±»å’Œå¯¹è±¡}
\label{clobjects}

%ğŸ% At this point you know how to use
%ğŸ% functions to organize code and
%ğŸ% built-in types to organize data.  The next step is to learn
%ğŸ% ``object-oriented programming'', which uses programmer-defined types
%ğŸ% to organize both code and data.  Object-oriented programming is
%ğŸ% a big topic; it will take a few chapters to get there.

ç›®å‰ä½ å·²ç»çŸ¥é“å¦‚ä½•ä½¿ç”¨å‡½æ•°æ¥ç»„ç»‡ä½ çš„ä»£ç ï¼ŒåŒæ—¶ç”¨å†…ç½®çš„ç±»å‹æ¥ç®¡ç†æ•°æ®ã€‚
ä¸‹ä¸€æ­¥æˆ‘ä»¬å°†å­¦ä¹  {\em ``é¢å‘å¯¹è±¡ç¼–ç¨‹''}ï¼Œå³ä½¿ç”¨
ç¨‹åºå‘˜å®šä¹‰çš„ç±»æ¥ç»„ç»‡ä»£ç å’Œæ•°æ®ã€‚
é¢å‘å¯¹è±¡ç¼–ç¨‹æ˜¯ä¸€ä¸ªå¾ˆå¤§çš„è¯é¢˜ï¼Œè®²å®Œéœ€è¦ä¸€äº›ç« èŠ‚ã€‚

\index{object-oriented programming}

%ğŸ% Code examples from this chapter are available from
%ğŸ% \url{http://thinkpython2.com/code/Point1.py}; solutions
%ğŸ% to the exercises are available from
%ğŸ% \url{http://thinkpython2.com/code/Point1_soln.py}.

æœ¬ç« çš„ç¤ºä¾‹ä»£ç å¯ä»¥åœ¨\href{http://thinkpython2.com/code/Point1.py}{æ­¤å¤„} è·å–ï¼›
ç»ƒä¹ é¢˜çš„ç­”æ¡ˆå¯ä»¥åœ¨\href{http://thinkpython2.com/code/Point1_soln.py}{æ­¤å¤„} è·å–ã€‚


%ğŸ% \section{Programmer-defined types  |  ç¨‹åºå‘˜è‡ªå®šä¹‰ç±»å‹}
\section{ç¨‹åºå‘˜è‡ªå®šä¹‰ç±»å‹}
\label{point}
\index{programmer-defined type}  \index{type!programmer-defined}

%ğŸ% We have used many of Python's built-in types; now we are going
%ğŸ% to define a new type.  As an example, we will create a type
%ğŸ% called {\tt Point} that represents a point in two-dimensional
%ğŸ% space.

æˆ‘ä»¬å·²ç»ä½¿ç”¨è¿‡äº†è®¸å¤š Python çš„å†…ç½®ç±»å‹ï¼›
ç°åœ¨æˆ‘ä»¬è¦å®šä¹‰ä¸€ä¸ªæ–°ç±»å‹ã€‚ ä¸¾ä¸ªä¾‹å­ï¼Œæˆ‘ä»¬æ¥åˆ›å»ºä¸€ä¸ªå«åš \li{Point} çš„ç±»å‹ï¼Œä»£è¡¨äºŒç»´ç©ºé—´ä¸­çš„ä¸€ä¸ªç‚¹ã€‚

\index{point, mathematical}

%ğŸ% In mathematical notation, points are often written in
%ğŸ% parentheses with a comma separating the coordinates. For example,
%ğŸ% $(0,0)$ represents the origin, and $(x,y)$ represents the
%ğŸ% point $x$ units to the right and $y$ units up from the origin.

åœ¨æ•°å­¦è®°æ³•ä¸­ï¼Œç‚¹é€šå¸¸è¢«å†™æˆåœ¨ä¸¤ä¸ªå°æ‹¬å·ä¸­ç”¨ä¸€ä¸ªé€—å·åˆ†éš”åæ ‡çš„å½¢å¼ã€‚
ä¾‹å¦‚ $(0,0)$ ä»£è¡¨åŸç‚¹ï¼Œ$(x,y)$ ä»£è¡¨åŸç‚¹å‘å³ $x$ ä¸ªå•ä½ï¼Œå‘ä¸Š $y$ ä¸ªå•ä½çš„ç‚¹ã€‚

%ğŸ% There are several ways we might represent points in Python:

åœ¨ Python ä¸­ï¼Œæœ‰å‡ ç§è¡¨ç¤ºç‚¹çš„æ–¹æ³•ï¼š

\begin{itemize}

%ğŸ% \item We could store the coordinates separately in two
%ğŸ% variables, {\tt x} and {\tt y}.

\item æˆ‘ä»¬å¯ä»¥å°†åæ ‡å­˜å‚¨åœ¨ä¸¤ä¸ªç‹¬ç«‹çš„å˜é‡ï¼Œ\li{x} å’Œ \li{y} ä¸­ã€‚

%ğŸ% \item We could store the coordinates as elements in a list
%ğŸ% or tuple.

\item æˆ‘ä»¬å¯ä»¥å°†åæ ‡ä½œä¸ºä¸€ä¸ªåˆ—è¡¨æˆ–è€…å…ƒç»„çš„å…ƒç´ å­˜å‚¨ã€‚

%ğŸ% \item We could create a new type to represent points as
%ğŸ% objects.

\item æˆ‘ä»¬å¯ä»¥åˆ›å»ºä¸€ä¸ªæ–°ç±»å‹å°†ç‚¹è¡¨ç¤ºä¸ºå¯¹è±¡ã€‚

\end{itemize}
\index{representation}

%ğŸ% Creating a new type
%ğŸ% is more complicated than the other options, but
%ğŸ% it has advantages that will be apparent soon.

åˆ›å»ºä¸€ä¸ªæ–°ç±»å‹æ¯”å…¶ä»–æ–¹æ³•æ›´å¤æ‚ï¼Œä½†æ˜¯å®ƒçš„ä¼˜åŠ¿ä¸€ä¼šå„¿ä¼šæ˜¾ç°å‡ºæ¥ã€‚

%ğŸ% A programmer-defined type is also called a {\bf class}.
%ğŸ% A class definition looks like this:

ç¨‹åºå‘˜è‡ªå®šä¹‰ç±»å‹ \footnote{programmer-defined type} ä¹Ÿè¢«ç§°ä½œ {\em ç±»} (class)ã€‚  åƒè¿™æ ·å®šä¹‰ä¸€ä¸ªå¯¹è±¡ï¼š

\index{class}  \index{object!class}
\index{class definition}  \index{definition!class}

\begin{lstlisting}
class Point:
    """Represents a point in 2-D space."""
\end{lstlisting}

%
%ğŸ% The header indicates that the new class is called {\tt Point}.
%ğŸ% The body is a docstring that explains what the class is for.
%ğŸ% You can define variables and methods inside a class definition,
%ğŸ% but we will get back to that later.

å¤´éƒ¨è¯­å¥è¡¨æ˜æ–°ç±»çš„åç§°æ˜¯ \li{Point} ã€‚
ä¸»ä½“éƒ¨åˆ†æ˜¯æ–‡æ¡£å­—ç¬¦ä¸²ï¼Œç”¨æ¥è§£é‡Šè¿™ä¸ªç±»çš„ç”¨é€”ã€‚
ä½ å¯ä»¥åœ¨ä¸€ä¸ªç±»çš„å®šä¹‰ä¸­å®šä¹‰å˜é‡å’Œå‡½æ•°ï¼Œç¨åä¼šè®¨è®ºè¿™ä¸ªã€‚

\index{Point class}  \index{class!Point}  \index{docstring}

%ğŸ% Defining a class named {\tt Point} creates a {\bf class object}.

å®šä¹‰ä¸€ä¸ªå«åš \li{Point} çš„ç±»å°†åˆ›å»ºäº†ä¸€ä¸ª {\em ç±»å¯¹è±¡} (class object)ã€‚

\begin{lstlisting}
>>> Point
<class '__main__.Point'>
\end{lstlisting}

%
%ğŸ% Because {\tt Point} is defined at the top level, its ``full
%ğŸ% name'' is \verb"__main__.Point".

ç”±äº \li{Point} æ˜¯å®šä¹‰åœ¨é¡¶å±‚çš„ï¼Œæ‰€ä»¥å®ƒçš„``å…¨å'' æ˜¯ \li{__main__.Point} ã€‚

\index{object!class}  \index{class object}

%ğŸ% The class object is like a factory for creating objects.  To create a
%ğŸ% Point, you call {\tt Point} as if it were a function.

ç±»å¯¹è±¡å°±åƒæ˜¯ä¸€ä¸ªç”¨æ¥åˆ›å»ºå¯¹è±¡çš„å·¥å‚ã€‚
è¦åˆ›å»ºä¸€ä¸ªç‚¹ï¼Œä½ å¯ä»¥åƒè°ƒç”¨å‡½æ•°é‚£æ ·è°ƒç”¨ \li{Point} ã€‚

\begin{lstlisting}
>>> blank = Point()
>>> blank
<__main__.Point object at 0xb7e9d3ac>
\end{lstlisting}

%
%ğŸ% The return value is a reference to a Point object, which we
%ğŸ% assign to {\tt blank}.

è¿”å›å€¼æ˜¯ä¸€ä¸ª \li{Point} å¯¹è±¡çš„å¼•ç”¨ï¼Œæˆ‘ä»¬å°†å®ƒèµ‹å€¼ç»™ \li{blank} ã€‚

%ğŸ% Creating a new object is called
%ğŸ% {\bf instantiation}, and the object is an {\bf instance} of
%ğŸ% the class.

åˆ›å»ºä¸€ä¸ªæ–°å¯¹è±¡çš„è¿‡ç¨‹å«åš {\em å®ä¾‹åŒ–} (instantiation) ï¼Œè¿™ä¸ªæ–°å¯¹è±¡å«åšè¿™ä¸ªç±»çš„ä¸€ä¸ª {\em å®ä¾‹} (instance)ã€‚

\index{instance}  \index{instantiation}

%ğŸ% When you print an instance, Python tells you what class it
%ğŸ% belongs to and where it is stored in memory (the prefix
%ğŸ% {\tt 0x} means that the following number is in hexadecimal).

å½“ä½ è¯•å›¾æ‰“å°ä¸€ä¸ªå®ä¾‹ï¼ŒPython ä¼šå‘Šè¯‰ä½ å®ƒå±äºå“ªä¸ªç±»ï¼Œ
ä»¥åŠå®ƒåœ¨å†…å­˜ä¸­çš„å­˜å‚¨åœ°å€ï¼ˆå‰ç¼€ \li{0x} ä»£è¡¨ç´§è·Ÿåé¢çš„æ•°æ˜¯ä»¥åå…­è¿›åˆ¶è¡¨ç¤ºçš„ï¼‰ã€‚

\index{hexadecimal}

%ğŸ% Every object is an instance of some class, so ``object'' and
%ğŸ% ``instance'' are interchangeable.  But in this chapter I use
%ğŸ% ``instance'' to indicate that I am talking about a programmer-defined
%ğŸ% type.

æ¯ä¸€ä¸ªå¯¹è±¡éƒ½æ˜¯æŸç§ç±»çš„å®ä¾‹ï¼Œæ‰€ä»¥``å¯¹è±¡''å’Œ``å®ä¾‹''å¯ä»¥äº’æ¢ã€‚  ä½†æ˜¯åœ¨è¿™ç« æˆ‘ç”¨ ``å®ä¾‹'' æ¥è¡¨ç¤ºæˆ‘åœ¨è®¨è®ºç¨‹åºå‘˜è‡ªå®šä¹‰ç±»å‹ã€‚


%ğŸ% \section{Attributes  |  å±æ€§}
\section{å±æ€§}
\label{attributes}
\index{instance attribute}  \index{attribute!instance}
\index{dot notation}

%ğŸ% You can assign values to an instance using dot notation:

ä½ å¯ä»¥ä½¿ç”¨ç‚¹æ ‡è®°æ³•å‘ä¸€ä¸ªå®ä¾‹è¿›è¡Œèµ‹å€¼æ“ä½œï¼š

\begin{lstlisting}
>>> blank.x = 3.0
>>> blank.y = 4.0
\end{lstlisting}

%
%ğŸ% This syntax is similar to the syntax for selecting a variable from a
%ğŸ% module, such as {\tt math.pi} or {\tt string.whitespace}.  In this case,
%ğŸ% though, we are assigning values to named elements of an object.
%ğŸ% These elements are called {\bf attributes}.

è¿™ä¸ªè¯­æ³•ç±»ä¼¼äºä»ä¸€ä¸ªæ¨¡å—ä¸­ä½¿ç”¨å˜é‡çš„è¯­æ³•ï¼Œæ¯”å¦‚ \li{math.pi} å’Œ \li{string.whitespace} ã€‚  ä¸è¿‡åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬æ˜¯ç»™ä¸€ä¸ªç±»ä¸­å·²å‘½åçš„å…ƒç´ èµ‹å€¼ã€‚  è¿™ç±»å…ƒç´ å«åš {\em å±æ€§} (attributes)ã€‚

%ğŸ% As a noun, ``AT-trib-ute'' is pronounced with emphasis on the first
%ğŸ% syllable, as opposed to ``a-TRIB-ute'', which is a verb.

ä½œä¸ºåè¯çš„æ—¶å€™ï¼Œ``å±æ€§'' çš„è‹±æ–‡ ``AT-trib-ute'' çš„é‡éŸ³åœ¨ç¬¬ä¸€ä¸ªéŸ³èŠ‚ä¸Šï¼Œä½œä¸ºåŠ¨è¯çš„æ—¶å€™ï¼Œ``a-TRIB-ute'' é‡éŸ³åœ¨ç¬¬äºŒä¸ªéŸ³èŠ‚ä¸Šã€‚

%ğŸ% The following diagram shows the result of these assignments.
%ğŸ% A state diagram that shows an object and its attributes is
%ğŸ% called an {\bf object diagram}; see Figure~\ref{fig.point}.

è§å›¾~\ref{fig.point}å±•ç¤ºäº†è¿™äº›èµ‹å€¼æ“ä½œçš„ç»“æœã€‚  æè¿°ä¸€ä¸ªå¯¹è±¡åŠå…¶å±æ€§çš„çŠ¶æ€å›¾å«åš {\em å¯¹è±¡å›¾} (object diagram)ï¼› ã€‚

\index{state diagram}  \index{diagram!state}
\index{object diagram}  \index{diagram!object}

\begin{figure}
\centerline
{\includegraphics[scale=0.8]{../source/figs/point.pdf}}
% \caption{Object diagram.}
\caption{å¯¹è±¡å›¾ã€‚}
\label{fig.point}
\end{figure}

%ğŸ% The variable {\tt blank} refers to a Point object, which
%ğŸ% contains two attributes.  Each attribute refers to a
%ğŸ% floating-point number.

å˜é‡ \li{blank} å¼•ç”¨äº†ä¸€ä¸ª \li{Point} ç±»ï¼Œè¿™ä¸ªç±»æ‹¥æœ‰äº†ä¸¤ä¸ªå±æ€§ã€‚
æ¯ä¸ªå±æ€§éƒ½å¼•ç”¨äº†ä¸€ä¸ªæµ®ç‚¹æ•°ã€‚

%ğŸ% You can read the value of an attribute using the same syntax:

ä½ å¯ä»¥ä½¿ç”¨ç›¸åŒçš„è¯­æ³•è¯»å–ä¸€ä¸ªå±æ€§çš„å€¼ï¼š

\begin{lstlisting}
>>> blank.y
4.0
>>> x = blank.x
>>> x
3.0
\end{lstlisting}

%
%ğŸ% The expression {\tt blank.x} means, ``Go to the object {\tt blank}
%ğŸ% refers to and get the value of {\tt x}.''  In the example, we assign that
%ğŸ% value to a variable named {\tt x}.  There is no conflict between
%ğŸ% the variable {\tt x} and the attribute {\tt x}.

è¡¨è¾¾å¼ \li{blank.x} çš„æ„æ€æ˜¯ï¼Œ``å‰å¾€ \li{blank} æ‰€å¼•ç”¨çš„å¯¹è±¡å¹¶ä¸”è·å– \li{x} çš„å€¼''ã€‚
åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬å°†è·å–åˆ°çš„å€¼èµ‹å€¼ç»™äº†ä¸€ä¸ªå«åš \li{x} çš„å˜é‡ã€‚
å˜é‡ \li{x} å’Œå±æ€§ \li{x} å¹¶ä¸ä¼šå†²çªã€‚

%ğŸ% You can use dot notation as part of any expression.  For example:

ä½ å¯ä»¥åœ¨ä»»ä½•è¡¨è¾¾å¼ä¸­ä½¿ç”¨ç‚¹æ ‡è®°æ³•ã€‚ ä¾‹å¦‚ï¼š

\begin{lstlisting}
>>> '(%g, %g)' % (blank.x, blank.y)
'(3.0, 4.0)'
>>> distance = math.sqrt(blank.x**2 + blank.y**2)
>>> distance
5.0
\end{lstlisting}

%ğŸ% %
%ğŸ% You can pass an instance as an argument in the usual way.
%ğŸ% For example:

ä½ å¯ä»¥å°†ä¸€ä¸ªå®ä¾‹ä½œä¸ºå‚æ•°ä¼ é€’ã€‚ ä¾‹å¦‚ï¼š

\index{instance!as argument}

\begin{lstlisting}
def print_point(p):
    print('(%g, %g)' % (p.x, p.y))
\end{lstlisting}

%ğŸ% %
%ğŸ% \verb"print_point" takes a point as an argument and displays it in
%ğŸ% mathematical notation.  To invoke it, you can pass {\tt blank} as
%ğŸ% an argument:

\li{print_point} æ¥å—ä¸€ä¸ªç‚¹ä½œä¸ºå‚æ•°ï¼Œæ‰“å°å‡ºå…¶åœ¨æ•°å­¦ä¸­çš„è¡¨ç¤ºæ–¹æ³•ã€‚
è°ƒç”¨å®ƒçš„æ—¶å€™ï¼Œä½ å¯ä»¥å°† \li{blank} ä½œä¸ºå‚æ•°ä¼ é€’ï¼š

\begin{lstlisting}
>>> print_point(blank)
(3.0, 4.0)
\end{lstlisting}

%ğŸ% %
%ğŸ% Inside the function, {\tt p} is an alias for {\tt blank}, so if
%ğŸ% the function modifies {\tt p}, {\tt blank} changes.
\index{aliasing}

åœ¨è¿™ä¸ªå‡½æ•°å†…éƒ¨ï¼Œ \li{p} æ˜¯ \li{blank} çš„åˆ«åï¼Œ
æ‰€ä»¥ï¼Œå¦‚æœå‡½æ•°ä¿®æ”¹äº† \li{p} ï¼Œ \li{blank} ä¹Ÿä¼šéšä¹‹æ”¹å˜ã€‚

%ğŸ% As an exercise, write a function called \verb"distance_between_points"
%ğŸ% that takes two Points as arguments and returns the distance between
%ğŸ% them.

æˆ‘ä»¬åšä¸ªè”ç³»ï¼Œç¼–å†™ä¸€ä¸ªå«åš \li{distance_between_points} çš„å‡½æ•°ï¼Œå®ƒæ¥å—ä¸¤ä¸ª \li{Point} ä½œä¸ºå‚æ•°ï¼Œç„¶åè¿”å›è¿™ä¸¤ä¸ªç‚¹ä¹‹é—´çš„è·ç¦»ã€‚


%ğŸ% \section{Rectangles  |  çŸ©å½¢}
\section{çŸ©å½¢}
\label{rectangles}

%ğŸ% Sometimes it is obvious what the attributes of an object should be,
%ğŸ% but other times you have to make decisions.  For example, imagine you
%ğŸ% are designing a class to represent rectangles.  What attributes would
%ğŸ% you use to specify the location and size of a rectangle?  You can
%ğŸ% ignore angle; to keep things simple, assume that the rectangle is
%ğŸ% either vertical or horizontal.

æœ‰æ—¶å€™ï¼Œä¸€ä¸ªå¯¹è±¡è¯¥æ‹¥æœ‰å“ªäº›å±æ€§æ˜¯æ˜¾è€Œæ˜“è§çš„ï¼Œä½†æœ‰æ—¶å€™ä½ éœ€è¦å¥½å¥½è€ƒè™‘ä¸€ç•ªã€‚
æ¯”å¦‚ï¼Œä½ éœ€è¦è®¾è®¡ä¸€ä¸ªä»£è¡¨çŸ©å½¢çš„ç±»ã€‚
ä¸ºäº†æè¿°ä¸€ä¸ªçŸ©å½¢çš„ä½ç½®å’Œå¤§å°ï¼Œä½ éœ€è¦è®¾è®¡å“ªäº›å±æ€§å‘¢ï¼Ÿ
è§’åº¦æ˜¯å¯ä»¥å¿½ç•¥çš„ï¼›ä¸ºäº†ä½¿äº‹æƒ…æ›´ç®€å•ï¼Œæˆ‘ä»¬å‡è®¾çŸ©å½¢æ˜¯æ°´å¹³æˆ–è€…ç«–ç›´çš„ã€‚

\index{representation}

%ğŸ% There are at least two possibilities:

è‡³å°‘æœ‰ä¸¤ç§å¯èƒ½çš„è®¾è®¡ï¼š

\begin{itemize}

%ğŸ% \item You could specify one corner of the rectangle
%ğŸ% (or the center), the width, and the height.
%ğŸ%
%ğŸ% \item You could specify two opposing corners.

\item ä½ å¯ä»¥æŒ‡å®šçŸ©å½¢çš„ä¸€ä¸ªè§’ï¼ˆæˆ–æ˜¯ä¸­å¿ƒï¼‰ã€å®½åº¦ä»¥åŠé•¿åº¦ã€‚

\item ä½ å¯ä»¥æŒ‡å®šå¯¹è§’çº¿ä¸Šçš„ä¸¤ä¸ªè§’ã€‚

\end{itemize}

%ğŸ% At this point it is hard to say whether either is better than
%ğŸ% the other, so we'll implement the first one, just as an example.

è¿™ä¸ªæ—¶å€™è¿˜ä¸èƒ½å¤Ÿè¯´æ˜å“ªä¸ªæ–¹æ³•ä¼˜äºå“ªä¸ªæ–¹æ³•ã€‚æˆ‘ä»¬å…ˆæ¥å®ç°å‰è€…ã€‚

\index{Rectangle class}  \index{class!Rectangle}

%ğŸ% Here is the class definition:

ä¸‹é¢æ˜¯ç±»çš„å®šä¹‰ï¼š

\begin{lstlisting}
class Rectangle:
    """Represents a rectangle.

    attributes: width, height, corner.
    """
\end{lstlisting}

%
%ğŸ% The docstring lists the attributes:  {\tt width} and
%ğŸ% {\tt height} are numbers; {\tt corner} is a Point object that
%ğŸ% specifies the lower-left corner.

æ–‡æ¡£å­—ç¬¦ä¸²ä¸­åˆ—å‡ºäº†å±æ€§ï¼š \li{width} å’Œ \li{height} æ˜¯æ•°å­—ï¼›
\li{corner} æ˜¯ä¸€ä¸ª \li{Point} å¯¹è±¡ï¼Œä»£è¡¨å·¦ä¸‹è§’çš„é‚£ä¸ªç‚¹ã€‚

%ğŸ% To represent a rectangle, you have to instantiate a Rectangle
%ğŸ% object and assign values to the attributes:

ä¸ºäº†æè¿°ä¸€ä¸ªçŸ©å½¢ï¼Œä½ éœ€è¦å®ä¾‹åŒ–ä¸€ä¸ª \li{Rectangle} å¯¹è±¡ï¼Œå¹¶ä¸”ä¸ºå®ƒçš„å±æ€§èµ‹å€¼ï¼š

\begin{lstlisting}
box = Rectangle()
box.width = 100.0
box.height = 200.0
box.corner = Point()
box.corner.x = 0.0
box.corner.y = 0.0
\end{lstlisting}

%
%ğŸ% The expression {\tt box.corner.x} means,
%ğŸ% ``Go to the object {\tt box} refers to and select the attribute named
%ğŸ% {\tt corner}; then go to that object and select the attribute named
%ğŸ% {\tt x}.''

è¡¨è¾¾å¼ \li{box.corner.x} çš„æ„æ€æ˜¯ï¼Œ
``å‰å¾€ \li{box} æ‰€å¼•ç”¨çš„å¯¹è±¡ï¼Œæ‰¾åˆ°å«åš \li{corner} çš„å±æ€§ï¼›
ç„¶åå‰å¾€ \li{corner} æ‰€å¼•ç”¨çš„å¯¹è±¡ï¼Œæ‰¾åˆ°å«åš \li{x} çš„å±æ€§ã€‚''

\begin{figure}
\centerline
{\includegraphics[scale=0.8]{../source/figs/rectangle.pdf}}
% \caption{Object diagram.}
\caption{å¯¹è±¡å›¾ã€‚}
\label{fig.rectangle}
\end{figure}

%ğŸ% Figure~\ref{fig.rectangle} shows the state of this object.
%ğŸ% An object that is an attribute of another object is {\bf embedded}.

å›¾~\ref{fig.rectangle} å±•ç¤ºäº†è¿™ä¸ªå¯¹è±¡çš„çŠ¶æ€ã€‚
ä¸€ä¸ªå¯¹è±¡ä½œä¸ºå¦ä¸€ä¸ªå¯¹è±¡çš„å±æ€§å«åš {\em åµŒå¥—} (embedded)ã€‚
\index{state diagram}  \index{diagram!state}
\index{object diagram}  \index{diagram!object}
\index{embedded object}  \index{object!embedded}


%ğŸ% \section{Instances as return values  |  å®ä¾‹ä½œä¸ºè¿”å›å€¼}
\section{å®ä¾‹ä½œä¸ºè¿”å›å€¼}
\index{instance!as return value}  \index{return value}

%ğŸ% Functions can return instances.  For example, \verb"find_center"
%ğŸ% takes a {\tt Rectangle} as an argument and returns a {\tt Point}
%ğŸ% that contains the coordinates of the center of the {\tt Rectangle}:

å‡½æ•°å¯ä»¥è¿”å›å®ä¾‹ã€‚ ä¾‹å¦‚ï¼Œ \li{find_center} æ¥å—ä¸€ä¸ª \li{Rectangle} ä½œä¸ºå‚æ•°ï¼Œ
è¿”å›ä¸€ä¸ª \li{Point} ï¼Œä»£è¡¨äº†è¿™ä¸ª \li{Rectangle} çš„ä¸­å¿ƒåæ ‡ï¼š

\begin{lstlisting}
def find_center(rect):
    p = Point()
    p.x = rect.corner.x + rect.width/2
    p.y = rect.corner.y + rect.height/2
    return p
\end{lstlisting}

%
%ğŸ% Here is an example that passes {\tt box} as an argument and assigns
%ğŸ% the resulting Point to {\tt center}:

ä¸‹é¢è¿™ä¸ªä¾‹å­å°† \li{box} ä½œä¸ºå‚æ•°ä¼ é€’ï¼Œç„¶åå°†è¿”å›çš„ \li{Point} èµ‹å€¼ç»™ \li{center}ï¼š

\begin{lstlisting}
>>> center = find_center(box)
>>> print_point(center)
(50, 100)
\end{lstlisting}
%

%ğŸ% \section{Objects are mutable  |  å¯¹è±¡æ˜¯å¯å˜çš„}
\section{å¯¹è±¡æ˜¯å¯å˜çš„}
\index{object!mutable}  \index{mutability}

%ğŸ% You can change the state of an object by making an assignment to one of
%ğŸ% its attributes.  For example, to change the size of a rectangle
%ğŸ% without changing its position, you can modify the values of {\tt
%ğŸ% width} and {\tt height}:


ä½ å¯ä»¥é€šè¿‡ç»™ä¸€ä¸ªå¯¹è±¡çš„å±æ€§èµ‹å€¼æ¥æ”¹å˜è¿™ä¸ªå¯¹è±¡çš„çŠ¶æ€ã€‚
ä¾‹å¦‚ï¼Œè¦æ”¹å˜ä¸€ä¸ªçŸ©å½¢çš„å¤§å°è€Œä¸æ”¹å˜å®ƒçš„ä½ç½®ï¼Œä½ å¯ä»¥ä¿®æ”¹ \li{width} å’Œ \li{height} çš„å€¼ï¼š

\begin{lstlisting}
box.width = box.width + 50
box.height = box.height + 100
\end{lstlisting}

%
%ğŸ% You can also write functions that modify objects.  For example,
%ğŸ% \verb"grow_rectangle" takes a Rectangle object and two numbers,
%ğŸ% {\tt dwidth} and {\tt dheight}, and adds the numbers to the
%ğŸ% width and height of the rectangle:

ä½ ä¹Ÿå¯ä»¥ç¼–å†™å‡½æ•°æ¥ä¿®æ”¹å¯¹è±¡ã€‚
ä¾‹å¦‚ï¼Œ\li{grow_rectangle} æ¥å—ä¸€ä¸ª\li{Rectangle} å¯¹è±¡å’Œä¸¤ä¸ªæ•°å­—ï¼Œ
\li{dwidth} å’Œ\li{dheight} ï¼Œå¹¶å°†å…¶åŠ åˆ°çŸ©å½¢çš„å®½åº¦å’Œé«˜åº¦ä¸Šï¼š

\begin{lstlisting}
def grow_rectangle(rect, dwidth, dheight):
    rect.width += dwidth
    rect.height += dheight
\end{lstlisting}

%
%ğŸ% Here is an example that demonstrates the effect:

ä¸‹é¢çš„ä¾‹å­å±•ç¤ºäº†å…·ä½“æ•ˆæœï¼š

\begin{lstlisting}
>>> box.width, box.height
(150.0, 300.0)
>>> grow_rectangle(box, 50, 100)
>>> box.width, box.height
(200.0, 400.0)
\end{lstlisting}

%
%ğŸ% Inside the function, {\tt rect} is an
%ğŸ% alias for {\tt box}, so when the function modifies {\tt rect},
%ğŸ% {\tt box} changes.

åœ¨å‡½æ•°å†…éƒ¨ï¼Œ \li{rect} æ˜¯ \li{box} çš„ä¸€ä¸ªåˆ«åï¼Œ
æ‰€ä»¥å¦‚æœå‡½æ•°ä¿®æ”¹äº† \li{rect} ï¼Œåˆ™ \li{box} ä¹Ÿéšä¹‹æ”¹å˜ã€‚

%ğŸ% As an exercise, write a function named \verb"move_rectangle" that takes
%ğŸ% a Rectangle and two numbers named {\tt dx} and {\tt dy}.  It
%ğŸ% should change the location of the rectangle by adding {\tt dx}
%ğŸ% to the {\tt x} coordinate of {\tt corner} and adding {\tt dy}
%ğŸ% to the {\tt y} coordinate of {\tt corner}.

æˆ‘ä»¬åšä¸ªç»ƒä¹ ï¼Œç¼–å†™ä¸€ä¸ªå«åš \li{move_rectangle} çš„å‡½æ•°ï¼Œæ¥å—ä¸€ä¸ª \li{Rectangle} ä»¥åŠä¸¤ä¸ªæ•°å­— \li{dx} å’Œ \li{dy}ã€‚  å®ƒæŠŠ \li{corner} çš„ \li{x} åæ ‡åŠ ä¸Š \li{dx}ï¼ŒæŠŠ \li{corner} çš„ \li{y} åæ ‡åŠ ä¸Š \li{dy} ï¼Œä»è€Œæ”¹å˜çŸ©å½¢çš„ä½ç½®ã€‚

%ğŸ% \section{Copying  |  å¤åˆ¶}
\section{å¤åˆ¶}
\label{copying}
\index{aliasing}

%ğŸ% Aliasing can make a program difficult to read because changes
%ğŸ% in one place might have unexpected effects in another place.
%ğŸ% It is hard to keep track of all the variables that might refer
%ğŸ% to a given object.

åˆ«åä¼šé™ä½ç¨‹åºçš„å¯è¯»æ€§ï¼Œå› ä¸ºä¸€ä¸ªåœ°æ–¹çš„å˜åŠ¨å¯èƒ½å¯¹å¦ä¸€ä¸ªåœ°æ–¹é€ æˆé¢„æ–™ä¹‹å¤–çš„å½±å“ã€‚
è·Ÿè¸ªæ‰€æœ‰å¼•ç”¨åŒä¸€ä¸ªå¯¹è±¡çš„å˜é‡æ˜¯éå¸¸å›°éš¾çš„ã€‚
\index{copying objects}  \index{object!copying}
\index{copy module}  \index{module!copy}

%ğŸ% Copying an object is often an alternative to aliasing.
%ğŸ% The {\tt copy} module contains a function called {\tt copy} that
%ğŸ% can duplicate any object:

é€šå¸¸ç”¨å¤åˆ¶å¯¹è±¡çš„æ–¹æ³•å–ä»£ä¸ºå¯¹è±¡èµ·åˆ«åã€‚
\li{copy} æ¨¡å—æ‹¥æœ‰ä¸€ä¸ªå«åš \li{copy} çš„å‡½æ•°ï¼Œå¯ä»¥å¤åˆ¶ä»»ä½•å¯¹è±¡ï¼š

\begin{lstlisting}
>>> p1 = Point()
>>> p1.x = 3.0
>>> p1.y = 4.0

>>> import copy
>>> p2 = copy.copy(p1)
\end{lstlisting}

%ğŸ% %
%ğŸ% {\tt p1} and {\tt p2} contain the same data, but they are
%ğŸ% not the same Point.

\li{p1} å’Œ \li{p2} æ‹¥æœ‰ç›¸åŒçš„æ•°æ®ï¼Œä½†æ˜¯å®ƒä»¬å¹¶ä¸æ˜¯åŒä¸€ä¸ª \li{Point} å¯¹è±¡ã€‚

\begin{lstlisting}
>>> print_point(p1)
(3, 4)
>>> print_point(p2)
(3, 4)
>>> p1 is p2
False
>>> p1 == p2
False
\end{lstlisting}

%ğŸ% %
%ğŸ% The {\tt is} operator indicates that {\tt p1} and {\tt p2} are not the
%ğŸ% same object, which is what we expected.  But you might have expected
%ğŸ% {\tt ==} to yield {\tt True} because these points contain the same
%ğŸ% data.  In that case, you will be disappointed to learn that for
%ğŸ% instances, the default behavior of the {\tt ==} operator is the same
%ğŸ% as the {\tt is} operator; it checks object identity, not object
%ğŸ% equivalence.  That's because for programmer-defined types, Python doesn't
%ğŸ% know what should be considered equivalent.  At least, not yet.

æ­£å¦‚æˆ‘ä»¬é¢„æœŸçš„ï¼Œ \li{is} è¿ç®—ç¬¦æ˜¾ç¤ºäº† \li{p1} å’Œ \li{p2} å¹¶éåŒä¸€ä¸ªå¯¹è±¡ã€‚
ä¸è¿‡ä½ å¯èƒ½ä¼šè®¤ä¸º \li{==} è¿ç®—çš„ç»“æœåº”è¯¥æ˜¯ \li{True} ï¼Œå› ä¸ºè¿™ä¸¤ä¸ªç‚¹çš„æ•°æ®æ˜¯ç›¸åŒçš„ã€‚
ç„¶è€Œç»“æœå¹¶ä¸å¦‚ä½ æƒ³è±¡çš„é‚£æ ·ï¼Œ \li{==} è¿ç®—ç¬¦çš„é»˜è®¤è¡Œä¸ºå’Œ \li{is} è¿ç®—ç¬¦ç›¸åŒï¼›
å®ƒæ£€æŸ¥å¯¹è±¡çš„æ ‡è¯† (identity) æ˜¯å¦ç›¸åŒï¼Œè€Œéå¯¹è±¡çš„å€¼æ˜¯å¦ç›¸åŒã€‚  å› ä¸º Python å¹¶ä¸çŸ¥é“ä»€ä¹ˆæ ·å¯ä»¥è¢«è®¤ä¸ºç›¸åŒã€‚è‡³å°‘ç›®å‰ä¸çŸ¥é“ã€‚
\index{is operator}  \index{operator!is}
\index{identity}  \index{equivalence}

%ğŸ% If you use {\tt copy.copy} to duplicate a Rectangle, you will find
%ğŸ% that it copies the Rectangle object but not the embedded Point.
%ğŸ% \index{embedded object!copying}

å¦‚æœä½ ä½¿ç”¨ \li{copy.copy} æ¥å¤åˆ¶ä¸€ä¸ª \li{Rectangle} ï¼Œ
ä½ ä¼šå‘ç°å®ƒä»…ä»…å¤åˆ¶äº† \li{Rectangle} å¯¹è±¡ï¼Œä½†æ²¡æœ‰å¤åˆ¶åµŒå¥—çš„ \li{Point} å¯¹è±¡ã€‚

\begin{lstlisting}
>>> box2 = copy.copy(box)
>>> box2 is box
False
>>> box2.corner is box.corner
True
\end{lstlisting}

\begin{figure}
\centerline
{\includegraphics[scale=0.8]{../source/figs/rectangle2.pdf}}
% \caption{Object diagram.}
\caption{å¯¹è±¡å›¾ã€‚}
\label{fig.rectangle2}
\end{figure}

%ğŸ% Figure~\ref{fig.rectangle2} shows what the object diagram looks like.
%ğŸ% \index{state diagram}  \index{diagram!state}
%ğŸ% \index{object diagram}  \index{diagram!object}
%ğŸ% This operation is called a {\bf shallow copy} because it copies the
%ğŸ% object and any references it contains, but not the embedded objects.
%ğŸ% \index{shallow copy}  \index{copy!shallow}

å›¾~\ref{fig.rectangle2} å±•ç¤ºäº†ç›¸åº”çš„å¯¹è±¡å›¾ã€‚ è¿™ä¸ªæ“ä½œå«åš {\em æµ…å¤åˆ¶} (shallow
copy) ï¼Œå› ä¸ºå®ƒä»…å¤åˆ¶äº†å¯¹è±¡ä»¥åŠå…¶åŒ…å«çš„å¼•ç”¨ï¼Œ ä½†æœªå¤åˆ¶åµŒå¥—çš„å¯¹è±¡ã€‚
\index{state diagram}  \index{diagram!state}
\index{object diagram}  \index{diagram!object}
\index{shallow copy}  \index{copy!shallow}

%ğŸ% For most applications, this is not what you want.  In this example,
%ğŸ% invoking \verb"grow_rectangle" on one of the Rectangles would not
%ğŸ% affect the other, but invoking \verb"move_rectangle" on either would
%ğŸ% affect both!  This behavior is confusing and error-prone.

å¯¹å¤§å¤šæ•°åº”ç”¨æ¥è¯´ï¼Œè¿™å¹¶éæ˜¯ä½ æƒ³è¦çš„ç»“æœã€‚
åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œå¯¹å…¶ä¸­ä¸€ä¸ª \li{Rectangle} å¯¹è±¡è°ƒç”¨ \li{grow_rectangle}å¹¶ä¸ä¼šå½±å“åˆ°å¦å¤–ä¸€ä¸ªï¼Œ ç„¶è€Œå½“å¯¹ä»»ä½•ä¸€ä¸ª \li{Rectangle} å¯¹è±¡è°ƒç”¨ \li{move_rectangle}çš„æ—¶å€™ï¼Œä¸¤è€…éƒ½ä¼šè¢«å½±å“ï¼è¿™ä¸ªè¡Œä¸ºå¾ˆå®¹æ˜“å¸¦æ¥ç–‘æƒ‘å’Œé”™è¯¯ã€‚
\index{deep copy}  \index{copy!deep}

%ğŸ% Fortunately, the {\tt copy} module provides a method named {\tt
%ğŸ% deepcopy} that copies not only the object but also
%ğŸ% the objects it refers to, and the objects {\em they} refer to,
%ğŸ% and so on.
%ğŸ% You will not be surprised to learn that this operation is
%ğŸ% called a {\bf deep copy}.

å¹¸è¿çš„æ˜¯ï¼Œ \li{copy} æ¨¡å—æ‹¥æœ‰ä¸€ä¸ªå«åš \li{deepcopy} çš„æ–¹æ³•ï¼Œ
å®ƒä¸ä»…å¯ä»¥å¤åˆ¶ä¸€ä¸ªå¯¹è±¡ï¼Œè¿˜å¯ä»¥å¤åˆ¶è¿™ä¸ªå¯¹è±¡æ‰€å¼•ç”¨çš„å¯¹è±¡ï¼Œ
ç”šè‡³å¯ä»¥å¤åˆ¶ {\bf è¿™ä¸ªå¯¹è±¡æ‰€å¼•ç”¨çš„å¯¹è±¡} æ‰€å¼•ç”¨çš„å¯¹è±¡ï¼Œç­‰ç­‰ã€‚
æ²¡é”™ï¼è¿™ä¸ªæ“ä½œå«åš {\em æ·±å¤åˆ¶} (deep copy) ã€‚

\index{deepcopy function}  \index{function!deepcopy}

\begin{lstlisting}
>>> box3 = copy.deepcopy(box)
>>> box3 is box
False
>>> box3.corner is box.corner
False
\end{lstlisting}

%
%ğŸ% {\tt box3} and {\tt box} are completely separate objects.

%ğŸ% As an exercise, write a version of \verb"move_rectangle" that creates and
%ğŸ% returns a new Rectangle instead of modifying the old one.

æˆ‘ä»¬åšä¸ªç»ƒä¹ ï¼Œç¼–å†™å¦ä¸€ä¸ªç‰ˆæœ¬çš„ \li{move_rectangle} ï¼Œ
å‡½æ•°åˆ›å»ºå¹¶è¿”å›ä¸€ä¸ªæ–°çš„ \li{Rectangle} å¯¹è±¡è€Œéä¿®æ”¹åŸå…ˆçš„é‚£ä¸ªã€‚

%ğŸ% \section{Debugging  |  è°ƒè¯•}
\section{è°ƒè¯•}
\label{hasattr}
\index{debugging}

%ğŸ% When you start working with objects, you are likely to encounter
%ğŸ% some new exceptions.  If you try to access an attribute
%ğŸ% that doesn't exist, you get an {\tt AttributeError}:

å½“ä½ å¼€å§‹å­¦ä¹ å¯¹è±¡çš„æ—¶å€™ï¼Œä½ å¯èƒ½ä¼šé‡åˆ°ä¸€äº›æ–°çš„å¼‚å¸¸ã€‚
å¦‚æœä½ è®¿é—®ä¸€ä¸ªä¸å­˜åœ¨çš„å±æ€§ï¼Œä½ ä¼šå¾—åˆ° \li{Attributeerror} çš„é”™è¯¯æç¤ºï¼š

\index{exception!AttributeError}  \index{AttributeError}

\begin{lstlisting}
>>> p = Point()
>>> p.x = 3
>>> p.y = 4
>>> p.z
AttributeError: Point instance has no attribute 'z'
\end{lstlisting}

%
%ğŸ% If you are not sure what type an object is, you can ask:

å¦‚æœä½ ä¸ç¡®å®šä¸€ä¸ªå¯¹è±¡çš„ç±»å‹ï¼Œä½ å¯ä»¥è¯¢é—®ï¼š

\index{type function}  \index{function!type}

\begin{lstlisting}
>>> type(p)
<class '__main__.Point'>
\end{lstlisting}

%
%ğŸ% You can also use {\tt isinstance} to check whether an object
%ğŸ% is an instance of a class:

ä½ ä¹Ÿå¯ä»¥ç”¨ \li{isinstance} æ¥æ£€æŸ¥æŸä¸ªå¯¹è±¡æ˜¯ä¸æ˜¯æŸä¸ªç±»çš„å®ä¾‹ã€‚

\index{isinstance function}  \index{function!isinstance}

\begin{lstlisting}
>>> isinstance(p, Point)
True
\end{lstlisting}

%
%ğŸ% If you are not sure whether an object has a particular attribute,
%ğŸ% you can use the built-in function {\tt hasattr}:

å¦‚æœä½ ä¸ç¡®å®šä¸€ä¸ªå¯¹è±¡æ˜¯å¦æ‹¥æœ‰æŸä¸ªå±æ€§ï¼Œ ä½ å¯ä»¥ä½¿ç”¨å†…ç½®å‡½æ•° \li{hasattr} æ£€æŸ¥ï¼š
\index{hasattr function}  \index{function!hasattr}

\begin{lstlisting}
>>> hasattr(p, 'x')
True
>>> hasattr(p, 'z')
False
\end{lstlisting}

%
%ğŸ% The first argument can be any object; the second argument is a {\em
%ğŸ% string} that contains the name of the attribute.

ç¬¬ä¸€ä¸ªå‚æ•°å¯ä»¥æ˜¯ä»»ä½•å¯¹è±¡ï¼›
ç¬¬äºŒä¸ªå‚æ•°æ˜¯ä¸€ä¸ª {\em å­—ç¬¦ä¸²} ï¼Œä»£è¡¨äº†æŸä¸ªå±æ€§çš„åå­—ã€‚

\index{attribute}

%ğŸ% You can also use a {\tt try} statement to see if the object has the
%ğŸ% attributes you need:

ä½ ä¹Ÿå¯ä»¥ä½¿ç”¨ \li{try}ã€€è¯­å¥æ¥æ£€æŸ¥æŸä¸ªå¯¹è±¡æ˜¯ä¸æ˜¯æœ‰ä½ éœ€è¦çš„å±æ€§:

\index{try statement}  \index{statement!try}

\begin{lstlisting}
try:
    x = p.x
except AttributeError:
    x = 0
\end{lstlisting}

%ğŸ% This approach can make it easier to write functions that work with
%ğŸ% different types; more on that topic is
%ğŸ% coming up in Section~\ref{polymorphism}.

è¿™ä¸ªæ–¹æ³•å¯ä»¥è®©ä½ æ›´å®¹æ˜“ç¼–å†™å‡ºå¯ä»¥é€‚åº”å¤šç§æ•°æ®ç»“æ„çš„å‡½æ•°ã€‚ä½ å¯ä»¥åœ¨ \ref{polymorphism}~èŠ‚ æŸ¥çœ‹æ›´å¤šå†…å®¹ã€‚


%ğŸ% \section{Glossary  |  æœ¯è¯­è¡¨}
\section{æœ¯è¯­è¡¨}

\begin{description}

%ğŸ% \item[class:] A programmer-defined type.  A class definition creates a new
%ğŸ% class object.

\item[ç±» (class):]
ä¸€ç§ç¨‹åºå‘˜è‡ªå®šä¹‰çš„ç±»å‹ã€‚ç±»å®šä¹‰åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„ç±»å¯¹è±¡ã€‚
\index{class}  \index{programmer-defined type}  \index{type!programmer-defined}

%ğŸ% \item[class object:] An object that contains information about a
%ğŸ% programmer-defined type.  The class object can be used to create instances
%ğŸ% of the type.

\item[ç±»å¯¹è±¡ (class object):]åŒ…å«ç¨‹åºå‘˜è‡ªå®šä¹‰ç±»å‹çš„ç»†èŠ‚ä¿¡æ¯çš„å¯¹è±¡ã€‚ç±»å¯¹è±¡å¯ä»¥è¢«ç”¨äºåˆ›å»ºè¯¥ç±»å‹çš„å®ä¾‹ã€‚

\index{class object}  \index{object!class}

%ğŸ% \item[instance:] An object that belongs to a class.

\item[å®ä¾‹ (instance):]
å±äºæŸä¸ªç±»çš„å¯¹è±¡ã€‚
\index{instance}

%ğŸ% \item[instantiate:] To create a new object.

\item[å®ä¾‹åŒ– (instantiate):]
åˆ›å»ºæ–°çš„å¯¹è±¡ã€‚
\index{instantiate}

%ğŸ% \item[attribute:] One of the named values associated with an object.

\item[å±æ€§ (attribute):]
å’ŒæŸä¸ªå¯¹è±¡ç›¸å…³è”çš„æœ‰å‘½åçš„å€¼ã€‚
\index{attribute!instance}  \index{instance attribute}

%ğŸ% \item[embedded object:] An object that is stored as an attribute
%ğŸ% of another object.

\item[åµŒå¥—å¯¹è±¡ (embedded object):]
ä½œä¸ºå¦ä¸€ä¸ªå¯¹è±¡çš„å±æ€§å­˜å‚¨çš„å¯¹è±¡ã€‚
\index{embedded object}  \index{object!embedded}

%ğŸ% \item[shallow copy:] To copy the contents of an object, including
%ğŸ% any references to embedded objects;
%ğŸ% implemented by the {\tt copy} function in the {\tt copy} module.

\item[æµ…å¤åˆ¶ (shallow copy):]
åœ¨å¤åˆ¶å¯¹è±¡å†…å®¹çš„æ—¶å€™ï¼ŒåªåŒ…å«åµŒå¥—å¯¹è±¡çš„å¼•ç”¨ï¼Œé€šè¿‡ \li{copy} æ¨¡å—çš„ \li{copy} å‡½æ•°å®ç°ã€‚
\index{shallow copy}

%ğŸ% \item[deep copy:] To copy the contents of an object as well as any
%ğŸ% embedded objects, and any objects embedded in them, and so on;
%ğŸ% implemented by the {\tt deepcopy} function in the {\tt copy} module.

\item[æ·±å¤åˆ¶ (deep copy):]åœ¨å¤åˆ¶å¯¹è±¡å†…å®¹çš„æ—¶å€™ï¼Œæ—¢å¤åˆ¶å¯¹è±¡å±æ€§ï¼Œä¹Ÿå¤åˆ¶æ‰€æœ‰åµŒå¥—å¯¹è±¡åŠå…¶ä¸­çš„æ‰€æœ‰åµŒå¥—å¯¹è±¡ï¼Œç”± \li{copy} æ¨¡å—çš„ \li{deepcopy} å‡½æ•°å®ç°ã€‚
\index{deep copy}

%ğŸ% \item[object diagram:] A diagram that shows objects, their
%ğŸ% attributes, and the values of the attributes.

\item[å¯¹è±¡å›¾ (object diagram):]
å±•ç¤ºå¯¹è±¡åŠå…¶å±æ€§å’Œå±æ€§å€¼çš„å›¾ã€‚
\index{object diagram}  \index{diagram!object}

\end{description}


%ğŸ% \section{Exercises  |  ç»ƒä¹ }
\section{ç»ƒä¹ }

\begin{exercise}

%ğŸ% Write a definition for a class named {\tt Circle} with attributes
%ğŸ% {\tt center} and {\tt radius}, where {\tt center} is a Point object
%ğŸ% and radius is a number.

å®šä¹‰ä¸€ä¸ªå«åš {\em \li{Circle}} ç±»ï¼Œç±»çš„å±æ€§æ˜¯åœ†å¿ƒ {\em (\li{center})}  å’ŒåŠå¾„ {\em (\li{radius})} ,å…¶ä¸­ï¼Œåœ†å¿ƒ {\em (\li{center})} æ˜¯ä¸€ä¸ªã€€{\em \li{Point}} ç±»ï¼Œè€ŒåŠå¾„ {\em (\li{radius})}æ˜¯ä¸€ä¸ªæ•°å­—ã€‚

%ğŸ% Instantiate a Circle object that represents a circle with its center
%ğŸ% at $(150, 100)$ and radius 75.

å®ä¾‹åŒ–ä¸€ä¸ªåœ†å¿ƒ {\em (center)} ä¸º $(150, 100)$ ï¼ŒåŠå¾„ {\em (radius)} ä¸º $75$ çš„ {\em \li{Circle}} å¯¹è±¡ã€‚

%ğŸ% Write a function named \verb"point_in_circle" that takes a Circle and
%ğŸ% a Point and returns True if the Point lies in or on the boundary of
%ğŸ% the circle.

ç¼–å†™ä¸€ä¸ªåç§°ä¸º {\em \li{point_in_circle}} çš„å‡½æ•°ï¼Œè¯¥å‡½æ•°å¯ä»¥æ¥å—ä¸€ä¸ªåœ†ç±» {\em (\li{Circle})}å¯¹è±¡å’Œç‚¹ç±» {\em (\li{Point})} å¯¹è±¡ï¼Œç„¶ååˆ¤æ–­è¯¥ç‚¹æ˜¯å¦åœ¨åœ†å†…ã€‚ åœ¨åœ†å†…åˆ™è¿”å› {\em \li{True}} ã€‚

%ğŸ% Write a function named \verb"rect_in_circle" that takes a Circle and a
%ğŸ% Rectangle and returns True if the Rectangle lies entirely in or on the boundary
%ğŸ% of the circle.

ç¼–å†™ä¸€ä¸ªåç§°ä¸º {\em \li{rect_in_circle}} çš„å‡½æ•°ï¼Œè¯¥å‡½æ•°æ¥å—ä¸€ä¸ªåœ†ç±» {\em (\li{Circle})} å¯¹è±¡å’ŒçŸ©å½¢ {\em (\li{Rectangle})}å¯¹è±¡ï¼Œå¦‚æœè¯¥çŸ©å½¢æ˜¯å¦å®Œå…¨åœ¨åœ†å†…æˆ–è€…åœ¨åœ†ä¸Šåˆ™è¿”å› {\em \li{True}} ã€‚

%ğŸ% Write a function named \verb"rect_circle_overlap" that takes a Circle
%ğŸ% and a Rectangle and returns True if any of the corners of the Rectangle fall
%ğŸ% inside the circle.  Or as a more challenging version, return True if
%ğŸ% any part of the Rectangle falls inside the circle.

ç¼–å†™ä¸€ä¸ªåä¸º {\em \li{rect_circle_overlap}} å‡½æ•°ï¼Œè¯¥å‡½æ•°æ¥å—ä¸€ä¸ªåœ†ç±»å¯¹è±¡å’Œä¸€ä¸ªçŸ©å½¢ç±»å¯¹è±¡ï¼Œå¦‚æœçŸ©å½¢æœ‰ä»»æ„ä¸€ä¸ªè§’è½åœ¨åœ†å†…åˆ™è¿”å› {\em \li{True}} ã€‚ æˆ–è€…å†™ä¸€ä¸ªæ›´å…·æœ‰æŒ‘æˆ˜æ€§çš„ç‰ˆæœ¬ï¼Œå¦‚æœè¯¥çŸ©å½¢æœ‰ä»»ä½•éƒ¨åˆ†è½åœ¨åœ†å†…è¿”å› {\em \li{True}} ã€‚

%ğŸ% Solution: \url{http://thinkpython2.com/code/Circle.py}.

\href{http://thinkpython2.com/code/Circle.py}{å‚è€ƒç­”æ¡ˆ}

\end{exercise}

\begin{exercise}

%ğŸ% Write a function called \verb"draw_rect" that takes a Turtle object
%ğŸ% and a Rectangle and uses the Turtle to draw the Rectangle.  See
%ğŸ% Chapter~\ref{turtlechap} for examples using Turtle objects.

ç¼–å†™ä¸€ä¸ªåä¸º {\em \li{draw_rect}} çš„å‡½æ•°ï¼Œè¯¥å‡½æ•°æ¥å—ä¸€ä¸ª {\em \li{Turtle}} å¯¹è±¡å’Œä¸€ä¸ª {\em \li{Rectangle}} å¯¹è±¡ï¼Œä½¿ç”¨ {\em \li{Turtle}} ç”»å‡ºè¯¥çŸ©å½¢ã€‚å‚è€ƒ \ref{turtlechap} ç« ä¸­ä½¿ç”¨ {\em \li{Turtle}} çš„ç¤ºä¾‹ã€‚

%ğŸ% Write a function called \verb"draw_circle" that takes a Turtle and
%ğŸ% a Circle and draws the Circle.

ç¼–å†™ä¸€ä¸ªåä¸ºã€€{\em \li{draw_circle}} çš„å‡½æ•°ï¼Œè¯¥å‡½æ•°æ¥å—ä¸€ä¸ª {\em \li{Turtle}} å¯¹è±¡å’Œ {\em \li{Circle}} å¯¹è±¡ï¼Œå¹¶ç”»å‡ºè¯¥åœ†ã€‚

%ğŸ% Solution: \url{http://thinkpython2.com/code/draw.py}.

\href{http://thinkpython2.com/code/draw.py}{å‚è€ƒç­”æ¡ˆ}

\end{exercise}