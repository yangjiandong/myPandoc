

%ğŸ% \chapter{Iteration  |  è¿­ä»£}
\chapter{è¿­ä»£}

%ğŸ% This chapter is about iteration, which is the ability to run
%ğŸ% a block of statements repeatedly.  We saw a kind of iteration,
%ğŸ% using recursion, in Section~\ref{recursion}.
%ğŸ% We saw another kind, using a {\tt for} loop,
%ğŸ% in Section~\ref{repetition}.  In this chapter we'll see yet another
%ğŸ% kind, using a {\tt while} statement.
%ğŸ% But first I want to say a little more about variable assignment.

æœ¬ç« ä»‹ç»è¿­ä»£ï¼Œå³é‡å¤è¿è¡ŒæŸä¸ªä»£ç å—çš„èƒ½åŠ›ã€‚æˆ‘ä»¬å·²ç»åœ¨~\ref{recursion} èŠ‚æ¥è§¦äº†ä¸€ç§åˆ©ç”¨é€’å½’è¿›è¡Œè¿­ä»£çš„æ–¹å¼ï¼›åœ¨~\ref{repetition} èŠ‚ä¸­ï¼Œæ¥è§¦äº†å¦ä¸€ç§åˆ©ç”¨ \li{for} å¾ªç¯è¿›è¡Œè¿­ä»£çš„æ–¹å¼ã€‚ åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬å°†è®¨è®ºå¦å¤–ä¸€ç§åˆ©ç”¨ \li{while} è¯­å¥å®ç°è¿­ä»£çš„æ–¹å¼ã€‚
ä¸è¿‡ï¼Œé¦–å…ˆæˆ‘æƒ³å†å¤šè°ˆè°ˆæœ‰å…³å˜é‡èµ‹å€¼çš„é—®é¢˜ã€‚

%ğŸ%  \section{Reassignment  |  é‡æ–°èµ‹å€¼}
\section{é‡æ–°èµ‹å€¼}
\index{assignment}  \index{statement!assignment}  \index{reassignment}
\index{èµ‹å€¼}  \index{è¯­å¥!èµ‹å€¼}  \index{é‡æ–°èµ‹å€¼}

%ğŸ% As you may have discovered, it is legal to make more than one
%ğŸ% assignment to the same variable.  A new assignment makes an existing
%ğŸ% variable refer to a new value (and stop referring to the old value).

å¯èƒ½ä½ å·²å‘ç°å¯¹åŒä¸€å˜é‡è¿›è¡Œå¤šæ¬¡èµ‹å€¼æ˜¯åˆæ³•çš„ã€‚ æ–°çš„èµ‹å€¼ä¼šä½¿å¾—å·²æœ‰çš„å˜é‡æŒ‡å‘
æ–°çš„å€¼ï¼ˆåŒæ—¶ä¸å†æŒ‡å‘æ—§çš„å€¼ï¼‰ã€‚

\begin{lstlisting}
>>> x = 5
>>> x
5
>>> x = 7
>>> x
7
\end{lstlisting}

%
%ğŸ% The first time we display
%ğŸ% {\tt x}, its value is 5; the second time, its
%ğŸ% value is 7.

ç¬¬ä¸€æ¬¡æ‰“å° \li{x} æ—¶ï¼Œ å®ƒçš„å€¼ä¸º \li{5}ï¼›ç¬¬äºŒæ¬¡æ‰“å°æ—¶ï¼Œå®ƒçš„å€¼æ˜¯ \li{7}ã€‚

%ğŸ% Figure~\ref{fig.assign2} shows what {\bf reassignment} looks
%ğŸ% like in a state diagram.
%ğŸ% \index{state diagram} \index{diagram!state}

å›¾~\ref{fig.assign2} å±•ç¤ºäº† {\bf é‡æ–°èµ‹å€¼} åœ¨çŠ¶æ€å›¾ä¸­çœ‹èµ·æ¥æ˜¯ä»€ä¹ˆæ ·å­ã€‚
\index{state diagram} \index{diagram!state}

%ğŸ% At this point I want to address a common source of confusion.
%ğŸ% Because Python uses the equal sign ({\tt =}) for assignment, it is
%ğŸ% tempting to interpret a statement like {\tt a = b} as a mathematical
%ğŸ% proposition of equality; that is, the claim that {\tt a} and
%ğŸ% {\tt b} are equal.  But this interpretation is wrong.
%ğŸ% \index{equality and assignment}

è¿™é‡Œæˆ‘æƒ³æ¢è®¨ä¸€ä¸ªå¸¸è§çš„ç–‘æƒ‘ç‚¹ã€‚ç”±äº Python ç”¨ç­‰å· (\li{=}) æ¥èµ‹å€¼ï¼Œæ‰€ä»¥å¾ˆå®¹æ˜“å°† \li{a = b} è¿™æ ·çš„è¯­å¥ç†è§£ä¸ºæ•°å­¦ä¸Šçš„ç›¸ç­‰å‘½é¢˜ï¼›å³ \li{a} å’Œ \li{b} ç›¸ç­‰ã€‚ä½†æ˜¯è¿™ç§ç†è§£æ˜¯é”™è¯¯çš„ã€‚

%ğŸ% First, equality is a symmetric relationship and assignment is not.  For
%ğŸ% example, in mathematics, if $a=7$ then $7=a$.  But in Python, the
%ğŸ% statement {\tt a = 7} is legal and {\tt 7 = a} is not.

é¦–å…ˆï¼Œç›¸ç­‰æ˜¯ä¸€ç§å¯¹ç§°å…³ç³»ï¼Œèµ‹å€¼ä¸æ˜¯ã€‚ä¾‹å¦‚ï¼Œåœ¨æ•°å­¦ä¸Šï¼Œå¦‚æœ $a = 7$ï¼Œ
åˆ™ $7 = a$ã€‚ ä½†æ˜¯åœ¨ Python ä¸­ï¼Œè¯­å¥ \li{a = 7} æ˜¯åˆæ³•çš„ï¼Œ \li{7 = a} åˆ™ä¸åˆæ³•ã€‚

%ğŸ% Also, in mathematics, a proposition of equality is either true or
%ğŸ% false for all time.  If $a=b$ now, then $a$ will always equal $b$.
%ğŸ% In Python, an assignment statement can make two variables equal, but
%ğŸ% they don't have to stay that way:

æ­¤å¤–ï¼Œæ•°å­¦ä¸­ï¼Œç›¸ç­‰å‘½é¢˜ä¸æ˜¯å¯¹çš„å°±æ˜¯é”™çš„ã€‚ å¦‚æœ $a = b$ï¼Œé‚£ä¹ˆ $a$
åˆ™æ˜¯æ°¸è¿œä¸ $b$ ç›¸ç­‰ã€‚åœ¨ Python ä¸­ï¼Œèµ‹å€¼è¯­å¥å¯ä»¥ä½¿å¾—ä¸¤ä¸ªå˜é‡ç›¸ç­‰ï¼Œ
ä½†æ˜¯è¿™ä¸¤ä¸ªå˜é‡ä¸ä¸€å®šå¿…é¡»ä¿æŒè¿™ä¸ªçŠ¶æ€ï¼š


\begin{lstlisting}
>>> a = 5
>>> b = a    # a and b are now equal
>>> a = 3    # a and b are no longer equal
>>> b
5
\end{lstlisting}

%
%ğŸ% The third line changes the value of {\tt a} but does not change the
%ğŸ% value of {\tt b}, so they are no longer equal.

ç¬¬ä¸‰è¡Œæ”¹å˜äº† \li{a} çš„å€¼ï¼Œä½†æ˜¯æ²¡æœ‰æ”¹å˜ \li{b} çš„å€¼ï¼Œæ‰€ä»¥å®ƒä»¬ä¸å†ç›¸ç­‰äº†ã€‚

%ğŸ% Reassigning variables is often useful, but you should use it
%ğŸ% with caution.  If the values of variables change frequently, it can
%ğŸ% make the code difficult to read and debug.

ç»™å˜é‡é‡æ–°èµ‹å€¼éå¸¸æœ‰ç”¨ï¼Œä½†æ˜¯éœ€è¦å°å¿ƒä½¿ç”¨ã€‚ å¯¹å˜é‡é¢‘ç¹é‡æ–°èµ‹å€¼ä¼šä½¿ä»£ç éš¾äºé˜…è¯»ï¼Œ
ä¸æ˜“è°ƒè¯•ã€‚

\begin{figure}
\centerline
{\includegraphics[scale=0.99]{../source/figs/assign2.pdf}}
% \caption {State diagram.}
\caption {é‡æ–°èµ‹å€¼çš„çŠ¶æ€å›¾ã€‚}
\label{fig.assign2}
\end{figure}


%ğŸ% \section{Updating variables  |  æ›´æ–°å˜é‡}
\section{æ›´æ–°å˜é‡}
\label{update}

\index{update}  \index{variable!updating}
\index{æ›´æ–°}  \index{å˜é‡!æ›´æ–°}

%ğŸ% A common kind of reassignment is an {\bf update},
%ğŸ% where the new value of the variable depends on the old.

é‡æ–°èµ‹å€¼çš„ä¸€ä¸ªå¸¸è§æ–¹å¼æ˜¯ {\em æ›´æ–°} (update) ï¼Œ æ›´æ–°æ“ä½œä¸­å˜é‡çš„æ–°å€¼ä¼šå–å†³äºæ—§å€¼ã€‚


\begin{lstlisting}
>>> x = x + 1
\end{lstlisting}

%
%ğŸ% This means ``get the current value of {\tt x}, add one, and then
%ğŸ% update {\tt x} with the new value.''

è¿™ä¸ªè¯­å¥çš„æ„æ€æ˜¯ï¼Œ``è·å¾— \li{x} çš„å½“å‰å€¼å¹¶ä¸ \li{1} åšåŠ æ³•æ±‚å’Œï¼Œç„¶åå°† \li{x} çš„å€¼æ›´æ–°ä¸ºæ‰€æ±‚çš„å’Œã€‚''

%ğŸ% If you try to update a variable that doesn't exist, you get an
%ğŸ% error, because Python evaluates the right side before it assigns
%ğŸ% a value to {\tt x}:

å¦‚æœè¯•å›¾å»æ›´æ–°ä¸€ä¸ªä¸å­˜åœ¨çš„å˜é‡ï¼Œåˆ™ä¼šè¿”å›ä¸€ä¸ªé”™è¯¯ã€‚ è¿™æ˜¯å› ä¸º Python æ˜¯å…ˆæ±‚
å¼å­å³è¾¹çš„å€¼ï¼Œç„¶åå†æŠŠæ‰€æ±‚çš„å€¼èµ‹ç»™ \li{x}ï¼š

\begin{lstlisting}
>>> x = x + 1
NameError: name 'x' is not defined
\end{lstlisting}

%
%ğŸ% Before you can update a variable, you have to {\bf initialize}
%ğŸ% it, usually with a simple assignment:
%ğŸ% \index{initialization (before update)}

åœ¨æ›´æ–°å˜é‡ä¹‹å‰ï¼Œä½ å¾—å…ˆ {\em åˆå§‹åŒ–} (initialize) å®ƒï¼Œé€šå¸¸æ˜¯é€šè¿‡ä¸€ä¸ªç®€å•çš„èµ‹å€¼å®ç°ï¼š
\index{initialization (before update)}
\index{åˆå§‹åŒ–}

\begin{lstlisting}
>>> x = 0
>>> x = x + 1
\end{lstlisting}

%
%ğŸ% Updating a variable by adding 1 is called an {\bf increment};
%ğŸ% subtracting 1 is called a {\bf decrement}.
%ğŸ% \index{increment}  \index{decrement}

é€šè¿‡åŠ  \li{1} æ¥æ›´æ–°å˜é‡å«åš {\em é€’å¢} (increment)ï¼› å‡ \li{1} å«åš {\em é€’å‡} (decrement)ã€‚
\index{increment}  \index{decrement}
\index{é€’å¢}  \index{é€’å‡}


%ğŸ% \section{The {\tt while} statement  |  {\tt while} è¯­å¥}
\section{{\tt while} è¯­å¥}

\index{statement!while}  \index{while loop}
\index{loop!while}  \index{iteration}


%ğŸ% Computers are often used to automate repetitive tasks.  Repeating
%ğŸ% identical or similar tasks without making errors is something that
%ğŸ% computers do well and people do poorly.  In a computer program,
%ğŸ% repetition is also called {\bf iteration}.

è®¡ç®—æœºç»å¸¸è¢«ç”¨æ¥è‡ªåŠ¨å¤„ç†é‡å¤æ€§çš„ä»»åŠ¡ã€‚
è®¡ç®—æœºå¾ˆæ“…é•¿æ— çº°æ¼åœ°é‡å¤ç›¸åŒæˆ–è€…ç›¸ä¼¼çš„ä»»åŠ¡ï¼Œ è€Œäººç±»åœ¨è¿™æ–¹é¢åšçš„ä¸å¥½ã€‚
åœ¨è®¡ç®—æœºç¨‹åºä¸­ï¼Œ é‡å¤ä¹Ÿè¢«ç§°ä¸º {\em è¿­ä»£} (iteration)ã€‚

%ğŸ% We have already seen two functions, {\tt countdown} and
%ğŸ% \verb"print_n", that iterate using recursion.  Because iteration is so
%ğŸ% common, Python provides language features to make it easier.
%ğŸ% One is the {\tt for} statement we saw in Section~\ref{repetition}.
%ğŸ% We'll get back to that later.

æˆ‘ä»¬å·²ç»è§è¿‡ä¸¤ä¸ªåˆ©ç”¨é€’å½’æ¥è¿­ä»£çš„å‡½æ•°ï¼š \li{countdown} å’Œ \li{print_n} ã€‚ ç”±äºè¿­ä»£çš„ä½¿ç”¨éå¸¸æ™®éï¼Œ æ‰€ä»¥ Python æä¾›äº†ä½¿å…¶æ›´å®¹æ˜“å®ç°çš„è¯­è¨€ç‰¹æ€§ã€‚ å…¶ä¸­ä¹‹ä¸€å°±æ˜¯æˆ‘ä»¬åœ¨ \ref{repetition}~èŠ‚ çœ‹åˆ°çš„ \li{for} è¯­å¥ã€‚ åé¢æˆ‘ä»¬è¿˜ä¼šç»§ç»­ä»‹ç»ã€‚

% add hyperref of åé¢ here

%ğŸ% Another is the {\tt while} statement.  Here is a version of {\tt
%ğŸ% countdown} that uses a {\tt while} statement:

å¦å¤–ä¸€ä¸ªç”¨äºè¿­ä»£çš„è¯­å¥æ˜¯ \li{while} ã€‚ ä¸‹é¢æ˜¯ä½¿ç”¨ \li{while} è¯­å¥å®ç°çš„ \li{countdown}ï¼š

\begin{lstlisting}
def countdown(n):
    while n > 0:
        print(n)
        n = n - 1
    print('Blastoff!')
\end{lstlisting}

%
%ğŸ% You can almost read the {\tt while} statement as if it were English.
%ğŸ% It means, ``While {\tt n} is greater than 0,
%ğŸ% display the value of {\tt n} and then decrement
%ğŸ% {\tt n}.  When you get to 0, display the word {\tt Blastoff!}''
\index{flow of execution}

ä½ å¯ä»¥åƒè¯»è‹±è¯­å¥å­ä¸€æ ·æ¥è¯» \li{while} è¯­å¥ã€‚ å®ƒçš„æ„æ€æ˜¯ï¼š``åªè¦ \li{n} çš„å€¼å¤§äº \li{0}ï¼Œ åˆ™æ‰“å°å‡º \li{n} çš„å€¼ï¼Œç„¶åè®© \li{n} å‡ \li{1}ã€‚ å½“ \li{n} é€’å‡è‡³ \li{0} æ—¶ï¼Œæ‰“å°å•è¯ \li{Blastoff}ï¼''ã€‚

%ğŸ% More formally, here is the flow of execution for a {\tt while} statement:

æ›´æ­£å¼åœ°æ¥è¯´ï¼Œ\li{while} è¯­å¥çš„æ‰§è¡Œæµç¨‹å¦‚ä¸‹ï¼š

%ğŸ% \begin{enumerate}
%ğŸ%
%ğŸ% \item Determine whether the condition is true or false.
%ğŸ%
%ğŸ% \item If false, exit the {\tt while} statement
%ğŸ% and continue execution at the next statement.
%ğŸ%
%ğŸ% \item If the condition is true, run the
%ğŸ% body and then go back to step 1.
%ğŸ%
%ğŸ% \end{enumerate}

\begin{enumerate}

\item é¦–å…ˆåˆ¤æ–­æ¡ä»¶ä¸º {\bf çœŸ} è¿˜æ˜¯ä¸º {\bf å‡}ã€‚

\item å¦‚æœä¸ºå‡ï¼Œé€€å‡º \li{while} è¯­å¥ï¼Œç„¶åæ‰§è¡Œæ¥ä¸‹æ¥çš„è¯­å¥ï¼›

\item å¦‚æœæ¡ä»¶ä¸ºçœŸï¼Œåˆ™è¿è¡Œ \li{while} è¯­å¥ {\em å¾ªç¯ä¸»ä½“}ï¼Œè¿è¡Œå®Œå†è¿”å›ç¬¬ä¸€æ­¥ï¼›

\end{enumerate}

%ğŸ% This type of flow is called a loop because the third step
%ğŸ% loops back around to the top.
\index{condition}  \index{loop}  \index{body}

è¿™ç§å½¢å¼çš„æµç¨‹å«åš {\em å¾ªç¯} (loop)ï¼Œ å› ä¸ºç¬¬ä¸‰æ­¥ååˆå¾ªç¯å›åˆ°äº†ç¬¬ä¸€æ­¥ã€‚
\index{æ¡ä»¶}  \index{å¾ªç¯}  \index{å¾ªç¯ä½“}

%ğŸ% The body of the loop should change the value of one or more variables
%ğŸ% so that the condition becomes false eventually and the loop
%ğŸ% terminates.  Otherwise the loop will repeat forever, which is called
%ğŸ% an {\bf infinite loop}.  An endless source of amusement for computer
%ğŸ% scientists is the observation that the directions on shampoo,
%ğŸ% ``Lather, rinse, repeat'', are an infinite loop.
\index{infinite loop}  \index{loop!infinite}

å¾ªç¯ä¸»ä½“åº”è¯¥æ”¹å˜ä¸€ä¸ªæˆ–å¤šä¸ªå˜é‡çš„å€¼ï¼Œè¿™æ ·çš„è¯æ‰èƒ½è®©æ¡ä»¶åˆ¤æ–­æœ€ç»ˆå˜ä¸ºå‡ï¼Œ
ä»è€Œç»ˆæ­¢å¾ªç¯ã€‚ å¦åˆ™ï¼Œå¾ªç¯å°†ä¼šæ°¸è¿œé‡å¤ä¸‹å»ï¼Œè¿™è¢«ç§°ä¸º {\em æ— é™å¾ªç¯} (infinite loop)ã€‚ åœ¨è®¡ç®—æœºç§‘å­¦å®¶çœ‹æ¥ï¼Œæ´—å‘æ°´çš„ä½¿ç”¨è¯´æ˜ â€”â€” ``æŠ¹æ´—å‘æ°´ï¼Œ
æ¸…æ´—æ‰ï¼Œé‡å¤'' ä¾¿æ˜¯ä¸ªæ— é™å¾ªç¯ï¼Œè¿™æ€»æ˜¯ä¼šè®©ä»–ä»¬è§‰å¾—å¥½ç¬‘ã€‚
\index{æ— é™å¾ªç¯}  \index{å¾ªç¯!æ— é™}

%ğŸ% In the case of {\tt countdown}, we can prove that the loop
%ğŸ% terminates: if {\tt n} is zero or negative, the loop never runs.
%ğŸ% Otherwise, {\tt n} gets smaller each time through the
%ğŸ% loop, so eventually we have to get to 0.

å¯¹äº \li{countdown} æ¥è¯´ï¼Œæˆ‘ä»¬å¯ä»¥è¯æ˜å¾ªç¯æ˜¯ä¸€å®šä¼šç»ˆæ­¢çš„ï¼šå½“ n æ˜¯ 0 æˆ–è€…è´Ÿæ•°ï¼Œè¯¥å¾ªç¯å°±ä¸ä¼šæ‰§è¡Œï¼›ä¸ç„¶ n é€šè¿‡æ¯æ¬¡å¾ªç¯ä¹‹åæ…¢æ…¢å‡å°ï¼Œæœ€ç»ˆä¹Ÿæ˜¯ä¼šå˜æˆ 0 çš„ã€‚

%ğŸ% For some other loops, it is not so easy to tell.  For example:

æœ‰äº›å…¶ä»–å¾ªç¯ï¼Œå¯èƒ½å°±æ²¡é‚£ä¹ˆå¥½ç†è§£äº†ã€‚ä¾‹å¦‚ï¼š

\begin{lstlisting}
def sequence(n):
    while n != 1:
        print(n)
        if n % 2 == 0:        # n is even
            n = n / 2
        else:                 # n is odd
            n = n*3 + 1
\end{lstlisting}

%
%ğŸ% The condition for this loop is {\tt n != 1}, so the loop will continue
%ğŸ% until {\tt n} is {\tt 1}, which makes the condition false.

å¾ªç¯çš„æ¡ä»¶æ˜¯ \li{n != 1}ï¼Œæ‰€ä»¥å¾ªç¯ä¼šä¸€ç›´æ‰§è¡Œåˆ° \li{n} ç­‰äº \li{1}ï¼Œæ¡ä»¶åˆ¤æ–­ä¸ºå‡æ—¶å¾ªç¯æ‰ç»ˆæ­¢ã€‚

%ğŸ% Each time through the loop, the program outputs the value of {\tt n}
%ğŸ% and then checks whether it is even or odd.  If it is even, {\tt n} is
%ğŸ% divided by 2.  If it is odd, the value of {\tt n} is replaced with
%ğŸ% {\tt n*3 + 1}. For example, if the argument passed to {\tt sequence}
%ğŸ% is 3, the resulting values of {\tt n} are 3, 10, 5, 16, 8, 4, 2, 1.

æ¯æ¬¡å¾ªç¯ï¼Œè¯¥ç¨‹åºæ‰“å°å‡º \li{n} çš„å€¼ï¼Œç„¶åæ£€æŸ¥å®ƒæ˜¯å¶æ•°è¿˜æ˜¯å¥‡æ•°ã€‚å¦‚æœå®ƒæ˜¯å¶æ•°ï¼Œ
é‚£ä¹ˆ \li{n} å¯ä»¥è¢«2æ•´é™¤ï¼›å¦‚æœæ˜¯å¥‡æ•°ï¼Œåˆ™å®ƒçš„å€¼è¢«æ›¿æ¢ä¸º \li {n*3 + 1}ã€‚ ä¾‹å¦‚ï¼Œå¦‚æœä¼ é€’ç»™ \li{sequence} çš„å®å‚ä¸º3ï¼Œ é‚£ä¹ˆæ‰“å°å‡ºçš„ç»“æœå°†ä¼šæ˜¯ï¼š\li{3}ã€ \li{10}ã€ \li{5}ã€ \li{16}ã€ \li{8}ã€ \li{4}ã€ \li{2}ã€ \li{1}ã€‚

%ğŸ% Since {\tt n} sometimes increases and sometimes decreases, there is no
%ğŸ% obvious proof that {\tt n} will ever reach 1, or that the program
%ğŸ% terminates.  For some particular values of {\tt n}, we can prove
%ğŸ% termination.  For example, if the starting value is a power of two,
%ğŸ% {\tt n} will be even every time through the loop
%ğŸ% until it reaches 1. The previous example ends with such a sequence,
%ğŸ% starting with 16.
%ğŸ% \index{Collatz conjecture}

ç”±äº \li{n} çš„å€¼æ—¶å¢æ—¶å‡ï¼Œæ‰€ä»¥ä¸èƒ½è½»æ˜“ä¿è¯ \li{n} ä¼šæœ€ç»ˆå˜æˆ \li{1}ï¼Œ æˆ–è€…è¯´è¿™ä¸ªç¨‹åºèƒ½å¤Ÿç»ˆæ­¢ã€‚ å¯¹äºæŸäº›ç‰¹æ®Šçš„ \li{n} çš„å€¼ï¼Œå¯ä»¥å¾ˆå¥½åœ°è¯æ˜å®ƒæ˜¯å¯ä»¥ç»ˆæ­¢çš„ã€‚ ä¾‹å¦‚ï¼Œ å½“ \li{n} çš„åˆå§‹å€¼æ˜¯ \li{2} çš„å€æ•°æ—¶ï¼Œåˆ™æ¯æ¬¡å¾ªç¯å \li{n} ä¸€ç›´ä¸ºå¶æ•°ï¼Œ ç›´åˆ°æœ€ç»ˆå˜ä¸º \li{1}ã€‚ ä¸Šä¸€ä¸ªç¤ºä¾‹ä¸­ï¼Œç¨‹åºå°±æ‰“å°äº†ç±»ä¼¼çš„åºåˆ—ï¼Œ ä» \li{16} å¼€å§‹å…¨éƒ¨ä¸ºå¶æ•°ã€‚
\index{Collatz conjecture}

%ğŸ% The hard question is whether we can prove that this program terminates
%ğŸ% for {\em all} positive values of {\tt n}.  So far, no one has
%ğŸ% been able to prove it {\em or} disprove it!  (See
%ğŸ%   \url{http://en.wikipedia.org/wiki/Collatz_conjecture}.)

éš¾ç‚¹åœ¨äºæ˜¯å¦èƒ½è¯æ˜ç¨‹åºå¯¹äº {\bf æ‰€æœ‰} çš„æ­£æ•´æ•° \li{n} éƒ½ä¼šç»ˆæ­¢ã€‚ ç›®å‰ä¸ºæ­¢ï¼Œ
è¿˜æ²¡æœ‰äººè¯æ˜ {\bf æˆ–è€…} è¯ä¼ªè¯¥å‘½é¢˜\footnote{è§ï¼š\href{http://en.wikipedia.org/wiki/Collatz_conjecture}{è€ƒæ‹‰å…¹çŒœæƒ³}}ã€‚
\index{è€ƒæ‹‰å…¹çŒœæƒ³}  \index{ç»´åŸºç™¾ç§‘}

%ğŸ% As an exercise, rewrite the function \verb"print_n" from
%ğŸ% Section~\ref{recursion} using iteration instead of recursion.

æˆ‘ä»¬åšä¸ªç»ƒä¹ ï¼Œåˆ©ç”¨è¿­ä»£è€Œéé€’å½’ï¼Œé‡å†™ä¹‹å‰~\ref{recursion} èŠ‚ä¸­çš„ \li{print_n} å‡½æ•°ã€‚

%ğŸ% \section{{\tt break} }
\section{{\tt break} }
\index{break statement}  \index{statement!break}

%ğŸ% Sometimes you don't know it's time to end a loop until you get half
%ğŸ% way through the body.  In that case you can use the {\tt break}
%ğŸ% statement to jump out of the loop.

æœ‰äº›æ—¶å€™å¾ªç¯æ‰§è¡Œåˆ°ä¸€åŠä½ æ‰çŸ¥é“å¾ªç¯è¯¥ç»“æŸäº†ã€‚è¿™ç§æƒ…å†µä¸‹ï¼Œä½ å¯ä»¥ä½¿ç”¨ \li{break} è¯­å¥æ¥è·³å‡ºå¾ªç¯ã€‚

%ğŸ% For example, suppose you want to take input from the user until they
%ğŸ% type {\tt done}.  You could write:

ä¾‹å¦‚ï¼Œå‡è®¾ä½ æƒ³ä»ç”¨æˆ·é‚£é‡Œè·å–è¾“å…¥ï¼Œç›´åˆ°ç”¨æˆ·é”®å…¥ \li{'done'}ã€‚ ä½ å¯ä»¥è¿™ä¹ˆå†™ï¼š

\begin{lstlisting}
while True:
    line = input('> ')
    if line == 'done':
        break
    print(line)

print('Done!')
\end{lstlisting}

%
%ğŸ% The loop condition is {\tt True}, which is always true, so the
%ğŸ% loop runs until it hits the break statement.

å¾ªç¯æ¡ä»¶æ˜¯ \li{True}ï¼Œå…¶æ€»æ˜¯ä¸ºçœŸï¼Œæ‰€ä»¥è¯¥å¾ªç¯ä¼šä¸€ç›´æ‰§è¡Œç›´åˆ°ç¢°åˆ° \li{break}ã€‚

%ğŸ% Each time through, it prompts the user with an angle bracket.
%ğŸ% If the user types {\tt done}, the {\tt break} statement exits
%ğŸ% the loop.  Otherwise the program echoes whatever the user types
%ğŸ% and goes back to the top of the loop.  Here's a sample run:

æ¯æ¬¡å¾ªç¯æ—¶ï¼Œç¨‹åºéƒ½ä¼šç»™å‡ºä¸€ä¸ªå°–æ‹¬å· (\li{>}) æç¤ºã€‚ å¦‚æœç”¨æˆ·è¾“å…¥ \li{'done'}ï¼Œæ‰§è¡Œ \li{break} è¯­å¥è·³å‡ºå¾ªç¯ã€‚ å¦åˆ™ï¼Œ ç¨‹åºå°±ä¼šä¸€ç›´æ‰“å°å‡ºç”¨æˆ·æ‰€è¾“å…¥çš„å†…å®¹å¹¶ä¸”è·³åˆ°å¾ªç¯å¼€å§‹ï¼Œ 0ä»¥ä¸‹æ˜¯ä¸€ä¸ªè¿è¡Œç¤ºä¾‹ï¼š


\begin{lstlisting}
> not done
not done
> done
Done!
\end{lstlisting}

%
%ğŸ% This way of writing {\tt while} loops is common because you
%ğŸ% can check the condition anywhere in the loop (not just at the
%ğŸ% top) and you can express the stop condition affirmatively
%ğŸ% (``stop when this happens'') rather than negatively (``keep going
%ğŸ% until that happens'').

\li{while} å¾ªç¯çš„è¿™ç§å†™æ³•å¾ˆå¸¸è§ï¼Œ å› ä¸ºä½ å¯ä»¥åœ¨å¾ªç¯çš„ä»»ä½•åœ°æ–¹åˆ¤æ–­æ¡ä»¶
ï¼ˆè€Œä¸åªæ˜¯åœ¨å¾ªç¯å¼€å§‹ï¼‰ï¼Œ è€Œä¸”ä½ å¯ä»¥ç§¯æåœ°è¡¨è¾¾ç»ˆæ­¢æ¡ä»¶ï¼ˆ``å½“å‡ºç°è¿™ä¸ªæƒ…å†µæ˜¯ç»ˆæ­¢''ï¼‰ï¼Œ è€Œä¸æ˜¯æ¶ˆæåœ°è¡¨ç¤º ï¼ˆ``ç»§ç»­è¿è¡Œç›´åˆ°å‡ºç°è¿™ä¸ªæƒ…å†µ''ï¼‰ã€‚


%ğŸ% \section{Square roots  |  å¹³æ–¹æ ¹}
\section{å¹³æ–¹æ ¹}
\label{squareroot}
\index{square root}  \index{å¹³æ–¹æ ¹}

%ğŸ% Loops are often used in programs that compute
%ğŸ% numerical results by starting with an approximate answer and
%ğŸ% iteratively improving it.
\index{Newton's method}

å¾ªç¯å¸¸ç”¨äºè®¡ç®—æ•°å€¼çš„ç¨‹åºä¸­ï¼Œ è¿™ç±»ç¨‹åºä¸€èˆ¬ä»ä¸€ä¸ªå¤§æ¦‚çš„å€¼å¼€å§‹ï¼Œ ç„¶åè¿­ä»£å¼åœ°è¿›è¡Œæ”¹è¿›ã€‚
\index{ç‰›é¡¿æ³•}

%ğŸ% For example, one way of computing square roots is Newton's method.
%ğŸ% Suppose that you want to know the square root of $a$.  If you start
%ğŸ% with almost any estimate, $x$, you can compute a better
%ğŸ% estimate with the following formula:

ä¾‹å¦‚ï¼Œç‰›é¡¿æ³• (Newton's method) æ˜¯è®¡ç®—å¹³æ–¹æ ¹çš„ä¸€ç§æ–¹æ³•ã€‚ å‡è®¾ä½ æƒ³æ±‚ $a$ çš„å¹³æ–¹æ ¹ã€‚ å¦‚æœä½ ä»ä»»æ„ä¸€ä¸ªä¼°ç®—å€¼ $x$ å¼€å§‹ï¼Œ åˆ™å¯ä»¥åˆ©ç”¨ä¸‹é¢çš„å…¬å¼è®¡ç®—å‡ºæ›´ä¸ºè¾ƒä¸ºç²¾ç¡®çš„ä¼°ç®—å€¼ï¼š

\[ y = \frac{x + a/x}{2} \]

%
%ğŸ% For example, if $a$ is 4 and $x$ is 3:

ä¾‹å¦‚ï¼Œå‡å®š $a$ æ˜¯ 4ï¼Œ$x$ æ˜¯ 3ï¼š

\begin{lstlisting}
>>> a = 4
>>> x = 3
>>> y = (x + a/x) / 2
>>> y
2.16666666667
\end{lstlisting}

%
%ğŸ% The result is closer to the correct answer ($\sqrt{4} = 2$).  If we
%ğŸ% repeat the process with the new estimate, it gets even closer:

å¯ä»¥çœ‹åˆ°ï¼Œ ç»“æœä¸çœŸå®å€¼ ( $\sqrt{4} = 2$ ) å·²ç»å¾ˆæ¥è¿‘äº†ï¼Œ å¦‚æœæˆ‘ä»¬ç”¨è¿™ä¸ªå€¼
å†é‡æ–°è¿ç®—ä¸€éï¼Œ å®ƒå°†å¾—åˆ°æ›´ä¸ºæ¥è¿‘çš„å€¼ã€‚


\begin{lstlisting}
>>> x = y
>>> y = (x + a/x) / 2
>>> y
2.00641025641
\end{lstlisting}

%
%ğŸ% After a few more updates, the estimate is almost exact:
%ğŸ% \index{update}

å†é€šè¿‡å¤šå‡ æ¬¡çš„è¿ç®—ï¼Œè¿™ä¸ªä¼°ç®—å¯ä»¥è¯´å·²ç»æ˜¯å¾ˆç²¾ç¡®äº†ã€‚
\index{update}

\begin{lstlisting}
>>> x = y
>>> y = (x + a/x) / 2
>>> y
2.00001024003
>>> x = y
>>> y = (x + a/x) / 2
>>> y
2.00000000003
\end{lstlisting}

%
%ğŸ% In general we don't know ahead of time how many steps it takes
%ğŸ% to get to the right answer, but we know when we get there
%ğŸ% because the estimate
%ğŸ% stops changing:

ä¸€èˆ¬æ¥è¯´ï¼Œ æˆ‘ä»¬äº‹å…ˆä¸çŸ¥é“è¦å¤šå°‘æ­¥æ‰èƒ½å¾—åˆ°æ­£ç¡®ç­”æ¡ˆï¼Œ ä½†æ˜¯æˆ‘ä»¬çŸ¥é“å½“ä¼°ç®—å€¼ä¸å†å˜åŠ¨æ—¶ï¼Œ æˆ‘ä»¬å°±è·å¾—äº†æ­£ç¡®çš„ç­”æ¡ˆã€‚

\begin{lstlisting}
>>> x = y
>>> y = (x + a/x) / 2
>>> y
2.0
>>> x = y
>>> y = (x + a/x) / 2
>>> y
2.0
\end{lstlisting}

%
%ğŸ% When {\tt y == x}, we can stop.  Here is a loop that starts
%ğŸ% with an initial estimate, {\tt x}, and improves it until it
%ğŸ% stops changing:

å½“ \li{y == x} æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥åœæ­¢è®¡ç®—äº†ã€‚ä¸‹é¢è¿™ä¸ªå¾ªç¯å°±æ˜¯åˆ©ç”¨ä¸€ä¸ªåˆå§‹ä¼°å€¼ \li{x}ï¼Œ
å¾ªåºæ¸è¿›åœ°è®¡ç®—ï¼Œç›´åˆ°ä¼°å€¼ä¸å†å˜åŒ–ã€‚

\begin{lstlisting}
while True:
    print(x)
    y = (x + a/x) / 2
    if y == x:
        break
    x = y
\end{lstlisting}

%
%ğŸ% For most values of {\tt a} this works fine, but in general it is
%ğŸ% dangerous to test {\tt float} equality.
%ğŸ% Floating-point values are only approximately right:
%ğŸ% most rational numbers, like $1/3$, and irrational numbers, like
%ğŸ% $\sqrt{2}$, can't be represented exactly with a {\tt float}.
%ğŸ% \index{floating-point}  \index{epsilon}

å¯¹äºå¤§éƒ¨åˆ† \li{a} çš„å€¼ï¼Œè¿™ä¸ªç¨‹åºè¿è¡Œæ­£å¸¸ï¼Œä¸è¿‡ä¸€èˆ¬æ¥è¯´ï¼Œæ£€æŸ¥ä¸¤ä¸ªæµ®ç‚¹æ•°æ˜¯å¦ç›¸ç­‰æ¯”è¾ƒå±é™©ã€‚æµ®ç‚¹æ•°åªèƒ½å¤§çº¦è¡¨ç¤ºï¼šå¤§å¤šæ•°æœ‰ç†æ•°ï¼Œå¦‚ $1/3$ï¼Œä»¥åŠæ— ç†æ•°ï¼Œ
å¦‚ : $\sqrt{2}$ï¼Œæ˜¯ä¸èƒ½ç”¨æµ®ç‚¹æ•° ( \li{float} ) æ¥ç²¾ç¡®è¡¨ç¤ºçš„ã€‚
\index{floating-point}  \index{epsilon}

%ğŸ% Rather than checking whether {\tt x} and {\tt y} are exactly equal, it
%ğŸ% is safer to use the built-in function {\tt abs} to compute the
%ğŸ% absolute value, or magnitude, of the difference between them:

ä¸å…¶æ£€æŸ¥ \li{x} å’Œ \li{y} çš„å€¼æ˜¯å¦å®Œå…¨ç›¸ç­‰ï¼Œä½¿ç”¨å†…ç½®å‡½æ•° \li{abs} æ¥è®¡ç®—äºŒè€…ä¹‹å·®çš„ç»å¯¹å€¼æˆ–æ•°é‡çº§æ›´ä¸ºå®‰å…¨ï¼š

\begin{lstlisting}
    if abs(y-x) < epsilon:
        break
\end{lstlisting}

%
%ğŸ% Where \verb"epsilon" has a value like {\tt 0.0000001} that
%ğŸ% determines how close is close enough.

è¿™é‡Œï¼Œå˜é‡ \li{epsilon} æ˜¯ä¸€ä¸ªå†³å®šå…¶ç²¾ç¡®åº¦çš„å€¼ï¼Œå¦‚ \li{0.0000001}ã€‚

%ğŸ% \section{Algorithms  |  ç®—æ³•}
\section{ç®—æ³•}
\index{algorithm}  \index{ç®—æ³•}

%ğŸ% Newton's method is an example of an {\bf algorithm}: it is a
%ğŸ% mechanical process for solving a category of problems (in this
%ğŸ% case, computing square roots).

ç‰›é¡¿æ³•å°±æ˜¯ä¸€ä¸ª {\em ç®—æ³•} (Algorithm) ç¤ºä¾‹ï¼š å®ƒæ˜¯è§£å†³ä¸€ç±»é—®é¢˜çš„è®¡ç®—æœºåˆ¶ (æœ¬ä¾‹ä¸­æ˜¯è®¡ç®—å¹³æ–¹æ ¹)ã€‚

%ğŸ% To understand what an algorithm is, it might help to start with
%ğŸ% something that is not an algorithm.  When you learned to multiply
%ğŸ% single-digit numbers, you probably memorized the multiplication table.
%ğŸ% In effect, you memorized 100 specific solutions.  That kind of
%ğŸ% knowledge is not algorithmic.

ä¸ºäº†ç†è§£ç®—æ³•æ˜¯ä»€ä¹ˆï¼Œå…ˆäº†è§£ä»€ä¹ˆä¸æ˜¯ç®—æ³•æˆ–è®¸æœ‰ç‚¹å¸®åŠ©ã€‚ ä½ åœ¨å­¦ä¹ ä¸€ä½æ•°ä¹˜æ³•æ—¶ï¼Œ
å¯èƒ½èƒŒå‡ºäº†ä¹˜æ³•è¡¨ã€‚ å®é™…ä¸Šï¼Œä½ åªæ˜¯è®°ä½äº† 100 ä¸ªç¡®åˆ‡çš„ç­”æ¡ˆã€‚ è¿™ç§çŸ¥è¯†å¹¶{\bf ä¸æ˜¯}ç®—æ³•æ€§çš„ã€‚

%ğŸ% But if you were ``lazy'', you might have learned a few
%ğŸ% tricks.  For example, to find the product of $n$ and 9, you can
%ğŸ% write $n-1$ as the first digit and $10-n$ as the second
%ğŸ% digit.  This trick is a general solution for multiplying any
%ğŸ% single-digit number by 9.  That's an algorithm!
%ğŸ% \index{addition with carrying}  \index{carrying, addition with}
%ğŸ% \index{subtraction!with borrowing}  \index{borrowing, subtraction with}

ä¸è¿‡ï¼Œ å¦‚æœä½ æƒ³æ‰¾ ``æ‡’äººæ–¹æ³•''ï¼Œ ä½ å¯èƒ½å°±ä¼šæ‰¾åˆ°ä¸€äº›è¯€çªã€‚ æ¯”å¦‚ä¸ºäº†è®¡ç®— $n$
å’Œ $9$ çš„ä¹˜ç§¯ï¼Œä½ å¯ä»¥æŠŠ $n-1$ ä½œä¸ºä¹˜ç§¯çš„ç¬¬ä¸€ä½æ•°ï¼Œå†æŠŠ $10-n$
ä½œä¸ºç¬¬äºŒä½æ•°ï¼Œä»è€Œå¾—åˆ°å®ƒä»¬çš„ä¹˜ç§¯ã€‚ è¿™ä¸ªè¯€çªæ˜¯å°†ä»»æ„ä¸ªä½æ•°
ä¸ $9$ ç›¸ä¹˜çš„æ™®éè§£æ³•ã€‚ è¿™å°±{\bf æ˜¯}ä¸€ç§ç®—æ³•ã€‚
\index{addition with carrying}  \index{carrying, addition with}
\index{subtraction!with borrowing}  \index{borrowing, subtraction with}

%ğŸ% Similarly, the techniques you learned for addition with carrying,
%ğŸ% subtraction with borrowing, and long division are all algorithms.  One
%ğŸ% of the characteristics of algorithms is that they do not require any
%ğŸ% intelligence to carry out.  They are mechanical processes where
%ğŸ% each step follows from the last according to a simple set of rules.

ç±»ä¼¼åœ°ï¼Œä½ æ‰€å­¦è¿‡çš„è¿›ä½åŠ æ³•ã€å€Ÿä½å‡æ³•ã€ä»¥åŠé•¿é™¤æ³•éƒ½æ˜¯ç®—æ³•ã€‚ç®—æ³•çš„ç‰¹ç‚¹ä¹‹ä¸€
å°±æ˜¯ä¸éœ€è¦è¿‡å¤šçš„è„‘åŠ›è®¡ç®—ã€‚ç®—æ³•æ˜¯ä¸€ä¸ªæœºæ¢°çš„è¿‡ç¨‹ï¼Œæ¯ä¸€æ­¥éƒ½æ˜¯ä¾
æ®ä¸€ç»„ç®€å•çš„è§„åˆ™è·Ÿç€ä¸Šä¸€æ­¥æ¥æ‰§è¡Œçš„ã€‚

%ğŸ% Executing algorithms is boring, but designing them is interesting,
%ğŸ% intellectually challenging, and a central part of computer science.

æ‰§è¡Œç®—æ³•çš„è¿‡ç¨‹æ˜¯å¾ˆä¹å‘³çš„ï¼Œä½†æ˜¯è®¾è®¡ç®—æ³•å°±æ¯”è¾ƒæœ‰è¶£äº†ï¼Œä¸ä½†æ˜¯æ™º
åŠ›ä¸Šçš„æŒ‘æˆ˜ï¼Œæ›´æ˜¯è®¡ç®—æœºç§‘å­¦çš„æ ¸å¿ƒã€‚

%ğŸ% Some of the things that people do naturally, without difficulty or
%ğŸ% conscious thought, are the hardest to express algorithmically.
%ğŸ% Understanding natural language is a good example.  We all do it, but
%ğŸ% so far no one has been able to explain {\em how} we do it, at least
%ğŸ% not in the form of an algorithm.

ä¸€äº›äººä»¬è‡ªç„¶è€Œç„¶æ— éœ€ä¸‹æ„è¯†åšåˆ°çš„äº‹æƒ…ï¼Œå¾€å¾€æ˜¯éš¾äºç”¨ç®—æ³•è¡¨è¾¾ã€‚ ç†è§£è‡ªç„¶è¯­è¨€å°±æ˜¯è¿™æ ·çš„ã€‚ æˆ‘ä»¬æ¯ä¸ªäººéƒ½å¬å¾—æ‡‚è‡ªç„¶è¯­è¨€ï¼Œ ä½†æ˜¯ç›®å‰è¿˜æ²¡æœ‰äººèƒ½å¤Ÿè§£é‡Šæˆ‘ä»¬æ˜¯ {\bf æ€ä¹ˆ} åšåˆ°çš„ï¼Œ è‡³å°‘æ— æ³•ä»¥ç®—æ³•çš„å½¢å¼è§£é‡Šã€‚

%ğŸ% \section{Debugging  |  è°ƒè¯•}
\section{è°ƒè¯•}
\label{bisectbug}

%ğŸ% As you start writing bigger programs, you might find yourself
%ğŸ% spending more time debugging.  More code means more chances to
%ğŸ% make an error and more places for bugs to hide.
%ğŸ% \index{debugging!by bisection}  \index{bisection, debugging by}

å½“ä½ å¼€å§‹å†™æ›´ä¸ºå¤æ‚çš„ç¨‹åºæ—¶ï¼Œä½ ä¼šå‘ç°å¤§éƒ¨åˆ†æ—¶é—´éƒ½èŠ±è´¹åœ¨è°ƒè¯•ä¸Šã€‚ æ›´å¤šçš„
ä»£ç æ„å‘³ç€æ›´é«˜çš„å‡ºé”™æ¦‚ç‡ï¼Œå¹¶ä¸”ä¼šæœ‰æ›´å¤šéšè— bug çš„åœ°æ–¹ã€‚
\index{debugging!by bisection}  \index{bisection, debugging by}

%ğŸ% One way to cut your debugging time is ``debugging by bisection''.
%ğŸ% For example, if there are 100 lines in your program and you
%ğŸ% check them one at a time, it would take 100 steps.

å‡å°‘è°ƒè¯•æ—¶é—´çš„ä¸€ä¸ªæ–¹æ³•å°±æ˜¯â€œå¯¹åˆ†è°ƒè¯•â€ã€‚ä¾‹å¦‚ï¼Œå¦‚æœç¨‹åºæœ‰100è¡Œï¼Œä½ ä¸€æ¬¡æ£€æŸ¥ä¸€è¡Œï¼Œå°±éœ€è¦100æ­¥ã€‚

%ğŸ% Instead, try to break the problem in half.  Look at the middle
%ğŸ% of the program, or near it, for an intermediate value you
%ğŸ% can check.  Add a {\tt print} statement (or something else
%ğŸ% that has a verifiable effect) and run the program.

ç›¸åï¼Œ è¯•ç€å°†é—®é¢˜æ‹†ä¸ºä¸¤åŠã€‚ åœ¨ä»£ç ä¸­é—´éƒ¨åˆ†æˆ–è€…é™„è¿‘çš„åœ°æ–¹ï¼Œ å¯»æ‰¾ä¸€ä¸ªå¯ä»¥æ£€æŸ¥çš„ä¸­é—´å€¼ã€‚ åŠ ä¸Šä¸€è¡Œ \li{print} è¯­å¥ (æˆ–æ˜¯å…¶ä»–å…·æœ‰å¯éªŒè¯æ•ˆæœçš„ä»£ç )ï¼Œ ç„¶åè¿è¡Œç¨‹åºã€‚

%ğŸ% If the mid-point check is incorrect, there must be a problem in the
%ğŸ% first half of the program.  If it is correct, the problem is
%ğŸ% in the second half.

å¦‚æœä¸­é—´ç‚¹æ£€æŸ¥å‡ºé”™äº†ï¼Œ é‚£ä¹ˆå°±è¯´æ˜ç¨‹åºçš„å‰åŠéƒ¨åˆ†å­˜åœ¨é—®é¢˜ã€‚ å¦‚æœæ²¡é—®é¢˜ï¼Œ åˆ™è¯´æ˜æ˜¯ååŠéƒ¨åˆ†å‡ºé”™äº†ã€‚

%ğŸ% Every time you perform a check like this, you halve the number of
%ğŸ% lines you have to search.  After six steps (which is fewer than 100),
%ğŸ% you would be down to one or two lines of code, at least in theory.

æ¯æ¬¡ä½ éƒ½è¿™æ ·æ£€æŸ¥ï¼Œ å°±å¯ä»¥å°†éœ€è¦æœç´¢çš„ä»£ç è¡Œæ•°å‡å°‘ä¸€åŠã€‚ ç»è¿‡6æ­¥ä¹‹å (è¿™æ¯”100å°å¤šäº†)ï¼Œ ä½ å°†ä¼šæ‰¾åˆ°é‚£æˆ–è€…ä¸¤è¡Œå‡ºé”™çš„ä»£ç ï¼Œ è‡³å°‘ç†è®ºä¸Šæ˜¯è¿™æ ·ã€‚

%ğŸ% In practice it is not always clear what
%ğŸ% the ``middle of the program'' is and not always possible to
%ğŸ% check it.  It doesn't make sense to count lines and find the
%ğŸ% exact midpoint.  Instead, think about places
%ğŸ% in the program where there might be errors and places where it
%ğŸ% is easy to put a check.  Then choose a spot where you
%ğŸ% think the chances are about the same that the bug is before
%ğŸ% or after the check.

åœ¨å®è·µä¸­ï¼Œ å¯èƒ½å¹¶ä¸èƒ½å¾ˆå¥½çš„ç¡®å®šç¨‹åºçš„ ``ä¸­é—´éƒ¨åˆ†'' æ˜¯ä»€ä¹ˆï¼Œ ä¹Ÿæœ‰å¯èƒ½å¹¶ä¸æ˜¯é‚£ä¹ˆå¥½æ£€æŸ¥ã€‚
è®¡ç®—è¡Œæ•°å¹¶ä¸”å–å…¶ä¸­é—´è¡Œæ˜¯æ²¡æœ‰æ„ä¹‰çš„ã€‚ ç›¸åï¼Œ å¤šè€ƒè™‘ä¸‹ç¨‹åºä¸­å“ªäº›åœ°æ–¹æ¯”è¾ƒå®¹æ˜“å‡ºé—®é¢˜ï¼Œ æˆ–è€…å“ªäº›åœ°æ–¹æ¯”è¾ƒå®¹æ˜“è¿›è¡Œæ£€æŸ¥ã€‚ ç„¶åé€‰å®šä¸€ä¸ªæ£€æŸ¥ç‚¹ï¼Œ åœ¨è¿™ä¸ªæ–­ç‚¹å‰åå‡ºç°bugçš„æ¦‚å¿µå·®ä¸å¤šã€‚

%ğŸ% \section{Glossary  |  æœ¯è¯­è¡¨}
\section{æœ¯è¯­è¡¨}

\begin{description}

%ğŸ% \item[reassignment:] Assigning a new value to a variable that
%ğŸ% already exists.
%ğŸ% \index{reassignment}

\item[é‡æ–°èµ‹å€¼ (reassignment)ï¼š] ç»™å·²ç»å­˜åœ¨çš„å˜é‡èµ‹ä¸€ä¸ªæ–°çš„å€¼ã€‚
\index{reassignment}

%ğŸ% \item[update:] An assignment where the new value of the variable
%ğŸ% depends on the old.
%ğŸ% \index{update}

\item[æ›´æ–° (update)ï¼š] å˜é‡çš„æ–°å€¼å–å†³äºæ—§å€¼çš„ä¸€ç§èµ‹å€¼æ–¹æ³•ã€‚
\index{update}

%ğŸ% \item[initialization:] An assignment that gives an initial value to
%ğŸ% a variable that will be updated.
%ğŸ% \index{initialization!variable}

\item[åˆå§‹åŒ– (initialize)ï¼š] ç»™åé¢å°†è¦æ›´æ–°çš„å˜é‡ä¸€ä¸ªåˆå§‹å€¼çš„ä¸€ç§èµ‹å€¼æ–¹æ³•ã€‚
\index{initialization!variable}

%ğŸ% \item[increment:] An update that increases the value of a variable
%ğŸ% (often by one).
%ğŸ% \index{increment}

\item[é€’å¢ (increment)ï¼š] é€šè¿‡å¢åŠ å˜é‡çš„å€¼çš„æ–¹å¼æ›´æ–°å˜é‡ (é€šå¸¸æ˜¯åŠ  1)ã€‚
\index{increment}

%ğŸ% \item[decrement:] An update that decreases the value of a variable.
%ğŸ% \index{decrement}

\item[é€’å‡ (decrement)ï¼š] é€šè¿‡å‡å°‘å˜é‡çš„å€¼çš„æ–¹å¼æ¥æ›´æ–°å˜é‡ã€‚
\index{decrement}

%ğŸ% \item[iteration:] Repeated execution of a set of statements using
%ğŸ% either a recursive function call or a loop.
%ğŸ% \index{iteration}

\item[è¿­ä»£ (iteration)ï¼š] åˆ©ç”¨é€’å½’æˆ–è€…å¾ªç¯çš„æ–¹å¼æ¥é‡å¤æ‰§è¡Œä»£ä¸€ç»„è¯­å¥çš„è¿‡ç¨‹ã€‚
\index{iteration}

%ğŸ% \item[infinite loop:] A loop in which the terminating condition is
%ğŸ% never satisfied.
%ğŸ% \index{infinite loop}

\item[æ— é™å¾ªç¯ (infinite loop)ï¼š] æ— æ³•æ»¡è¶³ç»ˆæ­¢æ¡ä»¶çš„å¾ªç¯ã€‚
\index{infinite loop}

%ğŸ% \item[algorithm:]  A general process for solving a category of
%ğŸ% problems.
%ğŸ% \index{algorithm}

\item[ç®—æ³• (algorithm)ï¼š] è§£å†³ä¸€ç±»é—®é¢˜çš„é€šç”¨è¿‡ç¨‹ã€‚
\index{algorithm}

\end{description}

%ğŸ% \section{Exercises  |  ç»ƒä¹ }
\section{ç»ƒä¹ }

\begin{exercise}
\index{algorithm!square root}

%ğŸ% Copy the loop from Section~\ref{squareroot}
%ğŸ% and encapsulate it in a function called
%ğŸ% \verb"mysqrt" that takes {\tt a} as a parameter, chooses a
%ğŸ% reasonable value of {\tt x}, and returns an estimate of the square
%ğŸ% root of {\tt a}.  \index{encapsulation}

å¤åˆ¶{\em \ref{squareroot}}~å°èŠ‚ä¸­çš„å¾ªç¯ï¼Œ å°†å…¶å°è£…è¿›ä¸€ä¸ªå« {\em \li{mysqrt}} çš„å‡½æ•°ä¸­ã€‚ è¿™ä¸ªå‡½æ•°æ¥å— {\em \li{a}} ä½œä¸ºå½¢å‚ï¼Œé€‰æ‹©ä¸€ä¸ªåˆé€‚çš„ {\em \li{x}} å€¼ï¼Œå¹¶è¿”å› {\em \li{a}} çš„å¹³æ–¹æ ¹ä¼°ç®—å€¼ã€‚

%ğŸ% To test it, write a function named \verb"test_square_root"
%ğŸ% that prints a table like this:

ä¸ºæµ‹è¯•ä¸Šé¢çš„å‡½æ•°ï¼Œç¼–å†™ä¸€ä¸ªåä¸º {\em \li{test_squre_root}} çš„å‡½æ•°ï¼Œæ‰“å°å‡ºå¦‚ä¸‹è¡¨æ ¼ï¼š

\begin{em}
\begin{lstlisting}
a   mysqrt(a)     math.sqrt(a)  diff
-   ---------     ------------  ----
1.0 1.0           1.0           0.0
2.0 1.41421356237 1.41421356237 2.22044604925e-16
3.0 1.73205080757 1.73205080757 0.0
4.0 2.0           2.0           0.0
5.0 2.2360679775  2.2360679775  0.0
6.0 2.44948974278 2.44948974278 0.0
7.0 2.64575131106 2.64575131106 0.0
8.0 2.82842712475 2.82842712475 4.4408920985e-16
9.0 3.0           3.0           0.0
\end{lstlisting}
\end{em}

%
%ğŸ% The first column is a number, $a$; the second column is the square
%ğŸ% root of $a$ computed with \verb"mysqrt"; the third column is the
%ğŸ% square root computed by {\tt math.sqrt}; the fourth column is the
%ğŸ% absolute value of the difference between the two estimates.

å…¶ä¸­ç¬¬ä¸€åˆ—æ˜¯ $a$ çš„å€¼ï¼›ç¬¬äºŒåˆ—æ˜¯é€šè¿‡ {\em \li{mysqrt}} è®¡ç®—å¾—åˆ°çš„ $a$ çš„å¹³æ–¹æ ¹ï¼› ç¬¬ä¸‰åˆ—æ˜¯ç”¨ {\em \li{math.sqrt}} è®¡ç®—å¾—åˆ°çš„å¹³æ–¹æ ¹ï¼› ç¬¬å››åˆ—åˆ™æ˜¯è¿™ä¸¤ä¸ªå¹³æ–¹æ ¹ä¹‹å·®çš„ç»å¯¹å€¼ã€‚

\end{exercise}


\begin{exercise}
\index{eval function}  \index{function!eval}

%ğŸ% The built-in function {\tt eval} takes a string and evaluates
%ğŸ% it using the Python interpreter.  For example:

å†…ç½®å‡½æ•° {\em \li{eval}} æ¥å—ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œå¹¶ä½¿ç”¨ {\em Python} è§£é‡Šå™¨æ¥è®¡ç®—è¯¥å­—ç¬¦ä¸²ã€‚ä¾‹å¦‚ï¼š

\begin{em}
\begin{lstlisting}
>>> eval('1 + 2 * 3')
7
>>> import math
>>> eval('math.sqrt(5)')
2.2360679774997898
>>> eval('type(math.pi)')
<class 'float'>
\end{lstlisting}
\end{em}

%
%ğŸ% Write a function called \verb"eval_loop" that iteratively
%ğŸ% prompts the user, takes the resulting input and evaluates
%ğŸ% it using {\tt eval}, and prints the result.

ç¼–å†™ä¸€ä¸ªåä¸º {\em \li{eval_loop}} çš„å‡½æ•°ï¼Œè¿­ä»£å¼åœ°æç¤ºç”¨æˆ·è¾“å…¥ï¼Œ è·å–è¾“å…¥çš„å†…å®¹ï¼Œå¹¶åˆ©ç”¨ {\em \li{eval}} æ¥è®¡ç®—å…¶å€¼ï¼Œæœ€åæ‰“å°è¯¥å€¼ã€‚

%ğŸ% It should continue until the user enters \verb"'done'", and then
%ğŸ% return the value of the last expression it evaluated.

è¯¥ç¨‹åºåº”æŒç»­è¿è¡Œï¼Œ çŸ¥é“ç”¨æˆ·è¾“å…¥ {\em \li{'done'}}ï¼Œ ç„¶åè¿”å›å®ƒæœ€åä¸€æ¬¡è®¡ç®—çš„è¡¨è¾¾å¼çš„å€¼ã€‚

\end{exercise}


\begin{exercise}
\index{Ramanujan, Srinivasa}

%ğŸ% The mathematician Srinivasa Ramanujan found an
%ğŸ% infinite series
%ğŸ% that can be used to generate a numerical
%ğŸ% approximation of $1 / \pi$:
\index{pi}

æ•°å­¦å®¶æ–¯é‡Œå°¼ç“¦ç‘ŸÂ·æ‹‰é©¬åŠªé‡‘ {\em (Srinivasa Ramanujan)} å‘ç°äº†ä¸€ä¸ªå¯ä»¥ç”¨æ¥ç”Ÿæˆ $1 / \pi$
è¿‘ä¼¼å€¼çš„æ— ç©·çº§æ•° {\em (infinite series)}ï¼š

\[ \frac{1}{\pi} = \frac{2\sqrt{2}}{9801}
\sum^\infty_{k=0} \frac{(4k)!(1103+26390k)}{(k!)^4 396^{4k}} \]

%ğŸ% Write a function called \verb"estimate_pi" that uses this formula
%ğŸ% to compute and return an estimate of $\pi$.  It should use a {\tt while}
%ğŸ% loop to compute terms of the summation until the last term is
%ğŸ% smaller than {\tt 1e-15} (which is Python notation for $10^{-15}$).
%ğŸ% You can check the result by comparing it to {\tt math.pi}.

ç¼–å†™ä¸€ä¸ªåä¸º {\em \li{estimate_pi}} çš„å‡½æ•°ï¼Œåˆ©ç”¨ä¸Šé¢å…¬å¼æ¥ä¼°ç®—å¹¶è¿”å› $\pi$
çš„å€¼ã€‚ è¿™ä¸ªå‡½æ•°åº”è¯¥ä½¿ç”¨ {\em \li{while}} å¾ªç¯æ¥è®¡ç®—æ‰€æœ‰é¡¹çš„å’Œï¼Œ ç›´åˆ°æœ€åä¸€é¡¹å°äº {\em \li{1e-15}} {\em (Python} ä¸­ç”¨äºè¡¨è¾¾ $10^{-15}$ çš„å†™æ³•{\em )} æ—¶ç»ˆæ­¢å¾ªç¯ã€‚ ä½ å¯ä»¥å°†è¯¥å€¼ä¸ {\em \li{math.pi}} è¿›è¡Œæ¯”è¾ƒï¼Œ æ£€æµ‹æ˜¯å¦å‡†ç¡®ã€‚

%ğŸ% Solution: \url{http://thinkpython2.com/code/pi.py}.

\href{http://thinkpython2.com/code/pi.py}{å‚è€ƒç­”æ¡ˆ}

\end{exercise}
