

%ğŸ% \chapter{Case study: word play  |  æ–‡å­—æ¸¸æˆ}
\chapter{æ¡ˆä¾‹ç ”ç©¶ï¼šæ–‡å­—æ¸¸æˆ}
\label{wordplay}

%ğŸ% This chapter presents the second case study, which involves
%ğŸ% solving word puzzles by searching for words that have certain
%ğŸ% properties.  For example, we'll find the longest palindromes
%ğŸ% in English and search for words whose letters appear in
%ğŸ% alphabetical order.  And I will present another program development
%ğŸ% plan: reduction to a previously solved problem.

è¿™ä¸€ç« å°†ä»‹ç»ç¬¬äºŒä¸ªæ¡ˆä¾‹ç ”ç©¶ï¼Œ å³é€šè¿‡æŸ¥æ‰¾å…·æœ‰ç‰¹å®šå±æ€§çš„å•è¯æ¥è§£ç­”å­—è°œæ¸¸æˆã€‚
ä¾‹å¦‚ï¼Œ æˆ‘ä»¬å°†æ‰¾å‡ºè‹±æ–‡ä¸­æœ€é•¿çš„å›æ–‡å•è¯ï¼Œ ä»¥åŠå­—ç¬¦æŒ‰ç…§å­—ç¬¦è¡¨é¡ºåºå‡ºç°çš„å•è¯ã€‚
å¦å¤–ï¼Œ æˆ‘è¿˜å°†ä»‹ç»å¦ä¸€ç§ç¨‹åºå¼€å‘æ–¹æ³•ï¼š ç®€åŒ–ä¸ºä¹‹å‰å·²è§£å†³çš„é—®é¢˜ã€‚

%ğŸ% \section{Reading word lists  |  è¯»å–å•è¯åˆ—è¡¨}
\section{è¯»å–å•è¯åˆ—è¡¨}
\label{wordlist}

%ğŸ% For the exercises in this chapter we need a list of English words.
%ğŸ% There are lots of word lists available on the Web, but the one most
%ğŸ% suitable for our purpose is one of the word lists collected and
%ğŸ% contributed to the public domain by Grady Ward as part of the Moby
%ğŸ% lexicon project (see \url{http://wikipedia.org/wiki/Moby_Project}).  It
%ğŸ% is a list of 113,809 official crosswords; that is, words that are
%ğŸ% considered valid in crossword puzzles and other word games.  In the
%ğŸ% Moby collection, the filename is {\tt 113809of.fic}; you can download
%ğŸ% a copy, with the simpler name {\tt words.txt}, from
%ğŸ% \url{http://thinkpython2.com/code/words.txt}.
\index{Moby Project}  \index{crosswords}

ä¸ºäº†å®Œæˆæœ¬ç« çš„ä¹ é¢˜ï¼Œ æˆ‘ä»¬éœ€è¦ä¸€ä¸ªè‹±è¯­å•è¯çš„åˆ—è¡¨ã€‚
ç½‘ç»œä¸Šæœ‰è®¸å¤šå•è¯åˆ—è¡¨ï¼Œ ä½†æ˜¯æœ€ç¬¦åˆæˆ‘ä»¬ç›®çš„åˆ—è¡¨ä¹‹ä¸€æ˜¯ç”± Grady
Wardæ”¶é›†å¹¶è´¡çŒ®ç»™å…¬ä¼—çš„åˆ—è¡¨ï¼Œ è¿™ä¹Ÿæ˜¯Mobyè¯å…¸é¡¹ç›®çš„ä¸€éƒ¨åˆ†\footnote{(è§ï¼š\url{http://wikipedia.org/wiki/Moby_Project}}ã€‚
å®ƒç”± 113,809 ä¸ªå¡«å­—æ¸¸æˆå•è¯ç»„æˆï¼Œ å³åœ¨å¡«å­—æ¸¸æˆä»¥åŠå…¶å®ƒæ–‡å­—æ¸¸æˆä¸­è¢«è®¤ä¸ºæœ‰æ•ˆçš„å•è¯ã€‚
åœ¨ Moby é›†åˆä¸­ï¼Œ è¯¥åˆ—è¡¨çš„æ–‡ä»¶åæ˜¯ \li{113809of.fic} ï¼›ä½ å¯ä»¥ä» \href{http://thinkpython.com/code/words.txt}{è¿™é‡Œ} ä¸‹è½½ä¸€ä¸ªæ‹·è´ï¼Œ æ–‡ä»¶åå·²è¢«ç®€åŒ–ä¸º \li{words.txt}ã€‚

\index{Moby Project}  \index{crosswords}
\index{ç»´åŸºç™¾ç§‘}

%ğŸ% This file is in plain text, so you can open it with a text
%ğŸ% editor, but you can also read it from Python.  The built-in
%ğŸ% function {\tt open} takes the name of the file as a parameter
%ğŸ% and returns a {\bf file object} you can use to read the file.

è¯¥æ–‡ä»¶æ˜¯çº¯æ–‡æœ¬ï¼Œ å› æ­¤ä½ å¯ä»¥ç”¨ä¸€ä¸ªæ–‡æœ¬ç¼–è¾‘å™¨æ‰“å¼€å®ƒï¼Œ ä½†æ˜¯ä½ ä¹Ÿå¯ä»¥ä» Python ä¸­è¯»å–å®ƒã€‚   å†…å»ºå‡½æ•° \li{open} æ¥å—æ–‡ä»¶åä½œä¸ºå½¢å‚ï¼Œ å¹¶è¿”å›ä¸€ä¸ª {\em æ–‡ä»¶å¯¹è±¡} (file object)ï¼Œ ä½ å¯ä»¥ä½¿ç”¨å®ƒè¯»å–è¯¥æ–‡ä»¶ã€‚

\index{open function}  \index{function!open}
\index{plain text}  \index{text!plain}
\index{object!file}  \index{file object}

\begin{lstlisting}
>>> fin = open('words.txt')
\end{lstlisting}

%ğŸ% %
%ğŸ% {\tt fin} is a common name for a file object used for input.  The file
%ğŸ% object provides several methods for reading, including {\tt readline},
%ğŸ% which reads characters from the file until it gets to a newline and
%ğŸ% returns the result as a string:
\index{readline method}  \index{method!readline}
\index{readline æ–¹æ³•}  \index{æ–¹æ³•!readline}

\li{`fin} æ˜¯è¾“å…¥æ–‡ä»¶å¯¹è±¡çš„ä¸€ä¸ªå¸¸ç”¨åã€‚
è¯¥æ–‡ä»¶å¯¹è±¡æä¾›äº†å‡ ä¸ªè¯»å–æ–¹æ³•ï¼Œ åŒ…æ‹¬ \li{readline}ï¼Œ å…¶ä»æ–‡ä»¶ä¸­è¯»å–å­—ç¬¦ç›´åˆ°ç¢°åˆ°æ–°è¡Œï¼Œ å¹¶å°†ç»“æœä½œä¸ºå­—ç¬¦ä¸²è¿”å›ï¼š
\index{method!readline}

\begin{lstlisting}
>>> fin.readline()
'aa\r\n'
\end{lstlisting}

%ğŸ% %
%ğŸ% The first word in this particular list is ``aa'', which is a kind of
%ğŸ% lava.  The sequence \verb"\r\n" represents two whitespace characters,
%ğŸ% a carriage return and a newline, that separate this word from the
%ğŸ% next.

åœ¨æ­¤åˆ—è¡¨ä¸­ï¼Œ ç¬¬ä¸€ä¸ªå•è¯æ˜¯ ``aa''ï¼Œ å®ƒæ˜¯ä¸€ç±»ç†”å²©çš„åç§°ã€‚   åºåˆ— \li{\r\n} ä»£è¡¨ä¸¤ä¸ªç©ºç™½å­—ç¬¦ï¼Œ å›è½¦å’Œæ¢è¡Œï¼Œ å®ƒä»¬å°†è¿™ä¸ªå•è¯å’Œä¸‹ä¸€ä¸ªåˆ†å¼€ã€‚

%ğŸ% The file object keeps track of where it is in the file, so
%ğŸ% if you call {\tt readline} again, you get the next word:

æ­¤æ–‡ä»¶å¯¹è±¡è·Ÿè¸ªå®ƒåœ¨æ–‡ä»¶ä¸­çš„ä½ç½®ï¼Œ
æ‰€ä»¥å¦‚æœä½ å†æ¬¡è°ƒç”¨ \li{readline}ï¼Œ ä½ è·å¾—ä¸‹ä¸€ä¸ªå•è¯ï¼š

\begin{lstlisting}
>>> fin.readline()
'aah\r\n'
\end{lstlisting}

%ğŸ% %
%ğŸ% The next word is ``aah'', which is a perfectly legitimate
%ğŸ% word, so stop looking at me like that.
%ğŸ% Or, if it's the whitespace that's bothering you,
%ğŸ% we can get rid of it with the string method {\tt strip}:

ä¸‹ä¸€ä¸ªå•è¯æ˜¯ ``aah''ï¼Œ ä¸è¦æƒŠè®¶ï¼Œ å®ƒæ˜¯ä¸€ä¸ªå®Œå…¨åˆæ³•çš„å•è¯ã€‚
æˆ–è€…ï¼Œ å¦‚æœç©ºæ ¼å›°æ‰°äº†ä½ ï¼Œ æˆ‘ä»¬å¯ä»¥ç”¨å­—ç¬¦ä¸²æ–¹æ³• \li{strip} åˆ æ‰å®ƒï¼š
\index{strip method}  \index{method!strip}
\index{strip æ–¹æ³•}  \index{æ–¹æ³•!strip}


\begin{lstlisting}
>>> line = fin.readline()
>>> word = line.strip()
>>> word
'aahed'
\end{lstlisting}

%ğŸ% %
%ğŸ% You can also use a file object as part of a {\tt for} loop.
%ğŸ% This program reads {\tt words.txt} and prints each word, one
%ğŸ% per line:

ä½ ä¹Ÿå¯ä»¥å°†æ–‡ä»¶å¯¹è±¡ç”¨åš \li{for} å¾ªç¯çš„ä¸€éƒ¨åˆ†ã€‚
æ­¤ç¨‹åºè¯»å– \li{words.txt} å¹¶æ‰“å°æ¯ä¸ªå•è¯ï¼Œ æ¯è¡Œä¸€ä¸ªï¼š
\index{open function}  \index{function!open}

\begin{lstlisting}
fin = open('words.txt')
for line in fin:
    word = line.strip()
    print(word)
\end{lstlisting}

%
%ğŸ% \section{Exercises  |  ç»ƒä¹ }
\section{ç»ƒä¹ }

%ğŸ% There are solutions to these exercises in the next section.
%ğŸ% You should at least attempt each one before you read the solutions.

\hyperref[search]{ä¸‹ä¸€èŠ‚}å°†ç»™å‡ºäº†è¿™äº›ä¹ é¢˜çš„ç­”æ¡ˆã€‚
åœ¨ä½ çœ‹ç­”æ¡ˆä¹‹å‰ï¼Œ åº”è¯¥è¯•ç€è§£ç­”ä¸€ä¸‹ã€‚

\begin{exercise}
%ğŸ% Write a program that reads {\tt words.txt} and prints only the
%ğŸ% words with more than 20 characters (not counting whitespace).

ç¼–ç¨‹å†™ä¸€ä¸ªç¨‹åºï¼Œ ä½¿å¾—å®ƒå¯ä»¥è¯»å– {\em \li{words.txt}} ï¼Œ ç„¶ååªæ‰“å°å‡ºé‚£äº›é•¿åº¦è¶…è¿‡ 20 ä¸ªå­—ç¬¦çš„å•è¯ (ä¸åŒ…æ‹¬ç©ºæ ¼)ã€‚
\index{whitespace}

\end{exercise}

\begin{exercise}

%ğŸ% In 1939 Ernest Vincent Wright published a 50,000 word novel called
%ğŸ% {\em Gadsby} that does not contain the letter ``e''.  Since ``e'' is
%ğŸ% the most common letter in English, that's not easy to do.

{\em 1939} å¹´ï¼Œ {\em Ernest Vincent Wright} å‡ºç‰ˆäº†ä¸€æœ¬åä¸º {\em ã€ŠGadsbyã€‹} çš„å°è¯´ï¼Œ
è¯¥å°è¯´é‡Œå®Œå…¨æ²¡æœ‰ä½¿ç”¨å­—ç¬¦ {\em ``e''}ã€‚   ç”±äº {\em ``e''} æ˜¯è‹±æ–‡ä¸­æœ€å¸¸ç”¨çš„å­—ç¬¦ï¼Œ å› æ­¤å†™å‡ºè¿™æœ¬ä¹¦å¹¶ä¸å®¹æ˜“ã€‚

%ğŸ% In fact, it is difficult to construct a solitary thought without using
%ğŸ% that most common symbol.  It is slow going at first, but with caution
%ğŸ% and hours of training you can gradually gain facility.

äº‹å®ä¸Šï¼Œ ä¸ä½¿ç”¨è¿™ä¸ªæœ€å¸¸ç”¨çš„å­—ç¬¦æ¥æ„å»ºä¸€ä¸ªç®€å•çš„æƒ³æ³•éƒ½æ˜¯å¾ˆéš¾çš„ã€‚
å¼€å§‹è¿›å±•ç¼“æ…¢ï¼Œ ä½†æ˜¯ç»è¿‡æœ‰æ„è¯†çš„ã€é•¿æ—¶é—´çš„è®­ç»ƒï¼Œ ä½ å¯ä»¥é€æ¸åœ°ç†Ÿç»ƒã€‚

%ğŸ% All right, I'll stop now.

å¥½å•¦ï¼Œ ä¸è¯´é¢˜å¤–è¯äº†ï¼Œ æˆ‘ä»¬å¼€å§‹ç¼–ç¨‹ç»ƒä¹ ã€‚

%ğŸ% Write a function called \verb"has_no_e" that returns {\tt True} if
%ğŸ% the given word doesn't have the letter ``e'' in it.

å†™ä¸€ä¸ªå«åš {\em \li{has_no_e}} çš„å‡½æ•°ï¼Œ å¦‚æœç»™å®šçš„å•è¯ä¸­ä¸åŒ…å«å­—ç¬¦ {\em ``e''}ï¼Œ è¿”å› {\em \li{True}} ã€‚

%ğŸ% Modify your program from the previous section to print only the words
%ğŸ% that have no ``e'' and compute the percentage of the words in the list
%ğŸ% that have no ``e''.

ä¿®æ”¹ä¸Šä¸€èŠ‚ä¸­çš„ç¨‹åºï¼Œ åªæ‰“å°ä¸åŒ…å« {\em ``e''} çš„å•è¯ï¼Œ å¹¶ä¸”è®¡ç®—åˆ—è¡¨ä¸­ä¸å« {\em ``e''} å•è¯çš„æ¯”ä¾‹ã€‚
\index{lipogram}

\end{exercise}


\begin{exercise}

%ğŸ% Write a function named {\tt avoids}
%ğŸ% that takes a word and a string of forbidden letters, and
%ğŸ% that returns {\tt True} if the word doesn't use any of the forbidden
%ğŸ% letters.

ç¼–å†™ä¸€ä¸ªåä¸º {\em \li{avoids}} çš„å‡½æ•°ï¼Œ æ¥å—ä¸€ä¸ªå•è¯å’Œä¸€ä¸ªæŒ‡å®šç¦æ­¢ä½¿ç”¨å­—ç¬¦çš„å­—ç¬¦ä¸²ï¼Œ
å¦‚æœå•è¯ä¸­ä¸åŒ…å«ä»»æ„è¢«ç¦æ­¢çš„å­—ç¬¦ï¼Œ åˆ™è¿”å› {\em \li{True}} ã€‚

%ğŸ% Modify your program to prompt the user to enter a string
%ğŸ% of forbidden letters and then print the number of words that
%ğŸ% don't contain any of them.
%ğŸ% Can you find a combination of 5 forbidden letters that
%ğŸ% excludes the smallest number of words?

ä¿®æ”¹ä½ çš„ç¨‹åºï¼Œ æç¤ºç”¨æˆ·è¾“å…¥ä¸€ä¸ªç¦æ­¢ä½¿ç”¨çš„å­—ç¬¦ï¼Œ ç„¶åæ‰“å°ä¸åŒ…å«è¿™äº›å­—ç¬¦çš„å•è¯çš„æ•°é‡ã€‚
ä½ èƒ½æ‰¾åˆ°ä¸€ä¸ª5ä¸ªç¦æ­¢ä½¿ç”¨å­—ç¬¦çš„ç»„åˆï¼Œ ä½¿å¾—å…¶æ’é™¤çš„å•è¯æ•°ç›®æœ€å°‘ä¹ˆï¼Ÿ

\end{exercise}



\begin{exercise}

%ğŸ% Write a function named \verb"uses_only" that takes a word and a
%ğŸ% string of letters, and that returns {\tt True} if the word contains
%ğŸ% only letters in the list.  Can you make a sentence using only the
%ğŸ% letters {\tt acefhlo}?  Other than ``Hoe alfalfa?''

ç¼–å†™ä¸€ä¸ªåä¸º {\em \li{uses_only}} çš„å‡½æ•°ï¼Œ æ¥å—ä¸€ä¸ªå•è¯å’Œä¸€ä¸ªå­—ç¬¦ä¸²ã€‚
å¦‚æœè¯¥å•è¯åªåŒ…æ‹¬æ­¤å­—ç¬¦ä¸²ä¸­çš„å­—ç¬¦ï¼Œ åˆ™è¿”å› {\em \li{True}}ã€‚
ä½ èƒ½åªç”¨ {\em \li{"acefhlo"}} è¿™å‡ ä¸ªå­—ç¬¦é€ ä¸€ä¸ªå¥å­ä¹ˆï¼Ÿ é™¤äº† ``Hoe alfalfa'' å¤–ã€‚

\end{exercise}


\begin{exercise}

%ğŸ% Write a function named \verb"uses_all" that takes a word and a
%ğŸ% string of required letters, and that returns {\tt True} if the word
%ğŸ% uses all the required letters at least once.  How many words are there
%ğŸ% that use all the vowels {\tt aeiou}?  How about {\tt aeiouy}?

ç¼–å†™ä¸€ä¸ªåä¸º {\em \li{uses_all}} çš„å‡½æ•°ï¼Œ æ¥å—ä¸€ä¸ªå•è¯å’Œä¸€ä¸ªå¿…é¡»ä½¿ç”¨çš„å­—ç¬¦ç»„æˆçš„å­—ç¬¦ä¸²ã€‚
å¦‚æœè¯¥å•è¯åŒ…æ‹¬æ­¤å­—ç¬¦ä¸²ä¸­çš„å…¨éƒ¨å­—ç¬¦è‡³å°‘ä¸€æ¬¡ï¼Œ åˆ™è¿”å› {\em \li{True}}ã€‚
ä½ èƒ½ç»Ÿè®¡å‡ºå¤šå°‘å•è¯åŒ…å«äº†æ‰€æœ‰çš„å…ƒéŸ³å­—ç¬¦ {\em \li{aeiou}}å—ï¼Ÿå¦‚æœæ¢æˆ {\em \li{aeiouy}} å‘¢ï¼Ÿ

\end{exercise}


\begin{exercise}

%ğŸ% Write a function called \verb"is_abecedarian" that returns
%ğŸ% {\tt True} if the letters in a word appear in alphabetical order
%ğŸ% (double letters are ok).
%ğŸ% How many abecedarian words are there?

ç¼–å†™ä¸€ä¸ªåä¸º {\em \li{is_abecedarian}} çš„å‡½æ•°ï¼Œ å¦‚æœå•è¯ä¸­çš„å­—ç¬¦ä»¥å­—ç¬¦è¡¨çš„é¡ºåºå‡ºç°(å…è®¸é‡å¤å­—ç¬¦)ï¼Œ åˆ™è¿”å› {\em \li{True}} ã€‚
æœ‰å¤šå°‘ä¸ªå…·å¤‡è¿™ç§ç‰¹å¾çš„å•è¯ï¼Ÿ

\index{abecedarian}  \index{å­—ç¬¦è¡¨}

\end{exercise}



%ğŸ% \section{Search  ||  æœç´¢}
\section{æœç´¢}
\label{search}
\index{search pattern}  \index{pattern!search}

%ğŸ% All of the exercises in the previous section have something
%ğŸ% in common; they can be solved with the search pattern we saw
%ğŸ% in Section~\ref{find}.  The simplest example is:

å‰ä¸€èŠ‚çš„æ‰€æœ‰ä¹ é¢˜æœ‰ä¸€ä¸ªå…±åŒç‚¹ï¼›éƒ½å¯ä»¥ç”¨åœ¨ \ref{find}~èŠ‚ ä¸­çœ‹åˆ°çš„æœç´¢æ¨¡å¼è§£å†³ã€‚

\begin{lstlisting}
def has_no_e(word):
    for letter in word:
        if letter == 'e':
            return False
    return True
\end{lstlisting}

%
%ğŸ% The {\tt for} loop traverses the characters in {\tt word}.  If we find
%ğŸ% the letter ``e'', we can immediately return {\tt False}; otherwise we
%ğŸ% have to go to the next letter.  If we exit the loop normally, that
%ğŸ% means we didn't find an ``e'', so we return {\tt True}.

\li{for} å¾ªç¯éå† \li{word} ä¸­çš„å­—ç¬¦ã€‚
å¦‚æœæˆ‘ä»¬æ‰¾åˆ°å­—ç¬¦ \li{"e"}ï¼Œ é‚£ä¹ˆæˆ‘ä»¬å¯ä»¥é©¬ä¸Šè¿”å› \li{False} ï¼›
å¦åˆ™æˆ‘ä»¬å¿…é¡»æ£€æŸ¥ä¸‹ä¸€ä¸ªå­—ç¬¦ã€‚
å¦‚æœæˆ‘ä»¬æ­£å¸¸é€€å‡ºå¾ªç¯ï¼Œ å°±æ„å‘³ç€æˆ‘ä»¬æ²¡æœ‰æ‰¾åˆ°ä¸€ä¸ª ``e''ï¼Œ æ‰€ä»¥æˆ‘ä»¬è¿”å› \li{True} ã€‚

\index{traversal}

\index{in operator}  \index{operator!in}

%ğŸ% You could write this function more concisely using the {\tt in}
%ğŸ% operator, but I started with this version because it
%ğŸ% demonstrates the logic of the search pattern.

ä½ ä¹Ÿå¯ä»¥ç”¨ \li{in} æ“ä½œç¬¦ç®€åŒ–ä¸Šè¿°å‡½æ•°ï¼Œ ä½†ä¹‹æ‰€ä»¥ä¸€å¼€å§‹å†™æˆè¿™æ ·ï¼Œ æ˜¯å› ä¸ºå®ƒå±•ç¤ºäº†æœç´¢æ¨¡å¼çš„é€»è¾‘ã€‚

\index{generalization}

%ğŸ% {\tt avoids} is a more general version of \verb"has_no_e" but it
%ğŸ% has the same structure:

\li{avoid}ã€€æ˜¯ä¸€ä¸ªæ›´é€šç”¨çš„ \li{has_no_e} å‡½æ•°ï¼Œ ä½†æ˜¯ç»“æ„æ˜¯ç›¸åŒçš„ï¼š

\begin{lstlisting}
def avoids(word, forbidden):
    for letter in word:
        if letter in forbidden:
            return False
    return True
\end{lstlisting}

%ğŸ% %
%ğŸ% We can return {\tt False} as soon as we find a forbidden letter;
%ğŸ% if we get to the end of the loop, we return {\tt True}.

ä¸€æ—¦æˆ‘ä»¬æ‰¾åˆ°ä¸€ä¸ªç¦æ­¢ä½¿ç”¨çš„å­—ç¬¦ï¼Œ æˆ‘ä»¬è¿”å› \li{False} ï¼›
å¦‚æœæˆ‘ä»¬åˆ°è¾¾å¾ªç¯ç»“å°¾ï¼Œ æˆ‘ä»¬è¿”å› \li{True} ã€‚

%ğŸ% \verb"uses_only" is similar except that the sense of the condition
%ğŸ% is reversed:

é™¤äº†æ£€æµ‹æ¡ä»¶ç›¸åä»¥å¤–ï¼Œ ä¸‹é¢ \li{uses_only} å‡½æ•°ä¸ä¸Šé¢çš„å‡½æ•°å¾ˆåƒï¼š

\begin{lstlisting}
def uses_only(word, available):
    for letter in word:
        if letter not in available:
            return False
    return True
\end{lstlisting}

%ğŸ% %
%ğŸ% Instead of a list of forbidden letters, we have a list of available
%ğŸ% letters.  If we find a letter in {\tt word} that is not in
%ğŸ% {\tt available}, we can return {\tt False}.

è¿™é‡Œæˆ‘ä»¬ä¼ å…¥ä¸€ä¸ªå…è®¸ä½¿ç”¨å­—ç¬¦çš„åˆ—è¡¨ï¼Œ è€Œä¸æ˜¯ç¦æ­¢ä½¿ç”¨å­—ç¬¦çš„åˆ—è¡¨ã€‚
å¦‚æœæˆ‘ä»¬åœ¨ \li{word} ä¸­æ‰¾åˆ°ä¸€ä¸ªä¸åœ¨ \li{available} ä¸­çš„å­—ç¬¦ï¼Œ æˆ‘ä»¬å°±å¯ä»¥è¿”å› \li{False} ã€‚

%ğŸ% \verb"uses_all" is similar except that we reverse the role
%ğŸ% of the word and the string of letters:

é™¤äº†å°† \li{word} ä¸æ‰€è¦æ±‚çš„å­—ç¬¦çš„è§’è‰²è¿›è¡Œäº†è°ƒæ¢ä¹‹å¤–ï¼Œ
ä¸‹é¢çš„ \li{uses_all} å‡½æ•°ä¹Ÿæ˜¯ç±»ä¼¼çš„ã€‚

\begin{lstlisting}
def uses_all(word, required):
    for letter in required:
        if letter not in word:
            return False
    return True
\end{lstlisting}

%ğŸ% %
%ğŸ% Instead of traversing the letters in {\tt word}, the loop
%ğŸ% traverses the required letters.  If any of the required letters
%ğŸ% do not appear in the word, we can return {\tt False}.

è¯¥å¾ªç¯éå†éœ€è¦çš„å­—ç¬¦ï¼Œ è€Œä¸æ˜¯éå† \li{word} ä¸­çš„å­—ç¬¦ã€‚  å¦‚æœä»»ä½•è¦æ±‚çš„å­—ç¬¦æ²¡å‡ºç°åœ¨å•è¯ä¸­ï¼Œ åˆ™æˆ‘ä»¬è¿”å› \li{False} ã€‚

\index{traversal}

%ğŸ% If you were really thinking like a computer scientist, you would
%ğŸ% have recognized that \verb"uses_all" was an instance of a
%ğŸ% previously solved problem, and you would have written:

å¦‚æœä½ çœŸçš„åƒè®¡ç®—æœºç§‘å­¦å®¶ä¸€æ ·æ€è€ƒï¼Œ ä½ å¯èƒ½å·²ç»æ„è¯†åˆ° \li{uses_all} æ˜¯å‰é¢å·²ç»è§£å†³çš„é—®é¢˜çš„ä¸€ä¸ªå®ä¾‹ï¼Œ ä½ å¯èƒ½ä¼šå†™æˆï¼š

\begin{lstlisting}
def uses_all(word, required):
    return uses_only(required, word)
\end{lstlisting}

%ğŸ% %
%ğŸ% This is an example of a program development plan called {\bf
%ğŸ%   reduction to a previously solved problem}, which means that you
%ğŸ% recognize the problem you are working on as an instance of a solved
%ğŸ% problem and apply an existing solution.  \index{reduction to a
%ğŸ%   previously solved problem} \index{development plan!reduction}

è¿™æ˜¯ä¸€ç§å«åš {\bf ç®€åŒ–ä¸ºä¹‹å‰å·²è§£å†³çš„é—®é¢˜\footnote{reduction to a
previously solved problem}} çš„ç¨‹åºå¼€å‘æ–¹æ³•çš„ä¸€ä¸ªç¤ºä¾‹ï¼Œ
ä¹Ÿå°±æ˜¯è¯´ï¼Œ ä½ è®¤è¯†åˆ°å½“å‰é¢ä¸´çš„é—®é¢˜æ˜¯ä¹‹å‰å·²ç»è§£å†³çš„é—®é¢˜çš„ä¸€ä¸ªå®ä¾‹ï¼Œ
ç„¶ååº”ç”¨äº†å·²æœ‰çš„è§£å†³æ–¹æ¡ˆã€‚


%ğŸ% \section{Looping with indices  |  ä½¿ç”¨ç´¢å¼•è¿›è¡Œå¾ªç¯}
\section{ä½¿ç”¨ç´¢å¼•è¿›è¡Œå¾ªç¯}
\index{looping!with indices}  \index{index!looping with}
\index{å¾ªç¯!ä½¿ç”¨ç´¢å¼•}  \index{ç´¢å¼•!æ§åˆ¶å¾ªç¯}

%ğŸ% I wrote the functions in the previous section with {\tt for}
%ğŸ% loops because I only needed the characters in the strings; I didn't
%ğŸ% have to do anything with the indices.

å‰ä¸€èŠ‚æˆ‘ç”¨ \li{for} å¾ªç¯æ¥ç¼–å†™å‡½æ•°ï¼Œ å› ä¸ºæˆ‘åªéœ€è¦å¤„ç†å­—ç¬¦ä¸²ä¸­çš„å­—ç¬¦ï¼›
æˆ‘ä¸å¿…ç”¨ç´¢å¼•åšä»»

%ğŸ% For \verb"is_abecedarian" we have to compare adjacent letters,
%ğŸ% which is a little tricky with a {\tt for} loop:

å¯¹äºä¸‹é¢çš„ \li{is_abecedarian} ï¼Œ æˆ‘ä»¬å¿…é¡»æ¯”è¾ƒé‚»æ¥çš„å­—ç¬¦ï¼Œ ç”¨ \li{for} å¾ªç¯æ¥å†™çš„è¯æœ‰ç‚¹æ£˜æ‰‹ã€‚

\begin{lstlisting}
def is_abecedarian(word):
    previous = word[0]
    for c in word:
        if c < previous:
            return False
        previous = c
    return True
\end{lstlisting}

%ğŸ% An alternative is to use recursion:

ä¸€ç§æ›¿ä»£æ–¹æ³•æ˜¯ä½¿ç”¨é€’å½’ï¼š

\begin{lstlisting}
def is_abecedarian(word):
    if len(word) <= 1:
        return True
    if word[0] > word[1]:
        return False
    return is_abecedarian(word[1:])
\end{lstlisting}

%ğŸ% Another option is to use a {\tt while} loop:

å¦ä¸€ä¸­æ–¹æ³•æ˜¯ä½¿ç”¨ \li{while} å¾ªç¯ï¼š

\begin{lstlisting}
def is_abecedarian(word):
    i = 0
    while i < len(word)-1:
        if word[i+1] < word[i]:
            return False
        i = i+1
    return True
\end{lstlisting}

%ğŸ% %
%ğŸ% The loop starts at {\tt i=0} and ends when {\tt i=len(word)-1}.  Each
%ğŸ% time through the loop, it compares the $i$th character (which you can
%ğŸ% think of as the current character) to the $i+1$th character (which you
%ğŸ% can think of as the next).

å¾ªç¯èµ·å§‹äº \li{i=0} ï¼Œ \li{i=len(word)-1} æ—¶ç»“æŸã€‚
æ¯æ¬¡å¾ªç¯ï¼Œ å‡½æ•°ä¼šæ¯”è¾ƒç¬¬ $i$ ä¸ªå­—ç¬¦(å¯ä»¥å°†å…¶è®¤ä¸ºæ˜¯å½“å‰å­—ç¬¦)
å’Œç¬¬ $i+1$ ä¸ªå­—ç¬¦(å¯ä»¥å°†å…¶è®¤ä¸ºæ˜¯ä¸‹ä¸€ä¸ªå­—ç¬¦)ã€‚

%ğŸ% If the next character is less than (alphabetically before) the current
%ğŸ% one, then we have discovered a break in the abecedarian trend, and
%ğŸ% we return {\tt False}.

å¦‚æœä¸‹ä¸€ä¸ªå­—ç¬¦æ¯”å½“å‰çš„å°(å­—ç¬¦åºé å‰)ï¼Œ
é‚£ä¹ˆæˆ‘ä»¬åœ¨é€’å¢è¶‹åŠ¿ä¸­æ‰¾åˆ°äº†æ–­ç‚¹ï¼Œ å³å¯è¿”å› \li{False} ã€‚

%ğŸ% If we get to the end of the loop without finding a fault, then the
%ğŸ% word passes the test.  To convince yourself that the loop ends
%ğŸ% correctly, consider an example like \verb"'flossy'".  The
%ğŸ% length of the word is 6, so
%ğŸ% the last time the loop runs is when {\tt i} is 4, which is the
%ğŸ% index of the second-to-last character.  On the last iteration,
%ğŸ% it compares the second-to-last character to the last, which is
%ğŸ% what we want.

å¦‚æœåˆ°å¾ªç¯ç»“æŸæ—¶æˆ‘ä»¬ä¹Ÿæ²¡æœ‰æ‰¾åˆ°ä¸€ç‚¹é”™è¯¯ï¼Œ é‚£ä¹ˆè¯¥å•è¯é€šè¿‡æµ‹è¯•ã€‚
ä¸ºäº†è®©ä½ ç›¸ä¿¡å¾ªç¯æ­£ç¡®åœ°ç»“æŸäº†ï¼Œ æˆ‘ä»¬ç”¨ \li{'flossy'} è¿™ä¸ªå•è¯æ¥ä¸¾ä¾‹ã€‚
å®ƒçš„é•¿åº¦ä¸º 6ï¼Œ å› æ­¤æœ€åä¸€æ¬¡å¾ªç¯è¿è¡Œæ—¶ï¼Œ \li{i} æ˜¯ 4ï¼Œ è¿™æ˜¯å€’æ•°ç¬¬ 2 ä¸ªå­—ç¬¦çš„ç´¢å¼•ã€‚
æœ€åä¸€æ¬¡è¿­ä»£æ—¶ï¼Œ å‡½æ•°æ¯”è¾ƒå€’æ•°ç¬¬äºŒä¸ªå’Œæœ€åä¸€ä¸ªå­—ç¬¦ï¼Œ è¿™æ­£æ˜¯æˆ‘ä»¬å¸Œæœ›çš„ã€‚
\index{palindrome}

%ğŸ% Here is a version of \verb"is_palindrome" (see
%ğŸ% Exercise~\ref{palindrome}) that uses two indices; one starts at the
%ğŸ% beginning and goes up; the other starts at the end and goes down.

ä¸‹é¢æ˜¯ \li{is_palindrome} å‡½æ•°çš„ä¸€ç§ç‰ˆæœ¬(è¯¦è§ ç»ƒä¹ ~\ref{palindrome} )
ï¼Œ å…¶ä¸­ä½¿ç”¨äº†ä¸¤ä¸ªç´¢å¼•ï¼›ä¸€ä¸ªä»æœ€å‰é¢å¼€å§‹å¹¶å¾€å‰ä¸Šï¼Œ å¦ä¸€ä¸ªä»æœ€åé¢å¼€å§‹å¹¶å¾€ä¸‹èµ°ã€‚

\begin{lstlisting}
def is_palindrome(word):
    i = 0
    j = len(word)-1

    while i<j:
        if word[i] != word[j]:
            return False
        i = i+1
        j = j-1

    return True
\end{lstlisting}

%ğŸ% Or we could reduce to a previously solved
%ğŸ% problem and write:

æˆ–è€…ï¼Œ æˆ‘ä»¬å¯ä»¥æŠŠé—®é¢˜ç®€åŒ–ä¸ºä¹‹å‰å·²ç»è§£å†³çš„é—®é¢˜ï¼Œ è¿™æ ·æ¥å†™:

\index{reduction to a previously solved problem}
\index{development plan!reduction}

\begin{lstlisting}
def is_palindrome(word):
    return is_reverse(word, word)
\end{lstlisting}

%ğŸ% %
%ğŸ% Using \verb"is_reverse" from Section~\ref{isreverse}.

ä½¿ç”¨ \ref{isreverse}~èŠ‚ ä¸­æè¿°çš„ \li{is_reverse}


%ğŸ% \section{Debugging  |  è°ƒè¯•}
\section{è°ƒè¯•}
\index{debugging}  \index{testing!is hard}  \index{program testing}

%ğŸ% Testing programs is hard.  The functions in this chapter are
%ğŸ% relatively easy to test because you can check the results by hand.
%ğŸ% Even so, it is somewhere between difficult and impossible to choose a
%ğŸ% set of words that test for all possible errors.

ç¨‹åºæµ‹è¯•å¾ˆå›°éš¾ã€‚  æœ¬ç« ä¸­ä»‹ç»çš„å‡½æ•°ç›¸å¯¹å®¹æ˜“æµ‹è¯•ï¼Œ å› ä¸ºä½ å¯ä»¥æ‰‹å·¥æ£€æŸ¥ç»“æœã€‚
å³ä½¿è¿™æ ·ï¼Œ é€‰æ‹©ä¸€å¯ä»¥æµ‹è¯•æ‰€æœ‰å¯èƒ½é”™è¯¯çš„å•è¯é›†åˆï¼Œ æ˜¯å¾ˆå›°éš¾çš„ï¼Œ ä»‹äºå›°éš¾å’Œä¸å¯èƒ½ä¹‹é—´ã€‚

%ğŸ% Taking \verb"has_no_e" as an example, there are two obvious
%ğŸ% cases to check: words that have an `e' should return {\tt False}, and
%ğŸ% words that don't should return {\tt True}.  You should have no
%ğŸ% trouble coming up with one of each.

ä»¥ \li{has_no_e} ä¸ºä¾‹ï¼Œ æœ‰ä¸¤ä¸ªæ˜æ˜¾çš„ç”¨ä¾‹éœ€è¦æ£€æŸ¥ï¼š
å«æœ‰ `e' çš„å•è¯åº”è¯¥è¿”å› \li{False}ï¼Œ ä¸å«çš„å•è¯åº”è¯¥è¿”å› \li{True} ã€‚
ä½ åº”è¯¥å¯ä»¥å¾ˆå®¹æ˜“å°±èƒ½æƒ³åˆ°è¿™ä¸¤ç§æƒ…å†µã€‚

%ğŸ% Within each case, there are some less obvious subcases.  Among the
%ğŸ% words that have an ``e'', you should test words with an ``e'' at the
%ğŸ% beginning, the end, and somewhere in the middle.  You should test long
%ğŸ% words, short words, and very short words, like the empty string.  The
%ğŸ% empty string is an example of a {\bf special case}, which is one of
%ğŸ% the non-obvious cases where errors often lurk.

åœ¨æ¯ä¸ªç”¨ä¾‹ä¸­ï¼Œ è¿˜æœ‰ä¸€äº›ä¸é‚£ä¹ˆæ˜æ˜¾çš„å­ç”¨ä¾‹ã€‚
åœ¨å«æœ‰ ``e'' çš„å•è¯ä¸­ï¼Œ ä½ åº”è¯¥æµ‹è¯• ``e'' åœ¨å¼€å§‹ã€ç»“å°¾ä»¥åŠåœ¨ä¸­é—´çš„å•è¯ã€‚
ä½ è¿˜åº”è¯¥æµ‹è¯•é•¿å•è¯ã€çŸ­å•è¯ä»¥åŠéå¸¸çŸ­çš„å•è¯ï¼Œ å¦‚ç©ºå­—ç¬¦ä¸²ã€‚
ç©ºå­—ç¬¦ä¸²æ˜¯ä¸€ä¸ª {\bf ç‰¹æ®Šç”¨ä¾‹\footnote{special case}} ï¼Œ åŠä¸€ä¸ªç»å¸¸å‡ºç°é”™è¯¯çš„ä¸æ˜“æƒ³åˆ°çš„ç”¨ä¾‹ã€‚
\index{special case}

%ğŸ% In addition to the test cases you generate, you can also test
%ğŸ% your program with a word list like {\tt words.txt}.  By scanning
%ğŸ% the output, you might be able to catch errors, but be careful:
%ğŸ% you might catch one kind of error (words that should not be
%ğŸ% included, but are) and not another (words that should be included,
%ğŸ% but aren't).

é™¤äº†ä½ ç”Ÿæˆçš„æµ‹è¯•ç”¨ä¾‹ï¼Œ ä½ ä¹Ÿå¯ä»¥ç”¨ä¸€ä¸ªç±»ä¼¼ \li{words.txt} ä¸­çš„å•è¯åˆ—è¡¨æµ‹è¯•ä½ çš„ç¨‹åºã€‚   é€šè¿‡æ‰«æè¾“å‡ºï¼Œ ä½ å¯èƒ½ä¼šæ•è·é”™è¯¯ï¼Œ ä½†æ˜¯è¯·æ³¨æ„ï¼š
ä½ å¯èƒ½æ•è·ä¸€ç±»é”™è¯¯(åŒ…æ‹¬äº†ä¸åº”è¯¥åŒ…æ‹¬çš„å•è¯)å´æ²¡èƒ½æ•è·å¦ä¸€ç±»é”™è¯¯(æ²¡æœ‰åŒ…æ‹¬åº”è¯¥åŒ…æ‹¬çš„å•è¯)ã€‚

%ğŸ% In general, testing can help you find bugs, but it is not easy to
%ğŸ% generate a good set of test cases, and even if you do, you can't
%ğŸ% be sure your program is correct.
%ğŸ% According to a legendary computer scientist:
\index{testing!and absence of bugs}

%ğŸ% \begin{quote}
%ğŸ% Program testing can be used to show the presence of bugs, but never to
%ğŸ% show their absence!
%ğŸ%
%ğŸ% --- Edsger W. Dijkstra
%ğŸ% \end{quote}
%ğŸ% \index{Dijkstra, Edsger}

ä¸€èˆ¬æ¥è®²ï¼Œ æµ‹è¯•èƒ½å¸®åŠ©ä½ æ‰¾åˆ°é”™è¯¯ï¼Œ ä½†æ˜¯ç”Ÿæˆå¥½çš„æµ‹è¯•ç”¨ä¾‹å¹¶ä¸å®¹æ˜“ï¼Œ
å¹¶ä¸”å³ä¾¿ä½ åšåˆ°äº†ï¼Œ ä½ ä»ç„¶ä¸èƒ½ä¿è¯ä½ çš„ç¨‹åºæ˜¯æ­£ç¡®çš„ã€‚  æ­£å¦‚ä¸€ä½ä¼ å¥‡è®¡ç®—æœºç§‘å­¦å®¶æ‰€è¯´ï¼š
\index{testing!and absence of bugs}
\begin{quote}
{\bf ç¨‹åºæµ‹è¯•èƒ½ç”¨äºå±•ç¤ºé”™è¯¯çš„å­˜åœ¨ï¼Œ ä½†æ˜¯æ— æ³•è¯æ˜ä¸å­˜åœ¨é”™è¯¯ï¼}

--- Edsger W. Dijkstra
\end{quote}
\index{Dijkstra, Edsger}


%ğŸ% \section{Glossary  |  æœ¯è¯­è¡¨}
\section{æœ¯è¯­è¡¨}

\begin{description}

%ğŸ% \item[file object:] A value that represents an open file.
\index{file object}  \index{object!file}

\item[æ–‡ä»¶å¯¹è±¡ (file object):] ä»£è¡¨æ‰“å¼€æ–‡ä»¶çš„å˜é‡ã€‚
\index{æ–‡ä»¶å¯¹è±¡}  \index{å¯¹è±¡!æ–‡ä»¶}

%ğŸ% \item[reduction to a previously solved problem:] A way of solving a
%ğŸ%   problem by expressing it as an instance of a previously solved
%ğŸ%   problem.
\index{reduction to a previously solved problem}
\index{development plan!reduction}

\item[ç®€åŒ–ä¸ºå·²è§£å†³çš„é—®é¢˜ï¼š] é€šè¿‡æŠŠæœªçŸ¥é—®é¢˜ç®€åŒ–ä¸ºå·²ç»è§£å†³çš„é—®é¢˜æ¥è§£å†³é—®é¢˜çš„æ–¹æ³•ã€‚
\index{ç®€åŒ–ä¸ºå·²è§£å†³çš„é—®é¢˜}  \index{å¼€å‘è®¡åˆ’!ç®€åŒ–}

%ğŸ% \item[special case:] A test case that is atypical or non-obvious
%ğŸ% (and less likely to be handled correctly).
\index{special case}

\item[ç‰¹æ®Šç”¨ä¾‹ (special case):] ä¸€ç§ä¸å…¸å‹æˆ–è€…ä¸æ˜æ˜¾çš„æµ‹è¯•ç”¨ä¾‹(è€Œä¸”å¾ˆå¯èƒ½æ— æ³•æ­£ç¡®è§£å†³çš„ç”¨ä¾‹)ã€‚
\index{special case}

\end{description}


%ğŸ% \section{Exercises}
\section{ç»ƒä¹ }

\begin{exercise}
\index{Car Talk}  \index{Puzzler}  \index{double letters}

%ğŸ% This question is based on a Puzzler that was broadcast on the radio
%ğŸ% program {\em Car Talk}
%ğŸ% (\url{http://www.cartalk.com/content/puzzlers}):

è¿™ä¸ªé—®é¢˜åŸºäºå¹¿æ’­èŠ‚ç›® {\em ã€Š\href{http://www.cartalk.com/content/puzzlers}{Car Talk}ã€‹} ä¸Šä»‹ç»çš„ä¸€ä¸ªå­—è°œï¼š

%ğŸ% \begin{quote}
%ğŸ% Give me a word with three consecutive double letters. I'll give you a
%ğŸ% couple of words that almost qualify, but don't. For example, the word
%ğŸ% committee, c-o-m-m-i-t-t-e-e. It would be great except for the `i' that
%ğŸ% sneaks in there. Or Mississippi: M-i-s-s-i-s-s-i-p-p-i. If you could
%ğŸ% take out those i's it would work. But there is a word that has three
%ğŸ% consecutive pairs of letters and to the best of my knowledge this may
%ğŸ% be the only word. Of course there are probably 500 more but I can only
%ğŸ% think of one. What is the word?
%ğŸ% \end{quote}

\begin{quote}
    æ‰¾å‡ºä¸€ä¸ªåŒ…å«ä¸‰ä¸ªè¿ç»­åŒå­—ç¬¦çš„å•è¯ã€‚  æˆ‘å°†ç»™ä½ ä¸€ç³»åˆ—å‡ ä¹èƒ½å¤Ÿç¬¦åˆæ¡ä»¶ä½†å®é™…ä¸ç¬¦åˆçš„å•è¯ã€‚
    æ¯”å¦‚ï¼Œ {\em committee} è¿™ä¸ªå•è¯ï¼Œ {\em c-o-m-m-i-t-t-e-e}ã€‚
    å¦‚æœä¸­é—´æ²¡æœ‰ {\em i} çš„è¯ï¼Œ å°±å¤ªæ£’äº†ã€‚
    æˆ–è€… {\em Mississippi} è¿™ä¸ªå•è¯: {\em M-i-s-s-i-s-s-i-p-p-i}ã€‚
    å‡å¦‚å°†è¿™äº› {\em i} å‰”é™¤å‡ºå»ï¼Œ å°±ä¼šç¬¦åˆæ¡ä»¶ã€‚
    ä½†æ˜¯ç¡®å®å­˜åœ¨ä¸€ä¸ªåŒ…å«ä¸‰ä¸ªè¿ç»­çš„å•è¯å¯¹ï¼Œ è€Œä¸”æ®æˆ‘äº†è§£ï¼Œ å®ƒå¯èƒ½æ˜¯å”¯ä¸€ç¬¦åˆæ¡ä»¶çš„å•è¯ã€‚
    å½“ç„¶ä¹Ÿå¯èƒ½æœ‰ {\em 500} å¤šä¸ªï¼Œ ä½†æ˜¯æˆ‘åªèƒ½æƒ³åˆ°ä¸€ä¸ªã€‚
    é‚£ä¹ˆè¿™ä¸ªå•è¯æ˜¯ä»€ä¹ˆï¼Ÿ
\end{quote}

%ğŸ% Write a program to find it.
%ğŸ% Solution: \url{http://thinkpython2.com/code/cartalk1.py}.

ç¼–å†™ä¸€ä¸ªç¨‹åºï¼Œ æ‰¾åˆ°è¿™ä¸ªå•è¯ã€‚
\href{http://thinkpython2.com/code/cartalk1.py}{å‚è€ƒç­”æ¡ˆ}

\end{exercise}


\begin{exercise}
%ğŸ% Here's another {\em Car Talk}
%ğŸ% Puzzler (\url{http://www.cartalk.com/content/puzzlers}):

ä¸‹é¢æ˜¯å¦ä¸€ä¸ªæ¥è‡ª {\em ã€Š\href{http://www.cartalk.com/content/puzzlers}{Car Talk}ã€‹} çš„è°œé¢˜:
\index{Car Talk}  \index{Puzzler}
\index{odometer}  \index{palindrome}

%ğŸ% \begin{quote}
%ğŸ% ``I was driving on the highway the other day and I happened to
%ğŸ% notice my odometer. Like most odometers, it shows six digits,
%ğŸ% in whole miles only. So, if my car had 300,000
%ğŸ% miles, for example, I'd see 3-0-0-0-0-0.
%ğŸ%
%ğŸ% Now, what I saw that day was very interesting. I noticed that the
%ğŸ% last 4 digits were palindromic; that is, they read the same forward as
%ğŸ% backward. For example, 5-4-4-5 is a palindrome, so my odometer
%ğŸ% could have read 3-1-5-4-4-5.
%ğŸ%
%ğŸ% One mile later, the last 5 numbers were palindromic. For example, it
%ğŸ% could have read 3-6-5-4-5-6.  One mile after that, the middle 4 out of
%ğŸ% 6 numbers were palindromic.  And you ready for this? One mile later,
%ğŸ% all 6 were palindromic!
%ğŸ%
%ğŸ% The question is, what was on the odometer when I first looked?''
%ğŸ% \end{quote}

\begin{quote}
    ``æœ‰ä¸€å¤©ï¼Œ æˆ‘æ­£åœ¨é«˜é€Ÿå…¬è·¯ä¸Šå¼€è½¦ï¼Œ æˆ‘å¶ç„¶æ³¨æ„åˆ°æˆ‘çš„é‡Œç¨‹è¡¨ã€‚  å’Œå¤§å¤šæ•°é‡Œç¨‹è¡¨ä¸€æ ·ï¼Œ å®ƒåªæ˜¾ç¤º {\em 6} ä½æ•°å­—çš„æ•´æ•°è‹±é‡Œæ•°ã€‚
    æ‰€ä»¥ï¼Œ å¦‚æœæˆ‘çš„è½¦å¼€äº†{\em 300,000} è‹±é‡Œï¼Œ æˆ‘èƒ½å¤Ÿçœ‹åˆ°çš„æ•°å­—æ˜¯{\em :3-0-0-0-0-0}ã€‚

    æˆ‘å½“å¤©çœ‹åˆ°çš„é‡Œç¨‹æ•°éå¸¸æœ‰æ„æ€ã€‚  æˆ‘æ³¨æ„åˆ°åå››ä½æ•°å­—æ˜¯å›æ–‡æ•°ï¼›ä¹Ÿå°±æ˜¯è¯´ï¼Œ æ­£åºè¯»å’Œé€†åºè¯»æ˜¯ä¸€æ ·çš„ã€‚  ä¾‹å¦‚ï¼Œ {\em 5-4-4-5} å°±æ˜¯å›æ–‡æ•°ã€‚
    æ‰€ä»¥æˆ‘çš„é‡Œç¨‹æ•°å¯èƒ½æ˜¯{\em 3-1-5-4-4-5}ã€‚

    ä¸€è‹±é‡Œåï¼Œ åäº”ä½æ•°å­—å˜æˆäº†å›æ–‡æ•°ã€‚  ä¾‹å¦‚ï¼Œ é‡Œç¨‹æ•°å¯èƒ½å˜æˆäº†æ˜¯ {\em 3-6-5-4-5-6} ã€‚  åˆè¿‡äº†ä¸€è‹±é‡Œåï¼Œ {\em 6} ä½æ•°å­—çš„ä¸­é—´å››ä½å˜æˆäº†å›æ–‡æ•°ã€‚
    ä½ ç›¸ä¿¡å—ï¼Ÿä¸€è‹±é‡Œåï¼Œ æ‰€æœ‰çš„ {\em 6} ä½æ•°å­—éƒ½å˜æˆäº†å›æ–‡æ•°ã€‚

    é‚£ä¹ˆé—®é¢˜æ¥äº†ï¼Œ å½“æˆ‘ç¬¬ä¸€æ¬¡çœ‹åˆ°é‡Œç¨‹è¡¨æ—¶ï¼Œ é‡Œç¨‹æ•°æ˜¯å¤šå°‘?''
\end{quote}

%ğŸ% Write a Python program that tests all the six-digit numbers and prints
%ğŸ% any numbers that satisfy these requirements.
%ğŸ% Solution: \url{http://thinkpython2.com/code/cartalk2.py}.

ç¼–å†™å†™ä¸€ä¸ªç¨‹åºï¼Œ æµ‹è¯•æ‰€æœ‰çš„ {\em 6} ä½æ•°å­—ï¼Œ ç„¶åè¾“å‡ºæ‰€æœ‰ç¬¦åˆè¦æ±‚çš„ç»“æœã€‚
\href{http://thinkpython2.com/code/cartalk2.py}{å‚è€ƒç­”æ¡ˆ}

\end{exercise}


\begin{exercise}
%ğŸ% Here's another {\em Car Talk} Puzzler you can solve with a
%ğŸ% search (\url{http://www.cartalk.com/content/puzzlers}):

è¿˜æ˜¯ {\em ã€Š\href{http://www.cartalk.com/content/puzzlers}{Car Talk}ã€‹} çš„è°œé¢˜ï¼Œ ä½ å¯ä»¥é€šè¿‡åˆ©ç”¨æœç´¢æ¨¡å¼è§£ç­”ï¼š
\index{Car Talk}  \index{Puzzler}  \index{palindrome}

%ğŸ% \begin{quote}
%ğŸ% ``Recently I had a visit with my mom and we realized that
%ğŸ% the two digits that make up my age when reversed resulted in her
%ğŸ% age. For example, if she's 73, I'm 37. We wondered how often this has
%ğŸ% happened over the years but we got sidetracked with other topics and
%ğŸ% we never came up with an answer.
%ğŸ%
%ğŸ% When I got home I figured out that the digits of our ages have been
%ğŸ% reversible six times so far. I also figured out that if we're lucky it
%ğŸ% would happen again in a few years, and if we're really lucky it would
%ğŸ% happen one more time after that. In other words, it would have
%ğŸ% happened 8 times over all. So the question is, how old am I now?''
%ğŸ%
%ğŸ% \end{quote}

\begin{quote}

    ``æœ€è¿‘æˆ‘æ¢æœ›äº†æˆ‘çš„å¦ˆå¦ˆï¼Œ æˆ‘ä»¬å¿½ç„¶æ„è¯†åˆ°æŠŠæˆ‘çš„å¹´çºªæ•°å­—åè¿‡æ¥å°±æ˜¯å¥¹çš„å¹´é¾„ã€‚  æ¯”å¦‚ï¼Œ å¦‚æœå¥¹ {\em 73} å²ï¼Œ é‚£ä¹ˆæˆ‘å°±æ˜¯ {\em 37} å²ã€‚
    æˆ‘ä»¬æƒ³çŸ¥é“è¿‡å»è¿™äº›å¹´æ¥ï¼Œ å‘ç”Ÿäº†å¤šå°‘æ¬¡è¿™æ ·çš„å·§åˆï¼Œ ä½†æ˜¯æˆ‘ä»¬å¾ˆå¿«åç¦»åˆ°å…¶ä»–è¯é¢˜ä¸Šï¼Œ æœ€åå¹¶æ²¡æœ‰æ‰¾åˆ°ç­”æ¡ˆã€‚

    å›åˆ°å®¶åï¼Œ æˆ‘è®¡ç®—å‡ºæˆ‘çš„å¹´é¾„æ•°å­—æœ‰ {\em 6} æ¬¡åè¿‡æ¥å°±æ˜¯å¦ˆå¦ˆçš„å¹´é¾„ã€‚
    åŒæ—¶ï¼Œ æˆ‘ä¹Ÿå‘ç°å¦‚æœå¹¸è¿çš„è¯ï¼Œ å°†æ¥å‡ å¹´è¿˜å¯èƒ½å‘ç”Ÿè¿™æ ·çš„å·§åˆï¼Œ
    è¿æ°”å†å¥½ç‚¹çš„è¯ï¼Œ ä¹‹åè¿˜ä¼šå‡ºç°ä¸€æ¬¡è¿™æ ·çš„å·§åˆã€‚
    æ¢å¥è¯è¯´ï¼Œ è¿™æ ·çš„å·§åˆä¸€å…±ä¼šå‘ç”Ÿ8æ¬¡ã€‚  é‚£ä¹ˆï¼Œ é—®é¢˜æ¥äº†ï¼Œ æˆ‘ç°åœ¨å¤šå¤§äº†ï¼Ÿ''

\end{quote}

%ğŸ% Write a Python program that searches for solutions to this Puzzler.
%ğŸ% Hint: you might find the string method {\tt zfill} useful.
%ğŸ%
%ğŸ% Solution: \url{http://thinkpython2.com/code/cartalk3.py}.

ç¼–å†™ä¸€ä¸ªæŸ¥æ‰¾è°œé¢˜ç­”æ¡ˆçš„ {\em Python} å‡½æ•°\footnote{æç¤ºï¼šå­—ç¬¦ä¸²çš„ \li{zfill} æ–¹æ³•ç‰¹åˆ«æœ‰ç”¨ã€‚  }ã€‚
\href{http://thinkpython2.com/code/cartalk3.py}{ç­”æ¡ˆ}


\end{exercise}
