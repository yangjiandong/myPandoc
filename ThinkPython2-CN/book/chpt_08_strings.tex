

%ğŸ% \chapter{Strings  |  å­—ç¬¦ä¸²}
\chapter{å­—ç¬¦ä¸²}
\label{strings}

%ğŸ% Strings are not like integers, floats, and booleans.  A string
%ğŸ% is a {\bf sequence}, which means it is
%ğŸ% an ordered collection of other values.  In this chapter you'll see
%ğŸ% how to access the characters that make up a string, and you'll
%ğŸ% learn about some of the methods strings provide.
%ğŸ% \index{sequence}

å­—ç¬¦ä¸²ä¸åƒæ•´æ•°ã€æµ®ç‚¹æ•°å’Œå¸ƒå°”å‹ã€‚  å­—ç¬¦ä¸²æ˜¯ä¸€ä¸ª {\em åºåˆ—} (sequence) ï¼Œ è¿™å°±æ„å‘³ç€
å®ƒæ˜¯å…¶ä»–å€¼çš„ä¸€ä¸ªæœ‰åºçš„é›†åˆã€‚  åœ¨è¿™ç« ä¸­ï¼Œ ä½ å°†å­¦ä¹ æ€ä¹ˆå»è®¿é—®å­—ç¬¦ä¸²é‡Œçš„å­—ç¬¦ï¼Œ åŒæ—¶ä½ ä¹Ÿä¼šå­¦ä¹ åˆ°å­—ç¬¦ä¸²æä¾›çš„ä¸€äº›æ–¹æ³•ã€‚
\index{sequence}  \index{åºåˆ—}

%ğŸ% \section{A string is a sequence  |  å­—ç¬¦ä¸²æ˜¯ä¸€ä¸ªåºåˆ—}
\section{å­—ç¬¦ä¸²æ˜¯ä¸€ä¸ªåºåˆ—}

\index{sequence}  \index{character}
\index{bracket operator}  \index{operator!bracket}
\index{åºåˆ—}  \index{å­—ç¬¦}
\index{åœ†æ‹¬å·æ“ä½œç¬¦}  \index{æ“ä½œç¬¦!åœ†æ‹¬å·}



%ğŸ% A string is a sequence of characters.
%ğŸ% You can access the characters one at a time with the
%ğŸ% bracket operator:

å­—ç¬¦ä¸²æ˜¯ç”±å­—ç¬¦ç»„æˆçš„åºåˆ—ã€‚  ä½ å¯ä»¥ç”¨æ‹¬å·è¿ç®—ç¬¦ä¸€æ¬¡è®¿é—®ä¸€ä¸ªå­—ç¬¦ï¼š

\begin{lstlisting}
>>> fruit = 'banana'
>>> letter = fruit[1]
\end{lstlisting}

%
%ğŸ% The second statement selects character number 1 from {\tt
%ğŸ% fruit} and assigns it to {\tt letter}.
\index{index}
\index{ç´¢å¼•}

ç¬¬2æ¡è¯­å¥ä» \li{fruit} ä¸­é€‰æ‹©ç´¢å¼•ä¸º1çš„å­—ç¬¦å¹¶å°†å®ƒèµ‹ç»™ \li{letter} ã€‚

%ğŸ% The expression in brackets is called an {\bf index}.
%ğŸ% The index indicates which character in the sequence you
%ğŸ% want (hence the name).

æ‹¬å·ä¸­çš„è¡¨è¾¾å¼è¢«ç§°ä½œ {\em ç´¢å¼•} (index)ã€‚  ç´¢å¼•æŒ‡å‡ºåœ¨åºåˆ—ä¸­ä½ æƒ³è¦å“ªä¸ªå­—ç¬¦(å› æ­¤è€Œå¾—å)ã€‚

%ğŸ% But you might not get what you expect:

ä½†å¯èƒ½å¾—åˆ°çš„ä¸æƒ³ä½ æœŸæœ›é‚£æ ·ï¼š

\begin{lstlisting}
>>> letter
'a'
\end{lstlisting}

%
%ğŸ% For most people, the first letter of \verb"'banana'" is {\tt b}, not
%ğŸ% {\tt a}.  But for computer scientists, the index is an offset from the
%ğŸ% beginning of the string, and the offset of the first letter is zero.

å¯¹å¤§å¤šæ•°äººæ¥è¯´ï¼Œ \li{'banana'} çš„ç¬¬ä¸€ä¸ªå­—æ¯æ˜¯ \li{b} è€Œä¸æ˜¯ \li{a}ã€‚
ä½†æ˜¯å¯¹äºè®¡ç®—æœºç§‘å­¦å®¶ï¼Œ ç´¢å¼•æ˜¯ä»å­—ç¬¦ä¸²èµ·ç‚¹å¼€å§‹çš„ä½ç§»é‡\footnote{offset} ï¼Œ ç¬¬ä¸€ä¸ªå­—æ¯çš„ä½ç§»é‡å°±æ˜¯ 0ã€‚

\begin{lstlisting}
>>> letter = fruit[0]
>>> letter
'b'
\end{lstlisting}

%
%ğŸ% So {\tt b} is the 0th letter (``zero-eth'') of \verb"'banana'", {\tt
%ğŸ%   a} is the 1th letter (``one-eth''), and {\tt n} is the 2th letter
%ğŸ% (``two-eth'').  \index{index!starting at zero} \index{zero, index
%ğŸ%   starting at}

æ‰€ä»¥ \li{b} æ˜¯ \li{'banana'} çš„ç¬¬ $0$ ä¸ªå­—æ¯ï¼Œ \li {a} æ˜¯ç¬¬ä¸€ä¸ªå­—æ¯ï¼Œ \li{n} æ˜¯ç¬¬äºŒä¸ªå­—æ¯\footnote{è¯‘æ³¨ï¼šåŸæ–‡åˆ†åˆ«æ˜¯ ``zero-eth'', ``one-eth'', ``two-eth''}ã€‚

%ğŸ% As an index you can use an expression that contains variables and
%ğŸ% operators:
\index{index}

ä½ å¯ä»¥ä½¿ç”¨ä¸€ä¸ªåŒ…å«å˜é‡åå’Œè¿ç®—ç¬¦çš„è¡¨è¾¾å¼ä½œä¸ºç´¢å¼•ï¼š

\begin{lstlisting}
>>> i = 1
>>> fruit[i]
'a'
>>> fruit[i+1]
'n'
\end{lstlisting}

%

%ğŸ% But the value of the index has to be an integer.  Otherwise you
%ğŸ% get:
\index{exception!TypeError}  \index{TypeError}

ç´¢å¼•å€¼å¿…é¡»ä½¿ç”¨æ•´æ•°ã€‚  å¦åˆ™ä½ ä¼šå¾—åˆ°é”™è¯¯ä¿¡æ¯:

\begin{lstlisting}
>>> letter = fruit[1.5]
TypeError: string indices must be integers
\end{lstlisting}


%
%ğŸ% \section{{\tt len}}
\section{{\tt len}}
\index{len function}  \index{function!len}
\index{len å‡½æ•°}  \index{å‡½æ•°!len}

%ğŸ% {\tt len} is a built-in function that returns the number of characters
%ğŸ% in a string:

\li{len} æ˜¯ä¸€ä¸ªå†…å»ºå‡½æ•°ï¼Œ å®ƒè¿”å›å­—ç¬¦ä¸²ä¸­çš„å­—ç¬¦çš„æ•°é‡ï¼š

\begin{lstlisting}
>>> fruit = 'banana'
>>> len(fruit)
6
\end{lstlisting}

%
%ğŸ% To get the last letter of a string, you might be tempted to try something
%ğŸ% like this:
\index{exception!IndexError}  \index{IndexError}

ä¸ºäº†è·å¾—æŸä¸ªå­—ç¬¦ä¸²ä¸­æœ€åä¸€ä¸ªå­—ç¬¦ï¼Œ ä½ å¯ä»¥å°è¯•è¿™æ ·æ“ä½œï¼š

\begin{lstlisting}
>>> length = len(fruit)
>>> last = fruit[length]
IndexError: string index out of range
\end{lstlisting}

%
%ğŸ% The reason for the {\tt IndexError} is that there is no letter in {\tt
%ğŸ% 'banana'} with the index 6.  Since we started counting at zero, the
%ğŸ% six letters are numbered 0 to 5.  To get the last character, you have
%ğŸ% to subtract 1 from {\tt length}:

å‡ºç° \li{IndexError} çš„åŸå› åœ¨äº \li{'banana'} ä¸­æ²¡æœ‰ç´¢å¼•å€¼ä¸º 6 çš„å­—æ¯ã€‚  ç”±äºæˆ‘ä»¬ä» 0 å¼€å§‹è®¡æ•°ï¼Œ å…­ä¸ªå­—æ¯çš„ç¼–å·æ˜¯ä» 0 åˆ° 5 ã€‚  ä¸ºäº†è·å¾—æœ€åä¸€ä¸ªå­—ç¬¦ï¼Œ ä½ å¿…é¡»å°† ã€åŠ›{length} å‡å»ä¸€ï¼š

\begin{lstlisting}
>>> last = fruit[length-1]
>>> last
'a'
\end{lstlisting}

%
%ğŸ% Or you can use negative indices, which count backward from
%ğŸ% the end of the string.  The expression {\tt fruit[-1]} yields the last
%ğŸ% letter, {\tt fruit[-2]} yields the second to last, and so on.
\index{index!negative}  \index{negative index}

ä½ ä¹Ÿå¯ä»¥ä½¿ç”¨è´Ÿæ•°ç´¢å¼•ï¼Œ å³ä»å­—ç¬¦ä¸²çš„æœ«å°¾å€’ç€å¾€å‰æ•°ã€‚  è¡¨è¾¾å¼ \li{fruit[-1]} è¿”å›çš„æ˜¯æœ€åä¸€ä¸ªå­—æ¯ï¼Œ \li{fruit[-2]} è¿”å›å€’æ•°ç¬¬äºŒä¸ªå­—æ¯ï¼Œ ä»¥æ­¤ç±»æ¨ã€‚
\index{ç´¢å¼•!è´Ÿæ•°}  \index{è´Ÿæ•°ç´¢å¼•}


%ğŸ% \section{Traversal with a {\tt for} loop  |  ä½¿ç”¨{\tt for}å¾ªç¯éå†}
\section{ä½¿ç”¨{\tt for}å¾ªç¯éå†}
\label{for}
\index{traversal}  \index{loop!traversal}
\index{for loop}  \index{loop!for}
\index{statement!for}

\index{éå†}  \index{å¾ªç¯!éå†}
\index{for å¾ªç¯}  \index{å¾ªç¯!for}
\index{è¯­å¥!for}

%ğŸ% A lot of computations involve processing a string one character at a
%ğŸ% time.  Often they start at the beginning, select each character in
%ğŸ% turn, do something to it, and continue until the end.  This pattern of
%ğŸ% processing is called a {\bf traversal}.  One way to write a traversal
%ğŸ% is with a {\tt while} loop:

è®¸å¤šè®¡ç®—ä¸­éœ€è¦ä¸€ä¸ªå­—ç¬¦ä¸€ä¸ªå­—ç¬¦åœ°å¤„ç†å­—ç¬¦ä¸²ã€‚  é€šå¸¸è®¡ç®—ä»å­—ç¬¦ä¸²çš„å¤´éƒ¨å¼€å§‹ï¼Œ ä¾æ¬¡é€‰æ‹©æ¯ä¸ªå­—ç¬¦ï¼Œ å¯¹å…¶åšä¸€äº›å¤„ç†ï¼Œ
ç„¶åç»§ç»­ç›´åˆ°ç»“æŸã€‚  è¿™ç§å¤„ç†æ¨¡å¼è¢«ç§°ä½œ {\em éå†} (traversal) ã€‚  ç¼–å†™éå†çš„æ–¹æ³•ä¹‹ä¸€æ˜¯ä½¿ç”¨ \li{while} å¾ªç¯ï¼š


\begin{lstlisting}
index = 0
while index < len(fruit):
    letter = fruit[index]
    print(letter)
    index = index + 1
\end{lstlisting}

%
%ğŸ% This loop traverses the string and displays each letter on a line by
%ğŸ% itself.  The loop condition is {\tt index < len(fruit)}, so
%ğŸ% when {\tt index} is equal to the length of the string, the
%ğŸ% condition is false, and the body of the loop doesn't run.  The
%ğŸ% last character accessed is the one with the index {\tt len(fruit)-1},
%ğŸ% which is the last character in the string.

è¯¥å¾ªç¯éå†å­—ç¬¦ä¸²å¹¶åœ¨æ¯è¡Œæ˜¾ç¤ºä¸€ä¸ªå­—ç¬¦ä¸²ã€‚  è¯¥å¾ªç¯çš„æ¡ä»¶æ˜¯ \li{index < len(fruit)}ï¼Œ æ‰€ä»¥å½“ \li{index} å’Œå­—ç¬¦ä¸²çš„é•¿åº¦ç›¸ç­‰æ—¶ï¼Œ æ¡ä»¶ä¸ºå‡ï¼Œ å¾ªç¯ä½“ä¸è¢«æ‰§è¡Œã€‚  è¢«è®¿é—®çš„æœ€åä¸€ä¸ªå­—ç¬¦çš„ç´¢å¼•ä¸º \li{len(fruit)-1}ï¼Œ è¿™ä¹Ÿæ˜¯å­—ç¬¦ä¸²çš„æœ€åä¸€ä¸ªå­—ç¬¦ã€‚

%ğŸ% As an exercise, write a function that takes a string as an argument
%ğŸ% and displays the letters backward, one per line.

æˆ‘ä»¬åšä¸ªç»ƒä¹ ï¼Œ ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œ æ¥å—ä¸€ä¸ªå­—ç¬¦ä¸²ä½œä¸ºå®å‚ï¼Œ
æŒ‰ç…§ä»åå‘å‰çš„é¡ºåºæ˜¾ç¤ºå­—ç¬¦ï¼Œ æ¯è¡Œåªæ˜¾ç¤ºä¸€ä¸ªã€‚

%ğŸ% Another way to write a traversal is with a {\tt for} loop:

ç¼–å†™éå†çš„å¦ä¸€ç§æ–¹æ³•æ˜¯ä½¿ç”¨ \li{for} å¾ªç¯ï¼š

\begin{lstlisting}
for letter in fruit:
    print(letter)
\end{lstlisting}

%
%ğŸ% Each time through the loop, the next character in the string is assigned
%ğŸ% to the variable {\tt letter}.  The loop continues until no characters are
%ğŸ% left.
\index{concatenation}  \index{abecedarian}
\index{McCloskey, Robert}

æ¯æ¬¡å¾ªç¯æ—¶ï¼Œ å­—ç¬¦ä¸²ä¸­çš„ä¸‹ä¸€ä¸ªå­—ç¬¦è¢«èµ‹å€¼ç»™å˜é‡ \li{letter} ã€‚  å¾ªç¯ç»§ç»­ï¼Œ ç›´åˆ°æ²¡æœ‰å‰©ä½™çš„å­—ç¬¦ä¸²äº†ã€‚

%ğŸ% The following example shows how to use concatenation (string addition)
%ğŸ% and a {\tt for} loop to generate an abecedarian series (that is, in
%ğŸ% alphabetical order).  In Robert McCloskey's book {\em Make
%ğŸ% Way for Ducklings}, the names of the ducklings are Jack, Kack, Lack,
%ğŸ% Mack, Nack, Ouack, Pack, and Quack.  This loop outputs these names in
%ğŸ% order:

ä¸‹é¢çš„ä¾‹å­æ¼”ç¤ºäº†å¦‚ä½•ä½¿ç”¨æ‹¼æ¥(å­—ç¬¦ä¸²ç›¸åŠ )å’Œ \li{for} å¾ªç¯ç”Ÿæˆä¸€ä¸ªå­—æ¯è¡¨åºåˆ— (å³æŒ‰ç…§å­—æ¯è¡¨é¡ºåºæ’åˆ—)ã€‚  åœ¨ Robert McCloskey çš„ä¹¦ ã€Š{\em Make Way for Ducklings}ã€‹ ä¸­ï¼Œ å°é¸­å­çš„åå­—æ˜¯ Jackã€ Kackã€ Lackã€ Mackã€ Nackã€ Ouackã€ Pack å’Œ Quackã€‚  æ­¤å¾ªç¯æŒ‰é¡ºåºè¾“å‡ºè¿™äº›åå­—ï¼š
\index{æ‹¼æ¥} \index{å­—æ¯è¡¨åºåˆ—}

\begin{lstlisting}
prefixes = 'JKLMNOPQ'
suffix = 'ack'

for letter in prefixes:
    print(letter + suffix)
\end{lstlisting}

%
The output is:
è¾“å‡ºæ˜¯ï¼š

\begin{lstlisting}
Jack
Kack
Lack
Mack
Nack
Oack
Pack
Qack
\end{lstlisting}

%
%ğŸ% Of course, that's not quite right because ``Ouack'' and ``Quack'' are
%ğŸ% misspelled.  As an exercise, modify the program to fix this error.

å½“ç„¶ï¼Œ è¾“å‡ºå¹¶ä¸å®Œå…¨æ­£ç¡®ï¼Œ å› ä¸º ``Ouack'' å’Œ ``Quack'' æ‹¼å†™é”™äº†ã€‚  æˆ‘ä»¬åšä¸ªç»ƒä¹ ï¼Œ ä¿®æ”¹è¿™ä¸ªç¨‹åºï¼Œ è§£å†³è¿™ä¸ªé—®é¢˜ã€‚


%ğŸ% \section{String slices  |  å­—ç¬¦ä¸²åˆ‡ç‰‡}
\section{å­—ç¬¦ä¸²åˆ‡ç‰‡}
\label{slice}
\index{slice operator} \index{operator!slice} \index{index!slice}
\index{string!slice} \index{slice!string}
\index{åˆ‡ç‰‡æ“ä½œ} \index{æ“ä½œ!åˆ‡ç‰‡} \index{ç´¢å¼•!åˆ‡ç‰‡}
\index{å­—ç¬¦ä¸²!åˆ‡ç‰‡} \index{åˆ‡ç‰‡!å­—ç¬¦ä¸²}



%ğŸ% A segment of a string is called a {\bf slice}.  Selecting a slice is
%ğŸ% similar to selecting a character:

å­—ç¬¦ä¸²çš„ä¸€ä¸ªç‰‡æ®µè¢«ç§°ä½œ {\em åˆ‡ç‰‡} (slice)ã€‚  é€‰æ‹©ä¸€ä¸ªåˆ‡ç‰‡çš„æ“ä½œç±»ä¼¼äºé€‰æ‹©ä¸€ä¸ªå­—ç¬¦ï¼š

\begin{lstlisting}
>>> s = 'Monty Python'
>>> s[0:5]
'Monty'
>>> s[6:12]
'Python'
\end{lstlisting}

%
%ğŸ% The operator {\tt [n:m]} returns the part of the string from the
%ğŸ% ``n-eth'' character to the ``m-eth'' character, including the first but
%ğŸ% excluding the last.  This behavior is counterintuitive, but it might
%ğŸ% help to imagine the indices pointing {\em between} the
%ğŸ% characters, as in Figure~\ref{fig.banana}.

æ“ä½œç¬¦ \li{[n:m]} è¿”å›ä»ç¬¬ n ä¸ªå­—ç¬¦åˆ°ç¬¬ m ä¸ªå­—ç¬¦çš„å­—ç¬¦ä¸²ç‰‡æ®µï¼Œ åŒ…æ‹¬ç¬¬ä¸€ä¸ªï¼Œ ä½†æ˜¯ä¸åŒ…æ‹¬æœ€åä¸€ä¸ªã€‚  è¿™ä¸ªè¡Œä¸ºè¿åç›´è§‰ï¼Œ ä½†æ˜¯å°†æŒ‡å‘ä¸¤ä¸ªå­—ç¬¦ä¹‹é—´çš„ç´¢å¼•ï¼Œ æƒ³è±¡æˆå›¾~ \ref{fig.banana} ä¸­é‚£æ ·æˆ–è®¸æœ‰å¸®åŠ©ã€‚

\begin{figure}
\centerline
{\includegraphics[scale=0.9]{../source/figs/banana.pdf}}
% \caption{Slice indices.}
\caption{åˆ‡ç‰‡ç´¢å¼•ã€‚  }
\label{fig.banana}
\end{figure}

%ğŸ% If you omit the first index (before the colon), the slice starts at
%ğŸ% the beginning of the string.  If you omit the second index, the slice
%ğŸ% goes to the end of the string:

å¦‚æœä½ çœç•¥ç¬¬ä¸€ä¸ªç´¢å¼•(å†’å·å‰é¢çš„å€¼)ï¼Œ åˆ‡ç‰‡èµ·å§‹äºå­—ç¬¦ä¸²å¤´éƒ¨ã€‚  å¦‚æœä½ çœç•¥ç¬¬äºŒä¸ªç´¢å¼•ï¼Œ åˆ‡ç‰‡ä¸€ç›´åˆ°å­—ç¬¦ä¸²ç»“å°¾ï¼š

\begin{lstlisting}
>>> fruit = 'banana'
>>> fruit[:3]
'ban'
>>> fruit[3:]
'ana'
\end{lstlisting}

%
%ğŸ% If the first index is greater than or equal to the second the result
%ğŸ% is an {\bf empty string}, represented by two quotation marks:
%ğŸ% \index{quotation mark}

å¦‚æœç¬¬ä¸€ä¸ªç´¢å¼•å¤§äºæˆ–ç­‰äºç¬¬äºŒä¸ªï¼Œ ç»“æœæ˜¯ {\bf ç©ºå­—ç¬¦ä¸²}\footnote{empty string} ï¼Œ ç”¨ä¸¤ä¸ªå¼•å·è¡¨ç¤ºï¼š

\begin{lstlisting}
>>> fruit = 'banana'
>>> fruit[3:3]
''
\end{lstlisting}

%
%ğŸ% An empty string contains no characters and has length 0, but other
%ğŸ% than that, it is the same as any other string.

ä¸€ä¸ªç©ºå­—ç¬¦ä¸²ä¸åŒ…æ‹¬å­—ç¬¦è€Œä¸”é•¿åº¦ä¸º 0ï¼Œ ä½†é™¤æ­¤ä¹‹å¤–ï¼Œ å®ƒå’Œå…¶å®ƒä»»ä½•å­—ç¬¦ä¸²ä¸€æ ·ã€‚

%ğŸ% Continuing this example, what do you think
%ğŸ% {\tt fruit[:]} means?  Try it and see.
\index{copy!slice}  \index{slice!copy}
\index{å¤åˆ¶!åˆ‡ç‰‡}  \index{åˆ‡ç‰‡!å¤åˆ¶}

%ğŸ% \section{Strings are immutable  |  å­—ç¬¦ä¸²æ˜¯ä¸å¯å˜çš„}
\section{å­—ç¬¦ä¸²æ˜¯ä¸å¯å˜çš„}
\index{mutability}  \index{immutability}  \index{string!immutable}
\index{å¯å˜æ€§}  \index{ä¸å¯å˜æ€§}  \index{å­—ç¬¦ä¸²!ä¸å¯å˜}

%ğŸ% It is tempting to use the {\tt []} operator on the left side of an
%ğŸ% assignment, with the intention of changing a character in a string.
%ğŸ% For example:
%ğŸ% \index{TypeError}  \index{exception!TypeError}

ä½ ä¼šå¾ˆæƒ³åœ¨èµ‹å€¼è¯­å¥çš„å·¦è¾¹ä½¿ç”¨ \li{[]}ï¼Œ æ¥æ”¹å˜å­—ç¬¦ä¸²çš„ä¸€ä¸ªå­—ç¬¦ã€‚  ä¾‹å¦‚:
\index{TypeError}  \index{exception!TypeError}

\begin{lstlisting}
>>> greeting = 'Hello, world!'
>>> greeting[0] = 'J'
TypeError: 'str' object does not support item assignment
\end{lstlisting}

%
%ğŸ% The ``object'' in this case is the string and the ``item'' is
%ğŸ% the character you tried to assign.  For now, an object is
%ğŸ% the same thing as a value, but we will refine that definition
%ğŸ% later (Section~\ref{equivalence}).
\index{object}  \index{item}  \index{item assignment}
\index{assignment!item}  \index{immutability}
\index{å¯¹è±¡}  \index{å…ƒç´ }  \index{å…ƒç´ èµ‹å€¼}
\index{èµ‹å€¼!å…ƒç´ }  \index{ä¸å¯å˜æ€§}



é”™è¯¯ä¿¡æ¯ä¸­çš„ ``object (å¯¹è±¡)'' æ˜¯é‚£ä¸ªå­—ç¬¦ä¸²ï¼Œ ``item (å…ƒç´ )''æ˜¯ä½ è¦èµ‹å€¼çš„å­—ç¬¦ã€‚  ç›®å‰ï¼Œ æˆ‘ä»¬è®¤ä¸ºå¯¹è±¡å’Œå€¼æ˜¯åŒæ ·çš„ä¸œè¥¿ï¼Œ ä½†æ˜¯æˆ‘ä»¬åé¢å°†æ”¹è¿›æ­¤å®šä¹‰ (è¯¦è§ \ref{equivalence}~èŠ‚)ã€‚

%ğŸ% The reason for the error is that
%ğŸ% strings are {\bf immutable}, which means you can't change an
%ğŸ% existing string.  The best you can do is create a new string
%ğŸ% that is a variation on the original:

å‡ºç°æ­¤é”™è¯¯çš„åŸå› æ˜¯å­—ç¬¦ä¸²æ˜¯ {\bf ä¸å¯å˜\footnote{immutable}çš„}ï¼Œ è¿™æ„å‘³ç€ä½ ä¸èƒ½æ”¹å˜ä¸€ä¸ªå·²å­˜åœ¨çš„å­—ç¬¦ä¸²ã€‚  ä½ æœ€å¤šåªèƒ½åˆ›å»ºä¸€ä¸ªæ–°çš„å­—ç¬¦ä¸²ï¼Œ åœ¨åŸæœ‰å­—ç¬¦ä¸²çš„åŸºç¡€ä¸Šç•¥æœ‰å˜åŒ–ï¼š

\begin{lstlisting}
>>> greeting = 'Hello, world!'
>>> new_greeting = 'J' + greeting[1:]
>>> new_greeting
'Jello, world!'
\end{lstlisting}

%
%ğŸ% This example concatenates a new first letter onto
%ğŸ% a slice of {\tt greeting}.  It has no effect on
%ğŸ% the original string.
\index{concatenation}

ä¸Šé¢çš„ç¤ºä¾‹ä¸­ï¼Œ æˆ‘ä»¬å°†ä¸€ä¸ªæ–°çš„é¦–å­—æ¯æ‹¼æ¥åˆ° \li{greeting} çš„ä¸€ä¸ªåˆ‡ç‰‡ä¸Šã€‚  å®ƒä¸å½±å“åŸå­—ç¬¦ä¸²ã€‚


%ğŸ% \section{Searching  |  æœç´¢}
\section{æœç´¢}
\label{find}

%ğŸ% What does the following function do?
\index{find function}  \index{function!find}

ä¸‹é¢çš„å‡½æ•°èµ·ä»€ä¹ˆä½œç”¨?

\begin{lstlisting}
def find(word, letter):
    index = 0
    while index < len(word):
        if word[index] == letter:
            return index
        index = index + 1
    return -1
\end{lstlisting}

%
%ğŸ% In a sense, {\tt find} is the inverse of the {\tt []} operator.
%ğŸ% Instead of taking an index and extracting the corresponding character,
%ğŸ% it takes a character and finds the index where that character
%ğŸ% appears.  If the character is not found, the function returns {\tt
%ğŸ% -1}.

åœ¨æŸç§æ„ä¹‰ä¸Šï¼Œ \li{find} å’Œ \li{[]} è¿ç®—ç¬¦ç›¸åã€‚  ä¸æ¥å—ä¸€ä¸ªç´¢å¼•å¹¶æå–ç›¸åº”çš„å­—ç¬¦ä¸åŒï¼Œ å®ƒæ¥å—ä¸€ä¸ªå­—ç¬¦å¹¶æ‰¾åˆ°è¯¥å­—ç¬¦æ‰€åœ¨çš„ç´¢å¼•ã€‚  å¦‚æœæ²¡æœ‰æ‰¾åˆ°è¯¥å­—ç¬¦ï¼Œ å‡½æ•°è¿”å› \li{-1}ã€‚

%ğŸ% This is the first example we have seen of a {\tt return} statement
%ğŸ% inside a loop.  If {\tt word[index] == letter}, the function breaks
%ğŸ% out of the loop and returns immediately.

è¿™æ˜¯æˆ‘ä»¬ç¬¬ä¸€æ¬¡åœ¨å¾ªç¯å†…éƒ¨çœ‹è§ \li{return} è¯­å¥ã€‚  å¦‚æœ \li{word[index] == letter}ï¼Œ
å‡½æ•°åœæ­¢å¾ªç¯å¹¶é©¬ä¸Šè¿”å›ã€‚

%ğŸ% If the character doesn't appear in the string, the program
%ğŸ% exits the loop normally and  returns {\tt -1}.

å¦‚æœå­—ç¬¦æ²¡å‡ºç°åœ¨å­—ç¬¦ä¸²ä¸­ï¼Œ é‚£ä¹ˆç¨‹åºæ­£å¸¸é€€å‡ºå¾ªç¯å¹¶è¿”å› \li{-1}ã€‚

%ğŸ% This pattern of computation---traversing a sequence and returning
%ğŸ% when we find what we are looking for---is called a {\bf search}.
\index{traversal}  \index{search pattern}  \index{pattern!search}

è¿™ç§è®¡ç®—æ¨¡å¼â€”â€”éå†ä¸€ä¸ªåºåˆ—å¹¶åœ¨æ‰¾åˆ°å¯»æ‰¾çš„ä¸œè¥¿æ—¶è¿”å›â€”â€”è¢«ç§°ä½œ {\em æœç´¢} (search)ã€‚

%ğŸ% As an exercise, modify {\tt find} so that it has a
%ğŸ% third parameter, the index in {\tt word} where it should start
%ğŸ% looking.

æˆ‘ä»¬åšä¸ªç»ƒä¹ ï¼Œ ä¿®æ”¹ \li {find} å‡½æ•°ä½¿å¾—å®ƒèƒ½æ¥å—ç¬¬ä¸‰ä¸ªå‚æ•°ï¼Œ å³ä»ä½•å¤„å¼€å§‹æœç´¢çš„ç´¢å¼•ã€‚

%ğŸ% \section{Looping and counting  |  å¾ªç¯å’Œè®¡æ•°}
\section{å¾ªç¯å’Œè®¡æ•°}
\label{counter}
\index{counter}  \index{counting and looping}
\index{looping and counting}  \index{looping!with strings}

%ğŸ% The following program counts the number of times the letter {\tt a}
%ğŸ% appears in a string:

ä¸‹é¢çš„ç¨‹åºè®¡ç®—å­—æ¯aåœ¨å­—ç¬¦ä¸²ä¸­å‡ºç°çš„æ¬¡æ•°ï¼š

\begin{lstlisting}
word = 'banana'
count = 0
for letter in word:
    if letter == 'a':
        count = count + 1
print(count)
\end{lstlisting}

%
%ğŸ% This program demonstrates another pattern of computation called a {\bf
%ğŸ% counter}.  The variable {\tt count} is initialized to 0 and then
%ğŸ% incremented each time an {\tt a} is found.
%ğŸ% When the loop exits, {\tt count}
%ğŸ% contains the result---the total number of {\tt a}'s.

æ­¤ç¨‹åºæ¼”ç¤ºäº†å¦ä¸€ç§è¢«ç§°ä½œ {\em è®¡æ•°å™¨} (counter) çš„è®¡ç®—æ¨¡å¼ã€‚  å˜é‡ \li{count} åˆå§‹åŒ–ä¸º 0 ï¼Œ ç„¶åæ¯æ¬¡å‡ºç° \li{a} æ—¶é€’å¢ã€‚  å½“å¾ªç¯ç»“æŸæ—¶ï¼Œ \li{count} åŒ…å«äº†å­—æ¯ \li{a} å‡ºç°çš„æ€»æ¬¡æ•°ã€‚

\index{encapsulation}

%ğŸ% As an exercise, encapsulate this code in a function named {\tt
%ğŸ% count}, and generalize it so that it accepts the string and the
%ğŸ% letter as arguments.

\index{å°è£…}
æˆ‘ä»¬åšä¸€ä¸ªç»ƒä¹ ï¼Œ å°†è¿™æ®µä»£ç å°è£…åœ¨ä¸€ä¸ªåä¸º \li{count} çš„å‡½æ•°ä¸­ï¼Œ å¹¶æ³›åŒ–è¯¥å‡½æ•°ï¼Œ ä½¿å…¶æ¥å—å­—ç¬¦ä¸²å’Œå­—æ¯ä½œä¸ºå®å‚ã€‚

%ğŸ% Then rewrite the function so that instead of
%ğŸ% traversing the string, it uses the three-parameter version of {\tt
%ğŸ% find} from the previous section.

ç„¶åé‡å†™è¿™ä¸ªå‡½æ•°ï¼Œ ä¸å†ä½¿ç”¨å­—ç¬¦ä¸²éå†ï¼Œ è€Œæ˜¯ä½¿ç”¨ä¸Šä¸€èŠ‚ä¸­ä¸‰å‚æ•°ç‰ˆæœ¬çš„ \li{find} å‡½æ•°ã€‚

%ğŸ% \section{String methods  |  å­—ç¬¦ä¸²æ–¹æ³•}
\section{å­—ç¬¦ä¸²æ–¹æ³•}
\label{optional}

%ğŸ% Strings provide methods that perform a variety of useful operations.
%ğŸ% A method is similar to a function---it takes arguments and
%ğŸ% returns a value---but the syntax is different.  For example, the
%ğŸ% method {\tt upper} takes a string and returns a new string with
%ğŸ% all uppercase letters.
\index{method}  \index{string!method}

å­—ç¬¦ä¸²æä¾›äº†å¯æ‰§è¡Œå¤šç§æœ‰ç”¨æ“ä½œçš„ {\em æ–¹æ³•} (method) ã€‚  æ–¹æ³•å’Œå‡½æ•°ç±»ä¼¼ï¼Œ æ¥å—å®å‚å¹¶è¿”å›ä¸€ä¸ªå€¼ï¼Œ ä½†æ˜¯è¯­æ³•ä¸åŒã€‚  ä¾‹å¦‚ï¼Œ \li{upper} æ–¹æ³•æ¥å—ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œ å¹¶è¿”å›ä¸€ä¸ªéƒ½æ˜¯å¤§å†™å­—æ¯çš„æ–°å­—ç¬¦ä¸²ã€‚
\index{æ–¹æ³•}  \index{å­—ç¬¦ä¸²!æ–¹æ³•}

%ğŸ% Instead of the function syntax {\tt upper(word)}, it uses
%ğŸ% the method syntax {\tt word.upper()}.

ä¸è¿‡ä½¿ç”¨çš„ä¸æ˜¯å‡½æ•°è¯­æ³• \li{upper(word)} ï¼Œ è€Œæ˜¯æ–¹æ³•çš„è¯­æ³• \li{word.upper()}ã€‚

\begin{lstlisting}
>>> word = 'banana'
>>> new_word = word.upper()
>>> new_word
'BANANA'
\end{lstlisting}

%
%ğŸ% This form of dot notation specifies the name of the method, {\tt
%ğŸ% upper}, and the name of the string to apply the method to, {\tt
%ğŸ% word}.  The empty parentheses indicate that this method takes no
%ğŸ% arguments.
\index{parentheses!empty}  \index{dot notation}

ç‚¹æ ‡è®°æ³•çš„å½¢å¼æŒ‡å‡ºæ–¹æ³•çš„åå­—ï¼Œ \li{upper}ï¼Œ ä»¥åŠåº”ç”¨è¯¥æ–¹æ³•çš„å­—ç¬¦ä¸²çš„åå­—ï¼Œ \li{word}ã€‚  ç©ºæ‹¬å·è¡¨æ˜è¯¥æ–¹æ³•ä¸æ¥å—å®å‚ã€‚

%ğŸ% A method call is called an {\bf invocation}; in this case, we would
%ğŸ% say that we are invoking {\tt upper} on {\tt word}.
\index{invocation}

è¿™è¢«ç§°ä½œ {\em æ–¹æ³•è°ƒç”¨} (invocation)ï¼› æ­¤ä¾‹ä¸­ï¼Œ æˆ‘ä»¬å¯ä»¥è¯´æ˜¯åœ¨ \li{word} ä¸Šè°ƒç”¨ \li{upper} ã€‚

%ğŸ% As it turns out, there is a string method named {\tt find} that
%ğŸ% is remarkably similar to the function we wrote:

äº‹å®ä¸Šï¼Œ æœ‰ä¸€ä¸ªè¢«ç§°ä¸º \li{find} çš„å­—ç¬¦ä¸²æ–¹æ³•ï¼Œ ä¸æˆ‘ä»¬ä¹‹å‰å†™çš„å‡½æ•°æå…¶ç›¸ä¼¼ï¼š

\begin{lstlisting}
>>> word = 'banana'
>>> index = word.find('a')
>>> index
1
\end{lstlisting}

%
%ğŸ% In this example, we invoke {\tt find} on {\tt word} and pass
%ğŸ% the letter we are looking for as a parameter.

æ­¤ä¾‹ä¸­ï¼Œ æˆ‘ä»¬åœ¨ \li{word} ä¸Šè°ƒç”¨ \li{find} ï¼Œ å¹¶å°†æˆ‘ä»¬è¦æ‰¾çš„å­—æ¯ä½œä¸ºå‚æ•°ä¼ å…¥ã€‚

%ğŸ% Actually, the {\tt find} method is more general than our function;
%ğŸ% it can find substrings, not just characters

äº‹å®ä¸Šï¼Œ \li{find} æ–¹æ³•æ¯”æˆ‘ä»¬çš„å‡½æ•°æ›´é€šç”¨ï¼› å®ƒè¿˜å¯ä»¥æŸ¥æ‰¾å­å­—ç¬¦ä¸²ï¼Œ è€Œä¸ä»…ä»…æ˜¯å­—ç¬¦:

\begin{lstlisting}
>>> word.find('na')
2
\end{lstlisting}

%
%ğŸ% By default, {\tt find} starts at the beginning of the string, but
%ğŸ% it can take a second argument, the index where it should start:
\index{optional argument}  \index{argument!optional}

\li{find} é»˜è®¤ä»å­—ç¬¦ä¸²çš„é¦–å­—æ¯å¼€å§‹æŸ¥æ‰¾ï¼Œ å®ƒè¿˜å¯ä»¥æ¥å—ç¬¬äºŒä¸ªå®å‚ï¼Œ å³ä»ä½•å¤„å¼€å§‹çš„ç´¢å¼•ã€‚

\begin{lstlisting}
>>> word.find('na', 3)
4
\end{lstlisting}

%
%ğŸ% This is an example of an {\bf optional argument};
%ğŸ% {\tt find} can
%ğŸ% also take a third argument, the index where it should stop:

è¿™æ˜¯ä¸€ä¸ª {\em å¯é€‰å‚æ•°} (optional argument) çš„ä¾‹å­ï¼› \li{find} ä¹Ÿå¯ä»¥æ¥å—ç»“æŸæŸ¥æ‰¾çš„ç´¢å¼•ä½œä¸ºç¬¬ä¸‰ä¸ªå®å‚ï¼š

\begin{lstlisting}
>>> name = 'bob'
>>> name.find('b', 1, 2)
-1
\end{lstlisting}

%
%ğŸ% This search fails because {\tt b} does not
%ğŸ% appear in the index range from {\tt 1} to {\tt 2}, not including {\tt
%ğŸ% 2}.  Searching up to, but not including, the second index makes
%ğŸ% {\tt find} consistent with the slice operator.

æ­¤æ¬¡æœç´¢å¤±è´¥ï¼Œ å› ä¸º \li{'b'} æ²¡æœ‰å‡ºç°åœ¨ç´¢å¼• \li{1}--\li{2} ä¹‹é—´(ä¸åŒ…æ‹¬\li{2})ã€‚  ä¸€ç›´æœç´¢åˆ°ç¬¬äºŒä¸ªç´¢å¼•ï¼Œ ä½†æ˜¯å¹¶ä¸æœç´¢ç¬¬äºŒä¸ªç´¢å¼•ï¼Œ è¿™ä½¿å¾— \li{find} è·Ÿåˆ‡ç‰‡è¿ç®—ç¬¦çš„è¡Œä¸ºä¸€è‡´.

%ğŸ% \section{The {\tt in} operator  |  {\tt in} è¿ç®—ç¬¦}
\section{{\tt in} è¿ç®—ç¬¦}
\label{inboth}
\index{in operator}  \index{operator!in}
\index{boolean operator}  \index{operator!boolean}

%ğŸ% The word {\tt in} is a boolean operator that takes two strings and
%ğŸ% returns {\tt True} if the first appears as a substring in the second:

å•è¯ \li{in} æ˜¯ä¸€ä¸ªå¸ƒå°”è¿ç®—ç¬¦ï¼Œ æ¥å—ä¸¤ä¸ªå­—ç¬¦ä¸²ã€‚  å¦‚æœç¬¬ä¸€ä¸ªä½œä¸ºå­ä¸²å‡ºç°åœ¨ç¬¬äºŒä¸ªä¸­ï¼Œ åˆ™è¿”å› \li{True}ï¼š

\begin{lstlisting}
>>> 'a' in 'banana'
True
>>> 'seed' in 'banana'
False
\end{lstlisting}

%
%ğŸ% For example, the following function prints all the
%ğŸ% letters from {\tt word1} that also appear in {\tt word2}:

ä¾‹å¦‚ï¼Œ ä¸‹é¢çš„å‡½æ•°æ‰“å°æ‰€æœ‰æ—¢å‡ºç°åœ¨ \li{word1} ä¸­ï¼Œ ä¹Ÿå‡ºç°åœ¨ \li{word2} ä¸­çš„å­—æ¯ï¼š

\begin{lstlisting}
def in_both(word1, word2):
    for letter in word1:
        if letter in word2:
            print(letter)
\end{lstlisting}

%
%ğŸ% With well-chosen variable names,
%ğŸ% Python sometimes reads like English.  You could read
%ğŸ% this loop, ``for (each) letter in (the first) word, if (the) letter
%ğŸ% (appears) in (the second) word, print (the) letter.''

å˜é‡åæŒ‘é€‰å¾—å½“çš„è¯ï¼Œ Python ä»£ç æœ‰æ—¶å€™è¯»èµ·æ¥åƒæ˜¯è‡ªç„¶è¯­è¨€ã€‚  ä½ å¯ä»¥è¿™æ ·è¯»æ­¤å¾ªç¯ï¼Œ ``å¯¹äº(æ¯ä¸ª) åœ¨(ç¬¬ä¸€ä¸ª)å•è¯ä¸­çš„å­—æ¯ï¼Œ å¦‚æœ(è¯¥)å­—æ¯(å‡ºç°)åœ¨(ç¬¬äºŒä¸ª)å•è¯ä¸­ï¼Œ æ‰“å°(è¯¥)å­—æ¯''ã€‚

%ğŸ% Here's what you get if you compare apples and oranges:

å¦‚æœä½ æ¯”è¾ƒ \li{'apples'} å’Œ \li{'oranges'}ï¼Œ ä½ ä¼šå¾—åˆ°ä¸‹é¢çš„ç»“æœï¼š

\begin{lstlisting}
>>> in_both('apples', 'oranges')
a
e
s
\end{lstlisting}

%

%ğŸ% \section{String comparison  |  å­—ç¬¦ä¸²æ¯”è¾ƒ}
\section{å­—ç¬¦ä¸²æ¯”è¾ƒ}
\index{string!comparison}  \index{comparison!string}

%ğŸ% The relational operators work on strings.  To see if two strings are equal:

å…³ç³»è¿ç®—ç¬¦ä¹Ÿé€‚ç”¨äºå­—ç¬¦ä¸²ã€‚  å¯ä»¥è¿™æ ·æ£€æŸ¥ä¸¤ä¸ªå­—ç¬¦ä¸²æ˜¯å¦ç›¸ç­‰ï¼š

\begin{lstlisting}
if word == 'banana':
    print('All right, bananas.')
\end{lstlisting}

%
%ğŸ% Other relational operations are useful for putting words in alphabetical
%ğŸ% order:

å…¶å®ƒçš„å…³ç³»è¿ç®—ç¬¦å¯¹äºæŒ‰å­—æ¯åºæ”¾ç½®å•è¯ä¹Ÿå¾ˆæœ‰ç”¨ï¼š

\begin{lstlisting}
if word < 'banana':
    print('Your word, ' + word + ', comes before banana.')
elif word > 'banana':
    print('Your word, ' + word + ', comes after banana.')
else:
    print('All right, bananas.')
\end{lstlisting}

%
%ğŸ% Python does not handle uppercase and lowercase letters the same way
%ğŸ% people do.  All the uppercase letters come before all the
%ğŸ% lowercase letters, so:

Pythonå¤„ç†å¤§å†™å’Œå°å†™å­—æ¯çš„æ–¹å¼å’Œäººä¸åŒã€‚  æ‰€æœ‰çš„å¤§å†™å­—æ¯å‡ºç°åœ¨æ‰€æœ‰å°å†™å­—æ¯ä¹‹å‰ï¼Œ æ‰€ä»¥ï¼š

\begin{lstlisting}
Your word, Pineapple, comes before banana.
\end{lstlisting}

%
%ğŸ% A common way to address this problem is to convert strings to a
%ğŸ% standard format, such as all lowercase, before performing the
%ğŸ% comparison. Keep that in mind in case you have to defend yourself
%ğŸ% against a man armed with a Pineapple.

%ğŸ% \section{Debugging  |  è°ƒè¯•}
\section{è°ƒè¯•}
\index{debugging}  \index{traversal}
\index{è°ƒè¯•}  \index{éå†}

%ğŸ% When you use indices to traverse the values in a sequence,
%ğŸ% it is tricky to get the beginning and end of the traversal
%ğŸ% right.  Here is a function that is supposed to compare two
%ğŸ% words and return {\tt True} if one of the words is the reverse
%ğŸ% of the other, but it contains two errors:

å½“ä½ ä½¿ç”¨ç´¢å¼•éå†åºåˆ—ä¸­çš„å€¼æ—¶ï¼Œ æ­£ç¡®åœ°æŒ‡å®šéå†çš„èµ·å§‹å’Œç»“æŸç‚¹æœ‰ç‚¹å›°éš¾ã€‚  ä¸‹é¢æ˜¯ä¸€ä¸ªç”¨æ¥æ¯”è¾ƒä¸¤ä¸ªå•è¯çš„å‡½æ•°ï¼Œ å¦‚æœä¸€ä¸ªå•è¯æ˜¯å¦ä¸€ä¸ªçš„å€’åºï¼Œ åˆ™è¿”å› \li{True} ï¼Œ ä½†å…¶ä¸­æœ‰ä¸¤ä¸ªé”™è¯¯ï¼š

\begin{lstlisting}
def is_reverse(word1, word2):
    if len(word1) != len(word2):
        return False

    i = 0
    j = len(word2)

    while j > 0:
        if word1[i] != word2[j]:
            return False
        i = i+1
        j = j-1

    return True
\end{lstlisting}

%
%ğŸ% The first {\tt if} statement checks whether the words are the
%ğŸ% same length.  If not, we can return {\tt False} immediately.
%ğŸ% Otherwise, for the rest of the function, we can assume that the words
%ğŸ% are the same length.  This is an example of the guardian pattern
%ğŸ% in Section~\ref{guardian}.
\index{guardian pattern}  \index{pattern!guardian}
\index{index}
\index{ç›‘æŠ¤äººæ¨¡å¼}  \index{æ¨¡å¼!ç›‘æŠ¤äºº}
\index{ç´¢å¼•}

ç¬¬ä¸€æ¡ \li{if} è¯­å¥æ£€æŸ¥ä¸¤ä¸ªå•è¯æ˜¯å¦ç­‰é•¿ã€‚  å¦‚æœä¸æ˜¯ï¼Œ æˆ‘ä»¬å¯ä»¥é©¬ä¸Šè¿”å› \li{False} ã€‚  å¦åˆ™ï¼Œ åœ¨å‡½æ•°å…¶ä½™çš„éƒ¨åˆ†ï¼Œ æˆ‘ä»¬å¯ä»¥å‡å®šå•è¯æ˜¯ç­‰é•¿çš„ã€‚  è¿™æ˜¯~\ref{guardian}èŠ‚ä¸­æåˆ°çš„ç›‘æŠ¤äººæ¨¡å¼çš„ä¸€ä¸ªä¾‹å­ã€‚

%ğŸ% {\tt i} and {\tt j} are indices: {\tt i} traverses {\tt word1}
%ğŸ% forward while {\tt j} traverses {\tt word2} backward.  If we find
%ğŸ% two letters that don't match, we can return {\tt False} immediately.
%ğŸ% If we get through the whole loop and all the letters match, we
%ğŸ% return {\tt True}.

\li{i} å’Œ \li{j} æ˜¯ç´¢å¼•ï¼š\li{i} å‘å‰éå† \li{word1}ï¼Œ \li{j} å‘åéå† \li{word2}ã€‚  å¦‚æœæˆ‘ä»¬æ‰¾åˆ°ä¸¤ä¸ªä¸åŒ¹é…çš„å­—æ¯ï¼Œ æˆ‘ä»¬å¯ä»¥ç«‹å³è¿”å› \li{False}ã€‚  å¦‚æœæˆ‘ä»¬å®Œæˆæ•´ä¸ªå¾ªç¯å¹¶ä¸”æ‰€æœ‰å­—æ¯éƒ½åŒ¹é…ï¼Œ æˆ‘ä»¬è¿”å› \li{True} ã€‚

%ğŸ% If we test this function with the words ``pots'' and ``stop'', we
%ğŸ% expect the return value {\tt True}, but we get an IndexError:
\index{IndexError}  \index{exception!IndexError}

å¦‚æœæˆ‘ä»¬ç”¨å•è¯ ``pots'' å’Œ ``stop'' æµ‹è¯•è¯¥å‡½æ•°ï¼Œ æˆ‘ä»¬æœŸæœ›è¿”å› \li{True} ï¼Œ ä½†æ˜¯å´å¾—åˆ°ä¸€ä¸ª \li{IndexError}ï¼š

\begin{lstlisting}
>>> is_reverse('pots', 'stop')
...
  File "reverse.py", line 15, in is_reverse
    if word1[i] != word2[j]:
IndexError: string index out of range
\end{lstlisting}

%
%ğŸ% For debugging this kind of error, my first move is to
%ğŸ% print the values of the indices immediately before the line
%ğŸ% where the error appears.

ä¸ºäº†è°ƒè¯•è¯¥ç±»é”™è¯¯ï¼Œ æˆ‘ç¬¬ä¸€æ­¥æ˜¯åœ¨é”™è¯¯å‡ºç°çš„è¡Œä¹‹å‰ï¼Œ æ‰“å°ç´¢å¼•çš„å€¼ã€‚

\begin{lstlisting}
    while j > 0:
        print(i, j)        # print here

        if word1[i] != word2[j]:
            return False
        i = i+1
        j = j-1
\end{lstlisting}

%
%ğŸ% Now when I run the program again, I get more information:

ç°åœ¨ï¼Œ å½“æˆ‘å†æ¬¡è¿è¡Œè¯¥ç¨‹åºæ—¶ï¼Œ å°†è·å¾—æ›´å¤šçš„ä¿¡æ¯ï¼š

\begin{lstlisting}
>>> is_reverse('pots', 'stop')
0 4
...
IndexError: string index out of range
\end{lstlisting}

%
%ğŸ% The first time through the loop, the value of {\tt j} is 4,
%ğŸ% which is out of range for the string \verb"'pots'".
%ğŸ% The index of the last character is 3, so the
%ğŸ% initial value for {\tt j} should be {\tt len(word2)-1}.

ç¬¬ä¸€æ¬¡å¾ªç¯æ—¶ï¼Œ \li{j} çš„å€¼æ˜¯4ï¼Œ è¶…å‡ºå­—ç¬¦ä¸² \li{'post'} çš„èŒƒå›´äº†ã€‚  æœ€åä¸€ä¸ªå­—ç¬¦çš„ç´¢å¼•æ˜¯ \li{3}ï¼Œ æ‰€ä»¥ \li{j} çš„åˆå§‹å€¼åº”è¯¥æ˜¯ \li{len(word2)-1} ã€‚

%ğŸ% If I fix that error and run the program again, I get:

å¦‚æœæˆ‘è§£å†³äº†è¿™ä¸ªé”™è¯¯ï¼Œ ç„¶åè¿è¡Œç¨‹åºï¼Œ å°†è·å¾—å¦‚ä¸‹è¾“å‡º:

\begin{lstlisting}
>>> is_reverse('pots', 'stop')
0 3
1 2
2 1
True
\end{lstlisting}

%
%ğŸ% This time we get the right answer, but it looks like the loop only ran
%ğŸ% three times, which is suspicious.  To get a better idea of what is
%ğŸ% happening, it is useful to draw a state diagram.  During the first
%ğŸ% iteration, the frame for \verb"is_reverse" is shown in
%ğŸ% Figure~\ref{fig.state4}.  \index{state diagram} \index{diagram!state}

è¿™æ¬¡æˆ‘ä»¬è·å¾—äº†æ­£ç¡®çš„ç­”æ¡ˆï¼Œ ä½†æ˜¯çœ‹èµ·æ¥å¾ªç¯åªè¿è¡Œäº†ä¸‰æ¬¡ï¼Œ è¿™å¾ˆå¥‡æ€ªã€‚  ç”»æ ˆå›¾å¯ä»¥å¸®æˆ‘ä»¬æ›´å¥½çš„ç†è§£å‘ç”Ÿäº†ä»€ä¹ˆã€‚  åœ¨ç¬¬ä¸€æ¬¡è¿­ä»£æœŸé—´ï¼Œ \li{is_reverse} çš„æ ˆå¸§å¦‚å›¾~\ref{fig.state4} æ‰€ç¤ºã€‚

\begin{figure}
\centerline
{\includegraphics[scale=0.8]{../source/figs/state4.pdf}}
% \caption{State diagram.}
\caption{å †æ ˆå›¾ã€‚  }
\label{fig.state4}
\end{figure}

%ğŸ% I took some license by arranging the variables in the frame
%ğŸ% and adding dotted lines to show that the values of {\tt i} and
%ğŸ% {\tt j} indicate characters in {\tt word1} and {\tt word2}.

æˆ‘å¯¹å †æ ˆå›¾åšäº†äº›è°ƒæ•´ï¼Œ é‡æ–°æ’åˆ—äº†æ ˆå¸§ä¸­çš„å˜é‡ï¼Œ å¢åŠ äº†è™šçº¿æ¥è¯´æ˜ \li{i} å’Œ \li{j} çš„å€¼è¡¨ç¤º \li{word1} å’Œ \li{word2} ä¸­çš„å­—ç¬¦ã€‚


%ğŸ% Starting with this diagram, run the program on paper, changing the
%ğŸ% values of {\tt i} and {\tt j} during each iteration.  Find and fix the
%ğŸ% second error in this function.

ä»è¿™ä¸ªå †æ ˆå›¾å¼€å§‹ï¼Œ åœ¨çº¸ä¸Šè¿è¡Œç¨‹åºï¼Œ æ¯æ¬¡è¿­ä»£æ—¶ä¿®æ”¹ \li{i} å’Œ \li{j} çš„å€¼ã€‚  æŸ¥æ‰¾å¹¶è§£å†³è¿™ä¸ªå‡½æ•°çš„ä¸­ç¬¬äºŒä¸ªé”™è¯¯ã€‚
\label{isreverse}


%ğŸ% \section{Glossary  |  æœ¯è¯­è¡¨}
\section{æœ¯è¯­è¡¨}

%ğŸ% \begin{description}
%ğŸ%
%ğŸ% \item[object:] Something a variable can refer to.  For now,
%ğŸ% you can use ``object'' and ``value'' interchangeably.
%ğŸ% \index{object}
%ğŸ%
%ğŸ% \item[sequence:] An ordered collection of
%ğŸ% values where each value is identified by an integer index.
%ğŸ% \index{sequence}
%ğŸ%
%ğŸ% \item[item:] One of the values in a sequence.
%ğŸ% \index{item}
%ğŸ%
%ğŸ% \item[index:] An integer value used to select an item in
%ğŸ% a sequence, such as a character in a string.  In Python
%ğŸ% indices start from 0.
%ğŸ% \index{index}
%ğŸ%
%ğŸ% \item[slice:] A part of a string specified by a range of indices.
%ğŸ% \index{slice}
%ğŸ%
%ğŸ% \item[empty string:] A string with no characters and length 0, represented
%ğŸ% by two quotation marks.
%ğŸ% \index{empty string}
%ğŸ%
%ğŸ% \item[immutable:] The property of a sequence whose items cannot
%ğŸ% be changed.
%ğŸ% \index{immutability}
%ğŸ%
%ğŸ% \item[traverse:] To iterate through the items in a sequence,
%ğŸ% performing a similar operation on each.
%ğŸ% \index{traversal}
%ğŸ%
%ğŸ% \item[search:] A pattern of traversal that stops
%ğŸ% when it finds what it is looking for.
%ğŸ% \index{search pattern}
%ğŸ% \index{pattern!search}
%ğŸ%
%ğŸ% \item[counter:] A variable used to count something, usually initialized
%ğŸ% to zero and then incremented.
%ğŸ% \index{counter}
%ğŸ%
%ğŸ% \item[invocation:] A statement that calls a method.
%ğŸ% \index{invocation}
%ğŸ%
%ğŸ% \item[optional argument:] A function or method argument that is not
%ğŸ% required.
%ğŸ% \index{optional argument}
%ğŸ% \index{argument!optional}
%ğŸ%
%ğŸ% \end{description}

\begin{description}

\item[å¯¹è±¡ (object)ï¼š] å˜é‡å¯ä»¥å¼•ç”¨çš„ä¸œè¥¿ã€‚  ç°åœ¨ä½ å°†å¯¹è±¡å’Œå€¼ç­‰ä»·ä½¿ç”¨ã€‚
\index{object}

\item[åºåˆ— (sequence)ï¼š] ä¸€ä¸ªæœ‰åºçš„å€¼çš„é›†åˆï¼Œ æ¯ä¸ªå€¼é€šè¿‡ä¸€ä¸ªæ•´æ•°ç´¢å¼•æ ‡è¯†ã€‚
\index{sequence}

\item[å…ƒç´  (item)ï¼š] åºåˆ—ä¸­çš„ä¸€ä¸ªå€¼ã€‚
\index{item}

\item[ç´¢å¼• (index)ï¼š] ç”¨æ¥é€‰æ‹©åºåˆ—ä¸­å…ƒç´  (å¦‚å­—ç¬¦ä¸²ä¸­çš„å­—ç¬¦) çš„ä¸€ä¸ªæ•´æ•°å€¼ã€‚  åœ¨Pythonä¸­ï¼Œ ç´¢å¼•ä»0å¼€å§‹ã€‚
\index{index}

\item[åˆ‡ç‰‡ (slice)ï¼š] ä»¥ç´¢å¼•èŒƒå›´æŒ‡å®šçš„å­—ç¬¦ä¸²ç‰‡æ®µã€‚
\index{slice}

\item[ç©ºå­—ç¬¦ä¸² (empty string)ï¼š] ä¸€ä¸ªæ²¡æœ‰å­—ç¬¦çš„å­—ç¬¦ä¸²ï¼Œ é•¿åº¦ä¸º0ï¼Œ ç”¨ä¸¤ä¸ªå¼•å·è¡¨ç¤ºã€‚
\index{empty string}

\item[ä¸å¯å˜æ€§ (immutable)] å…ƒç´ ä¸èƒ½è¢«æ”¹å˜çš„åºåˆ—çš„æ€§è´¨ã€‚
\index{immutability}

\item[éå† (traversal)ï¼š] å¯¹ä¸€ä¸ªåºåˆ—çš„æ‰€æœ‰å…ƒç´ è¿›è¡Œè¿­ä»£ï¼Œ å¯¹æ¯ä¸€å…ƒç´ æ‰§è¡Œç±»ä¼¼æ“ä½œã€‚
\index{traversal}

\item[æœç´¢ (search)ï¼š] ä¸€ç§éå†æ¨¡å¼ï¼Œ å½“æ‰¾åˆ°æœç´¢ç›®æ ‡æ—¶å°±åœæ­¢ã€‚
\index{search pattern}  \index{pattern!search}

\item[è®¡æ•°å™¨ (counter)ï¼š] ç”¨æ¥è®¡æ•°çš„å˜é‡ï¼Œ é€šå¸¸åˆå§‹åŒ–ä¸º0ï¼Œ å¹¶ä»¥æ­¤é€’å¢ã€‚
\index{counter}

\item[æ–¹æ³•è°ƒç”¨(invocation)ï¼š] æ‰§è¡Œä¸€ä¸ªæ–¹æ³•çš„å£°æ˜.
\index{invocation}

\item[å¯é€‰å‚æ•° (optional argument)ï¼š] ä¸€ä¸ªå‡½æ•°æˆ–è€…ä¸€ä¸ªæ–¹æ³•ä¸­ä¸å¿…è¦æŒ‡å®šçš„å‚æ•°ã€‚
\index{optional argument}  \index{argument!optional}

\end{description}


%ğŸ% \section{Exercises  |  ç»ƒä¹ }
\section{ç»ƒä¹ }

\begin{exercise}
\index{string method}  \index{method!string}

%ğŸ% Read the documentation of the string methods at
%ğŸ% \url{http://docs.python.org/3/library/stdtypes.html#string-methods}.
%ğŸ% You might want to experiment with some of them to make sure you
%ğŸ% understand how they work.  {\tt strip} and {\tt replace} are
%ğŸ% particularly useful.

ç‚¹å‡»å¦‚ä¸‹é“¾æ¥ï¼Œ é˜…è¯»\href{http://docs.python.org/3/library/stdtypes.html#string-methods}{å­—ç¬¦ä¸²æ–¹æ³•}çš„æ–‡æ¡£ã€‚   ä¸ºäº†ç¡®ä¿ä½ ç†è§£ä»–ä»¬æ˜¯æ€ä¹ˆå·¥ä½œçš„ï¼Œ å¯ä»¥å°è¯•ä½¿ç”¨å…¶ä¸­çš„ä¸€äº›æ–¹æ³•ã€‚  {\em \li{strip}} å’Œ {\em \li{replace}} å°¤å…¶æœ‰ç”¨ã€‚

%ğŸ% The documentation uses a syntax that might be confusing.
%ğŸ% For example, in \verb"find(sub[, start[, end]])", the brackets
%ğŸ% indicate optional arguments.  So {\tt sub} is required, but
%ğŸ% {\tt start} is optional, and if you include {\tt start},
%ğŸ% then {\tt end} is optional.

æ–‡æ¡£ä¸­ä½¿ç”¨äº†å¯èƒ½ä¼šå¼•èµ·å›°æƒ‘çš„å¥æ³•ã€‚  ä¾‹å¦‚ï¼Œ åœ¨ {\em \li{find(sub[, start[, end]])}} ä¸­ï¼Œ æ–¹æ‹¬å·æ„å‘³ç€è¿™æ˜¯å¯é€‰å‚æ•°ã€‚  æ‰€ä»¥ï¼Œ {\em \li{sub}} æ˜¯å¿…å¡«å‚æ•°ï¼Œ ä½†æ˜¯ {\em \li{start}} æ˜¯å¯é€‰çš„ï¼Œ è€Œä¸”å¦‚æœä½ æä¾›äº† {\em \li{start}} ï¼Œ ä¹Ÿä¸ä¸€å®šå¿…é¡»æä¾› {\em \li{end}} ã€‚

\index{optional argument}  \index{argument!optional}

\end{exercise}


\begin{exercise}
\index{count method}  \index{method!count}

%ğŸ% There is a string method called {\tt count} that is similar
%ğŸ% to the function in Section~\ref{counter}.  Read the documentation
%ğŸ% of this method
%ğŸ% and write an invocation that counts the number of {\tt a}'s
%ğŸ% in \verb"'banana'".

æœ‰ä¸€ä¸ªå­—ç¬¦ä¸²æ–¹æ³•å« {\em \li{count}} ï¼Œ å®ƒç±»ä¼¼äºä¹‹å‰ {\em \ref{counter}}~èŠ‚ä¸­çš„ {\em \li{counter}} ã€‚  é˜…è¯»è¿™ä¸ªæ–¹æ³•çš„æ–‡æ¡£ï¼Œ å†™ä¸€ä¸ªè®¡ç®— {\em \li{'banana'}} ä¸­ {\em \li{a}} çš„ä¸ªæ•°çš„æ–¹æ³•è°ƒç”¨ã€‚


\end{exercise}


\begin{exercise}
\index{step size}  \index{slice operator}  \index{operator!slice}
\index{æ­¥é•¿}  \index{åˆ‡ç‰‡æ“ä½œ}  \index{æ“ä½œ!åˆ‡ç‰‡}

%ğŸ% A string slice can take a third index that specifies the ``step
%ğŸ% size''; that is, the number of spaces between successive characters.
%ğŸ% A step size of 2 means every other character; 3 means every third,
%ğŸ% etc.

ä¸€ä¸ªå­—ç¬¦ä¸²åˆ‡ç‰‡å¯ä»¥æ¥å—æŒ‡å®šæ­¥é•¿çš„ç¬¬ä¸‰ä¸ªç´¢å¼•; ä¹Ÿå°±æ˜¯è¿ç»­å­—ç¬¦é—´ç©ºæ ¼çš„ä¸ªæ•°ã€‚  æ­¥é•¿ä¸º{\em 2}ï¼Œ æ„å‘³ç€æ¯éš”ä¸€ä¸ªå­—ç¬¦ï¼›æ­¥é•¿ä¸º{\em 3}ï¼Œ æ„å‘³ç€æ¯éš”ä¸¤ä¸ªå­—ç¬¦ï¼Œ ä»¥æ­¤ç±»æ¨ã€‚

\begin{lstlisting}
>>> fruit = 'banana'
>>> fruit[0:5:2]
'bnn'
\end{lstlisting}

%ğŸ% A step size of -1 goes through the word backwards, so
%ğŸ% the slice \verb"[::-1]" generates a reversed string.
\index{palindrome}

æ­¥é•¿ä¸º {\em \li{-1}} å°±æ˜¯ä»å•è¯çš„å°¾éƒ¨å¼€å§‹è¿›è¡Œï¼Œ æ‰€ä»¥åˆ‡ç‰‡ {\em \li{[::-1]}} ç”Ÿæˆä¸€ä¸ªå€’åºçš„å­—ç¬¦ä¸²ã€‚

%ğŸ% Use this idiom to write a one-line version of \verb"is_palindrome"
%ğŸ% from Exercise~\ref{palindrome}.

åˆ©ç”¨è¿™ä¸ªä¹ æƒ¯ç”¨æ³•\footnote{idiom}ï¼Œ å°†ä¹ é¢˜~{\em \ref{palindrome}}ä¸­ {\em \li{is_palindrome}} å‡½æ•°æ”¹å†™ä¸ºä¸€è¡Œä»£ç ç‰ˆã€‚

\end{exercise}

\begin{exercise}

%ğŸ% The following functions are all {\em intended} to check whether a
%ğŸ% string contains any lowercase letters, but at least some of them are
%ğŸ% wrong.  For each function, describe what the function actually does
%ğŸ% (assuming that the parameter is a string).

ä¸‹é¢è¿™äº›å‡½æ•°ï¼Œ éƒ½æ˜¯ {\bf ç”¨äº} æ£€æŸ¥ä¸€ä¸ªå­—ç¬¦ä¸²æ˜¯å¦åŒ…å«ä¸€äº›å°å†™å­—æ¯çš„ï¼Œ ä½†æ˜¯å…¶ä¸­è‡³å°‘æœ‰ä¸€äº›æ˜¯é”™è¯¯çš„å‡½æ•°ã€‚  æ£€æŸ¥æ¯ä¸ªå‡½æ•°ï¼Œ æè¿°è¿™ä¸ªå‡½æ•°å®é™…ä¸Šåšäº†ä»€ä¹ˆ {\em (} å‡è®¾å½¢å‚æ˜¯å­—ç¬¦ä¸²{\em )}ã€‚

\begin{em}
\begin{lstlisting}
def any_lowercase1(s):
    for c in s:
        if c.islower():
            return True
        else:
            return False

def any_lowercase2(s):
    for c in s:
        if 'c'.islower():
            return 'True'
        else:
            return 'False'

def any_lowercase3(s):
    for c in s:
        flag = c.islower()
    return flag

def any_lowercase4(s):
    flag = False
    for c in s:
        flag = flag or c.islower()
    return flag

def any_lowercase5(s):
    for c in s:
        if not c.islower():
            return False
    return True
\end{lstlisting}
\end{em}

\end{exercise}


\begin{exercise}
\index{letter rotation}  \index{rotation, letter}
\index{å­—æ¯åç§»}

\label{exrotate}
%ğŸ% A Caesar cypher is a weak form of encryption that involves ``rotating'' each
%ğŸ% letter by a fixed number of places.  To rotate a letter means
%ğŸ% to shift it through the alphabet, wrapping around to the beginning if
%ğŸ% necessary, so 'A' rotated by 3 is 'D' and 'Z' rotated by 1 is 'A'.

å‡¯æ’’å¯†ç  {\em (Caesar cypher)} æ˜¯ä¸€ç§å¼±åŠ å¯†æ–¹å¼ï¼Œ å®ƒå°†æ¯ä¸€ä¸ªå­—æ¯åç§»å›ºå®šçš„ä½ç½®ã€‚  åç§»ä¸€ä¸ªå­—æ¯ï¼Œ æŒ‡çš„æ˜¯æŒ‰ç€å­—æ¯è¡¨åç§»ï¼Œ å¦‚æœéœ€è¦çš„è¯å†ä»å°¾éƒ¨è·³è½¬è‡³é¦–å­—æ¯ï¼Œ æ‰€ä»¥ {\em `A'} åç§»ä¸‰ä¸ªä½ç½®å³ä¸º {\em `D'}ï¼Œ {\em `Z'} åç§»ä¸€ä¸ªä½ç½®æ˜¯ {\em `A'}ã€‚
% chn transplation need imporve

%ğŸ% To rotate a word, rotate each letter by the same amount.
%ğŸ% For example, ``cheer'' rotated by 7 is ``jolly'' and ``melon'' rotated
%ğŸ% by -10 is ``cubed''.  In the movie {\em 2001: A Space Odyssey}, the
%ğŸ% ship computer is called HAL, which is IBM rotated by -1.

è¦åç§»ä¸€ä¸ªå•è¯ï¼Œ å¯ä»¥å°†å…¶ä¸­æ¯ä¸€ä¸ªå­—æ¯åç§»ç›¸åŒçš„é‡ã€‚  ä¾‹å¦‚ï¼Œ {\em ``cheer''} åç§» {\em 7} ä¸ªä½ç½®åå˜æˆäº† {\em ``jolly''}ï¼Œ {\em ``melon''} åç§» {\em -10} ä¸ªä½ç½®å˜æˆäº† {\em ``cubed''}ã€‚  åœ¨ç”µå½± {\em ã€Š2001ï¼š}å¤ªç©ºå¥¥å¾·èµ›{\em (2001: A Space Odyssey)ã€‹} ä¸­ï¼Œ é£èˆ¹ä¸Šçš„ç”µè„‘å«åš {\em HAL}ï¼Œ ä¹Ÿå°±æ˜¯ {\em IBM} åç§» {\em 1} ä¸ªä½ç½®åçš„å•è¯ã€‚

%For example ``sleep''
%rotated by 9 is ``bunny'' and ``latex'' rotated by 7 is ``shale''.

%ğŸ% Write a function called \verb"rotate_word"
%ğŸ% that takes a string and an integer as parameters, and returns
%ğŸ% a new string that contains the letters from the original string
%ğŸ% rotated by the given amount.

ç¼–å†™ä¸€ä¸ªå« {\em \li{rotate_word}} çš„å‡½æ•°ï¼Œ æ¥å—ä¸€ä¸ªå­—ç¬¦ä¸²å’Œä¸€ä¸ªæ•´æ•°ä½œä¸ºå½¢å‚ï¼Œ å¹¶è¿”å›åŸå­—ç¬¦ä¸²æŒ‰ç…§ç»™å®šæ•´æ•°é‡åç§»åå¾—åˆ°çš„ä¸€ä¸ªæ–°å­—ç¬¦ä¸²ã€‚

%ğŸ% You might want to use the built-in function {\tt ord}, which converts
%ğŸ% a character to a numeric code, and {\tt chr}, which converts numeric
%ğŸ% codes to characters.  Letters of the alphabet are encoded in alphabetical
%ğŸ% order, so for example:

ä½ å¯èƒ½æƒ³ç”¨å†…ç½®å‡½æ•° {\em \li{ord}} ï¼Œ å®ƒå¯ä»¥å°†å­—ç¬¦è½¬åŒ–æˆæ•°å€¼ä»£ç ï¼Œ è¿˜æœ‰ {\em \li{chr}}ï¼Œ å®ƒå¯ä»¥å°†æ•°å€¼ä»£ç è½¬åŒ–æˆå­—ç¬¦. å­—æ¯è¡¨çš„å­—æ¯ä»¥å­—æ¯è¡¨é¡ºåºç¼–ç ï¼Œ ä¾‹å¦‚ï¼š

\begin{em}
\begin{lstlisting}
>>> ord('c') - ord('a')
2
\end{lstlisting}
\end{em}

%ğŸ% Because \verb"'c'" is the two-eth letter of the alphabet.  But
%ğŸ% beware: the numeric codes for upper case letters are different.

å› ä¸º {\em \li{'c'}} æ˜¯å­—æ¯è¡¨ä¸­çš„ç¬¬äºŒä¸ªå­—æ¯ã€‚  ä½†æ˜¯è¯·æ³¨æ„ï¼šå¤§å†™å­—æ¯çš„æ•°å€¼ä»£ç æ˜¯ä¸åŒçš„ã€‚

%ğŸ% Potentially offensive jokes on the Internet are sometimes encoded in
%ğŸ% ROT13, which is a Caesar cypher with rotation 13.  If you are not
%ğŸ% easily offended, find and decode some of them.  Solution:
%ğŸ% \url{http://thinkpython2.com/code/rotate.py}.

ç½‘ä¸Šä¸€äº›å¯èƒ½å†’çŠ¯äººçš„ç¬‘è¯æœ‰æ—¶ä»¥ {\em ROT13} ç¼–ç ï¼Œ å³ä»¥ {\em 13} ä¸ºåç§»é‡çš„å‡¯æ’’
å¯†ç ã€‚  å¦‚æœä½ ä¸æ˜¯å¾ˆå®¹æ˜“å°±è¢«å†’çŠ¯ï¼Œ é‚£ä¹ˆå¯ä»¥æ‰¾äº›è¿™æ ·çš„ç¬‘è¯ï¼Œ å¹¶è§£ç ã€‚

\href{http://thinkpython2.com/code/rotate.py}{å‚è€ƒç­”æ¡ˆ}

\end{exercise}