

%ğŸ% \chapter{Tuples | å…ƒç»„}
\chapter{å…ƒç»„}
\label{tuplechap}

%ğŸ% This chapter presents one more built-in type, the tuple, and then
%ğŸ% shows how lists, dictionaries, and tuples work together.
%ğŸ% I also present a useful feature for variable-length argument lists,
%ğŸ% the gather and scatter operators.
%ğŸ%
%ğŸ% One note: there is no consensus on how to pronounce ``tuple''.
%ğŸ% Some people say ``tuh-ple'', which rhymes with ``supple''.  But
%ğŸ% in the context of programming, most people say ``too-ple'', which
%ğŸ% rhymes with ``quadruple''.

æœ¬ç« ä»‹ç»å¦ä¸€ä¸ªå†…å»ºçš„ç±»å‹ --- å…ƒç»„\footnote{å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œ ``tuple''å¹¶æ²¡æœ‰ç»Ÿä¸€çš„å‘éŸ³ï¼Œ æœ‰äº›äººè¯»``tuh-ple''ï¼Œ éŸ³å¾‹ç±»ä¼¼äº``supple''ï¼›è€Œæœ‰äººè¯»``too-ple''éŸ³å¾‹ç±»ä¼¼äº``quadruple''ã€‚  }ï¼Œ åŒæ—¶è¯´æ˜å¦‚ä½•ç»“åˆä½¿ç”¨åˆ—è¡¨ã€å­—å…¸å’Œå…ƒç»„ã€‚
åé¢çš„ç« èŠ‚ä¼šä»‹ç»å…³äº å¯å˜é•¿åº¦å‚æ•°åˆ—è¡¨ çš„æœ‰ç”¨åŠŸèƒ½ï¼Œ ä»¥åŠ\emph{æ±‡é›†} å’Œ \emph{åˆ†æ•£}æ“ä½œã€‚

%ğŸ% \section{Tuples are immutable | å…ƒç»„æ˜¯ä¸å¯å˜çš„}
\section{å…ƒç»„æ˜¯ä¸å¯å˜çš„}
\index{tuple}  \index{type!tuple}  \index{sequence}

%ğŸ% A tuple is a sequence of values.  The values can be any type, and
%ğŸ% they are indexed by integers, so in that respect tuples are a lot
%ğŸ% like lists.  The important difference is that tuples are immutable.
\index{mutability}  \index{immutability}

å…ƒç»„æ˜¯ä¸€ç»„\emph{å€¼}çš„åºåˆ—ã€‚
å…¶ä¸­çš„å€¼å¯ä»¥æ˜¯ä»»æ„ç±»å‹ï¼Œ ä½¿ç”¨æ•´æ•°ç´¢å¼•å…¶ä½ç½®ï¼Œ å› æ­¤å…ƒç»„ä¸åˆ—è¡¨éå¸¸ç›¸ä¼¼ã€‚
è€Œé‡è¦çš„ä¸åŒä¹‹å¤„åœ¨äºå…ƒç»„çš„ä¸å¯å˜æ€§ã€‚

%ğŸ% Syntactically, a tuple is a comma-separated list of values:

è¯­æ³•ä¸Š,å…ƒç»„æ˜¯ç”¨é€—å·éš”å¼€ä¸€ç³»åˆ—å€¼çš„åˆ—è¡¨ï¼š

\begin{lstlisting}
>>> t = 'a', 'b', 'c', 'd', 'e'
\end{lstlisting}
%
%ğŸ% Although it is not necessary, it is common to enclose tuples in
%ğŸ% parentheses:

è™½ç„¶å¹¶éå¿…é¡»ï¼Œ å…ƒç»„é€šå¸¸ç”¨æ‹¬å·æ‹¬èµ·æ¥ï¼š

\index{parentheses!tuples in}

\begin{lstlisting}
>>> t = ('a', 'b', 'c', 'd', 'e')
\end{lstlisting}
%
%ğŸ% To create a tuple with a single element, you have to include a final
%ğŸ% comma:

ä½¿ç”¨å•ä¸€å…ƒç´ å»ºç«‹å…ƒç»„æ—¶ï¼Œ éœ€è¦åœ¨ç»“å°¾ä½¿ç”¨ä¸€ä¸ªé€—å·ï¼š

\index{singleton}
\index{tuple!singleton}

\begin{lstlisting}
>>> t1 = 'a',
>>> type(t1)
<class 'tuple'>
\end{lstlisting}
%
%ğŸ% A value in parentheses is not a tuple:

å°†å€¼æ”¾ç½®åœ¨æ‹¬å·ä¸­å¹¶ä¸ä¼šåˆ›å»ºå…ƒç»„ï¼š

\begin{lstlisting}
>>> t2 = ('a')
>>> type(t2)
<class 'str'>
\end{lstlisting}
%
%ğŸ% Another way to create a tuple is the built-in function {\tt tuple}.
%ğŸ% With no argument, it creates an empty tuple:
\index{tuple function}
\index{function!tuple}

å¦ä¸€ä¸ªå»ºç«‹å…ƒç»„çš„æ–¹æ³•æ˜¯ä½¿ç”¨å†…å»ºå‡½æ•° \li{tuple}ã€‚
åœ¨æ²¡æœ‰å‚æ•°ä¼ é€’æ—¶å®ƒä¼šäº§ç”Ÿä¸€ä¸ªç©ºå…ƒç»„ã€‚

\begin{lstlisting}
>>> t = tuple()
>>> t
()
\end{lstlisting}

%
%ğŸ% If the argument is a sequence (string, list or tuple), the result
%ğŸ% is a tuple with the elements of the sequence:

å¦‚æœå®å‚æ˜¯ä¸€ä¸ªåºåˆ—(å­—ç¬¦ä¸²ã€åˆ—è¡¨æˆ–è€…å…ƒç»„)ï¼Œ ç»“æœå°†æ˜¯åŒ…å«åºåˆ—å†…å…ƒç´ çš„ä¸€ä¸ªå…ƒç»„ã€‚

\begin{lstlisting}
>>> t = tuple('lupins')
>>> t
('l', 'u', 'p', 'i', 'n', 's')
\end{lstlisting}
%
%ğŸ% Because {\tt tuple} is the name of a built-in function, you should
%ğŸ% avoid using it as a variable name.

å› ä¸º \li{tuple} æ˜¯å†…å»ºå‡½æ•°åï¼Œ æ‰€ä»¥åº”è¯¥é¿å…å°†å®ƒç”¨äºå˜é‡åã€‚


%ğŸ% Most list operators also work on tuples.  The bracket operator
%ğŸ% indexes an element:

åˆ—è¡¨çš„å¤§å¤šæ•°æ“ä½œåŒæ ·ä¹Ÿé€‚ç”¨äºå…ƒç»„ã€‚  æ–¹æ‹¬å·è¿ç®—ç¬¦å°†ç´¢å¼•ä¸€ä¸ªå…ƒç´ ï¼š

\index{bracket operator}
\index{operator!bracket}

\begin{lstlisting}
>>> t = ('a', 'b', 'c', 'd', 'e')
>>> t[0]
'a'
\end{lstlisting}
%
%ğŸ% And the slice operator selects a range of elements.

åˆ‡ç‰‡æ“ä½œå¯ä»¥é€‰å–ä¸€ä¸ªèŒƒå›´å†…çš„å…ƒç´ :
\index{slice operator}  \index{operator!slice}
\index{tuple!slice}  \index{slice!tuple}
\index{åˆ‡ç‰‡æ“ä½œç¬¦}  \index{æ“ä½œç¬¦!åˆ‡ç‰‡}
\index{å…ƒç»„!åˆ‡ç‰‡}  \index{åˆ‡ç‰‡!å…ƒç»„}

\begin{lstlisting}
>>> t[1:3]
('b', 'c')
\end{lstlisting}
%
%ğŸ% But if you try to modify one of the elements of the tuple, you get
%ğŸ% an error:

ä½†æ˜¯ï¼Œ å¦‚æœä½ è¯•æ›´æ”¹å›¾å…ƒç»„ä¸­çš„ä¸€ä¸ªå…ƒç´ ï¼Œ ä¼šå¾—åˆ°é”™è¯¯ä¿¡æ¯ï¼š

\index{exception!TypeError}  \index{TypeError}
\index{item assignment}  \index{assignment!item}

\begin{lstlisting}
>>> t[0] = 'A'
TypeError: object doesn't support item assignment
\end{lstlisting}

%
%ğŸ% Because tuples are immutable, you can't modify the elements.  But you
%ğŸ% can replace one tuple with another:

å› ä¸ºå…ƒç»„æ˜¯ä¸å¯å˜çš„ï¼Œ æ‚¨æ— æ³•æ”¹å˜å…¶ä¸­çš„å…ƒç´ ã€‚
ä½†æ˜¯å¯ä»¥ä½¿ç”¨å…¶ä»–å…ƒç»„æ›¿æ¢ç°æœ‰å…ƒç»„ï¼š

\begin{lstlisting}
>>> t = ('A',) + t[1:]
>>> t
('A', 'b', 'c', 'd', 'e')
\end{lstlisting}
%
%ğŸ% This statement makes a new tuple and then makes {\tt t} refer to it.

è¿™ä¸ªè¯­å¥åˆ›å»ºäº†ä¸€ä¸ªæ–°å…ƒç»„ï¼Œ ç„¶åè®© \li{t} å¼•ç”¨è¯¥å…ƒç»„ã€‚

%ğŸ% The relational operators work with tuples and other sequences;
%ğŸ% Python starts by comparing the first element from each
%ğŸ% sequence.  If they are equal, it goes on to the next elements,
%ğŸ% and so on, until it finds elements that differ.  Subsequent
%ğŸ% elements are not considered (even if they are really big).

å…³ç³»å‹æ“ä½œä¹Ÿé€‚ç”¨äºå…ƒç»„å’Œå…¶ä»–åºåˆ—ï¼›
Python ä¼šé¦–å…ˆæ¯”è¾ƒåºåˆ—ä¸­çš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œ å¦‚æœå®ƒä»¬ç›¸ç­‰ï¼Œ å°±ç»§ç»­æ¯”è¾ƒä¸‹ä¸€ç»„å…ƒç´ ï¼Œ
ä»¥æ­¤ç±»æ¨ï¼Œ ç›´è‡³æ¯”å€¼ä¸åŒã€‚
å…¶åçš„å…ƒç´ (å³ä¾¿æ˜¯å·®å¼‚å¾ˆå¤§)ä¹Ÿä¸ä¼šå†å‚ä¸æ¯”è¾ƒã€‚

\index{comparison!tuple}
\index{tuple!comparison}

\begin{lstlisting}
>>> (0, 1, 2) < (0, 3, 4)
True
>>> (0, 1, 2000000) < (0, 3, 4)
True
\end{lstlisting}


%ğŸ% \section{Tuple assignment | å…ƒç»„èµ‹å€¼}
\section{å…ƒç»„èµ‹å€¼}
\label{tuple.assignment} \index{tuple!assignment} \index{assignment!tuple}
\index{swap pattern} \index{pattern!swap}

%ğŸ% It is often useful to swap the values of two variables.
%ğŸ% With conventional assignments, you have to use a temporary
%ğŸ% variable.  For example, to swap {\tt a} and {\tt b}:

ä¸¤ä¸ªå˜é‡äº’æ¢å€¼çš„æ“ä½œé€šå¸¸å¾ˆæœ‰ç”¨ã€‚
æŒ‰ç…§ä¼ ç»Ÿçš„èµ‹å€¼æ–¹æ³•ï¼Œ ä½ éœ€è¦ä½¿ç”¨ä¸€ä¸ªä¸´æ—¶å˜é‡ã€‚
ä¾‹å¦‚ä¸ºäº†äº¤æ¢ \li{a}å’Œ \li{b} çš„å€¼ï¼š

\begin{lstlisting}
>>> temp = a
>>> a = b
>>> b = temp
\end{lstlisting}
%
%ğŸ% This solution is cumbersome; {\bf tuple assignment} is more elegant:

è¿™ä¸ªæ–¹æ³•å¾ˆç¹çï¼›é€šè¿‡{\bf å…ƒç»„èµ‹å€¼}æ¥å®ç°æ›´ä¸ºä¼˜é›…:

\begin{lstlisting}
>>> a, b = b, a
\end{lstlisting}
%
%ğŸ% The left side is a tuple of variables; the right side is a tuple of
%ğŸ% expressions.  Each value is assigned to its respective variable.
%ğŸ% All the expressions on the right side are evaluated before any
%ğŸ% of the assignments.

ç­‰å·å·¦ä¾§æ˜¯å˜é‡ç»„æˆçš„å…ƒç»„ï¼›å³ä¾§æ˜¯è¡¨è¾¾å¼ç»„æˆçš„å…ƒç»„ã€‚
æ¯ä¸ªå€¼éƒ½è¢«èµ‹ç»™äº†å¯¹åº”çš„å˜é‡ã€‚
å˜é‡è¢«é‡æ–°èµ‹å€¼å‰ï¼Œ å°†å…ˆå¯¹å³ä¾§çš„è¡¨è¾¾å¼è¿›è¡Œæ±‚å€¼ã€‚

%ğŸ% The number of variables on the left and the number of
%ğŸ% values on the right have to be the same:

ä½¿ç”¨å…ƒç»„èµ‹å€¼ï¼Œ å·¦å³ä¸¤ä¾§å˜é‡æ•°å¿…é¡»ç›¸åŒï¼š

\index{exception!ValueError}  \index{ValueError}

\begin{lstlisting}
>>> a, b = 1, 2, 3
ValueError: too many values to unpack
\end{lstlisting}
%
%ğŸ% More generally, the right side can be any kind of sequence
%ğŸ% (string, list or tuple).  For example, to split an email address
%ğŸ% into a user name and a domain, you could write:

ä¸€èˆ¬è¯´æ¥ï¼Œ å…ƒç»„èµ‹å€¼æ—¶å³ä¾§è¡¨è¾¾å¼å¯ä»¥æ˜¯ä»»æ„ç±»å‹(å­—ç¬¦ä¸²ã€åˆ—è¡¨æˆ–è€…å…ƒç»„)çš„åºåˆ—ã€‚  ä¾‹å¦‚ï¼Œ å°†ä¸€ä¸ªç”µå­é‚®ç®±åœ°å€åˆ†æˆç”¨æˆ·åå’ŒåŸŸåï¼Œ ä½ å¯ä»¥ï¼š

\index{split method}  \index{method!split}
\index{email address}

\begin{lstlisting}
>>> addr = 'monty@python.org'
>>> uname, domain = addr.split('@')
\end{lstlisting}

%
%ğŸ% The return value from {\tt split} is a list with two elements;
%ğŸ% the first element is assigned to {\tt uname}, the second to
%ğŸ% {\tt domain}.

 \li{split}å‡½æ•°è¿”å›çš„å¯¹è±¡æ˜¯ä¸€ä¸ªåŒ…å«ä¸¤ä¸ªå…ƒç´ çš„åˆ—è¡¨ï¼›ç¬¬ä¸€ä¸ªå…ƒç´ è¢«èµ‹ç»™äº† \li{uname}çš„å˜é‡ï¼Œ ç¬¬äºŒä¸ªè¢«èµ‹ç»™äº† \li{domain}ã€‚

\begin{lstlisting}
>>> uname
'monty'
>>> domain
'python.org'
\end{lstlisting}
%

%ğŸ% \section{Tuples as return values | å…ƒç»„ä½œä¸ºè¿”å›å€¼}
\section{å…ƒç»„ä½œä¸ºè¿”å›å€¼}
\index{tuple} \index{value!tuple} \index{return value!tuple}
\index{function, tuple as return value}

%ğŸ% Strictly speaking, a function can only return one value, but
%ğŸ% if the value is a tuple, the effect is the same as returning
%ğŸ% multiple values.  For example, if you want to divide two integers
%ğŸ% and compute the quotient and remainder, it is inefficient to
%ğŸ% compute {\tt x/y} and then {\tt x\%y}.  It is better to compute
%ğŸ% them both at the same time.

ä¸¥æ ¼åœ°è¯´ï¼Œ ä¸€ä¸ªå‡½æ•°åªèƒ½è¿”å›ä¸€ä¸ªå€¼ï¼Œ ä½†æ˜¯å¦‚æœè¿™ä¸ªè¿”å›å€¼æ˜¯å…ƒç»„ï¼Œ å…¶æ•ˆæœç­‰åŒäºè¿”å›å¤šä¸ªå€¼ã€‚  ä¾‹å¦‚ï¼Œ ä½ æƒ³å¯¹ä¸¤ä¸ªæ•´æ•°åšé™¤æ³•ï¼Œ è®¡ç®—å‡ºå•†å’Œä½™æ•°ï¼Œ ä¾æ¬¡è®¡ç®—å‡º \li{x/y}å’Œ \li{x%y}æ˜¯å¾ˆä½æ•ˆçš„ã€‚
åŒæ—¶è®¡ç®—å‡ºè¿™ä¸¤ä¸ªå€¼æ›´å¥½ã€‚
\index{divmod}

%ğŸ% The built-in function {\tt divmod} takes two arguments and
%ğŸ% returns a tuple of two values, the quotient and remainder.
%ğŸ% You can store the result as a tuple:

å†…å»ºå‡½æ•°\href{https://docs.python.org/3/library/functions.html#divmod}{ \li{divmod}}æ¥å—ä¸¤ä¸ªå‚æ•°ï¼Œ è¿”å›åŒ…å«ä¸¤ä¸ªå€¼çš„å…ƒç»„ --- å•†å’Œä½™æ•°ã€‚
å¯ä»¥ä½¿ç”¨å…ƒç»„æ¥å­˜å‚¨è¿”å›å€¼:

\begin{lstlisting}
>>> t = divmod(7, 3)
>>> t
(2, 1)
\end{lstlisting}

%
%ğŸ% Or use tuple assignment to store the elements separately:

æˆ–è€…ä½¿ç”¨å…ƒç»„èµ‹å€¼åˆ†åˆ«å­˜å‚¨å®ƒä»¬ï¼š

\index{tuple assignment}  \index{assignment!tuple}

\begin{lstlisting}
>>> quot, rem = divmod(7, 3)
>>> quot
2
>>> rem
1
\end{lstlisting}

%
%ğŸ% Here is an example of a function that returns a tuple:

ä¸‹é¢æ˜¯å¦ä¸€ä¸ªè¿”å›å…ƒç»„ä½œä¸ºç»“æœçš„å‡½æ•°ä¾‹å­ï¼š

\begin{lstlisting}
def min_max(t):
    return min(t), max(t)
\end{lstlisting}

%
%ğŸ% {\tt max} and {\tt min} are built-in functions that find
%ğŸ% the largest and smallest elements of a sequence.  \verb"min_max"
%ğŸ% computes both and returns a tuple of two values.

 \li{max} å’Œ  \li{min} æ˜¯ç”¨äºæ‰¾å‡ºä¸€ç»„å…ƒç´ åºåˆ—ä¸­æœ€å¤§å€¼å’Œæœ€å°å€¼çš„å†…å»ºå‡½æ•°ï¼Œ \li{min_max}å‡½æ•°åŒæ—¶è®¡ç®—å‡ºè¿™ä¸¤ä¸ªå€¼ï¼Œ å¹¶è¿”å›äºŒè€…ç»„æˆçš„å…ƒç»„ã€‚
\index{max function} \index{function!max}
\index{min function} \index{function!min}


%ğŸ% \section{Variable-length argument tuples | å¯å˜é•¿åº¦å‚æ•°å…ƒç»„}
\section{å¯å˜é•¿åº¦å‚æ•°å…ƒç»„}
\label{gather}
\index{variable-length argument tuple} \index{argument!variable-length tuple}
\index{gather} \index{parameter!gather} \index{argument!gather}

%ğŸ% Functions can take a variable number of arguments.  A parameter
%ğŸ% name that begins with {\tt *} {\bf gathers} arguments into
%ğŸ% a tuple.  For example, {\tt printall}
%ğŸ% takes any number of arguments and prints them:

å‡½æ•°å¯ä»¥æ¥å—å¯å˜æ•°é‡çš„å‚æ•°ã€‚  ä»¥ {\bf *} å¼€å¤´çš„å½¢å‚å°†è¾“å…¥çš„å‚æ•° \emph{æ±‡é›†} åˆ°ä¸€ä¸ªå…ƒç»„ä¸­ã€‚
ä¾‹å¦‚ï¼Œ \li{printall} å¯ä»¥æ¥å—ä»»æ„æ•°é‡çš„å‚æ•°ï¼Œ å¹¶å°†å®ƒä»¬æ‰“å°å‡ºæ¥ï¼š

\begin{lstlisting}
def printall(*args):
    print(args)
\end{lstlisting}

%
%ğŸ% The gather parameter can have any name you like, but {\tt args} is
%ğŸ% conventional.  Here's how the function works:

æ±‡é›†çš„å½¢å‚å¯ä»¥ä½¿ç”¨ä»»æ„åå­—ï¼Œ ä½†æ˜¯ä¹ æƒ¯ä½¿ç”¨ \li{args}ã€‚
ä»¥ä¸‹æ˜¯è¿™ä¸ªå‡½æ•°çš„è°ƒç”¨æ•ˆæœï¼š

\begin{lstlisting}
>>> printall(1, 2.0, '3')
(1, 2.0, '3')
\end{lstlisting}

%
%ğŸ% The complement of gather is {\bf scatter}.  If you have a
%ğŸ% sequence of values and you want to pass it to a function
%ğŸ% as multiple arguments, you can use the {\tt *} operator.
%ğŸ% For example, {\tt divmod} takes exactly two arguments; it
%ğŸ% doesn't work with a tuple:

ä¸æ±‡é›†ç›¸å¯¹çš„æ˜¯\emph{åˆ†æ•£}{\bf scatter}ã€‚
å¦‚æœä½ æœ‰ä¸€ä¸ªå€¼çš„åºåˆ—ï¼Œ å¹¶ä¸”å¸Œæœ›å°†å…¶ä½œä¸ºå¤šä¸ªå‚æ•°ä¼ é€’ç»™ä¸€ä¸ªå‡½æ•°ï¼Œ
ä½ å¯ä»¥ä½¿ç”¨è¿ç®—ç¬¦ \li{*}ã€‚
ä¾‹å¦‚ï¼Œ \li{divmod} éœ€è¦æ¥å—ä¸¤ä¸ªå®å‚ï¼›ä¸€ä¸ªå…ƒç»„åˆ™æ— æ³•ä½œä¸ºå‚æ•°ä¼ é€’è¿›å»ï¼š

\index{scatter} \index{argument scatter} \index{TypeError}
\index{exception!TypeError}

\begin{lstlisting}
>>> t = (7, 3)
>>> divmod(t)
TypeError: divmod expected 2 arguments, got 1
\end{lstlisting}

%
%ğŸ% But if you scatter the tuple, it works:

ä½†æ˜¯å¦‚æœå°†è¿™ä¸ªå…ƒç»„åˆ†æ•£ï¼Œ å®ƒå°±å¯ä»¥è¢«ä¼ é€’è¿›å‡½æ•°ï¼š

\begin{lstlisting}
>>> divmod(*t)
(2, 1)
\end{lstlisting}

%
%ğŸ% Many of the built-in functions use
%ğŸ% variable-length argument tuples.  For example, {\tt max}
%ğŸ% and {\tt min} can take any number of arguments:

å¤šæ•°å†…å»ºå‡½æ•°ä½¿ç”¨å¯å˜é•¿åº¦å‚æ•°å…ƒç»„ã€‚
ä¾‹å¦‚ï¼Œ \li{max} å’Œ  \li{min} å¯ä»¥æ¥å—ä»»æ„æ•°é‡çš„å®å‚ã€‚

\index{max function} \index{function!max}
\index{min function} \index{function!min}

\begin{lstlisting}
>>> max(1, 2, 3)
3
\end{lstlisting}

%
%ğŸ% But {\tt sum} does not.

ä½†æ˜¯æ±‚å’Œæ“ä½œ \li{sum} ä¸è¡Œï¼š
\index{sum function} \index{function!sum}

\begin{lstlisting}
>>> sum(1, 2, 3)
TypeError: sum expected at most 2 arguments, got 3
\end{lstlisting}

%
%ğŸ% As an exercise, write a function called {\tt sumall} that takes any number
%ğŸ% of arguments and returns their sum.

æˆ‘ä»¬å°è¯•ç¼–å†™ä¸€ä¸ªå«åš  \li{sumall}çš„å‡½æ•°ä½œä¸ºç»ƒä¹ ï¼Œ
ä½¿å®ƒèƒ½å¤Ÿæ¥å—ä»»ä½•æ•°é‡çš„ä¼ å‚å¹¶è¿”å›å®ƒä»¬çš„å’Œã€‚


%ğŸ% \section{Lists and tuples | åˆ—è¡¨å’Œå…ƒç»„}
\section{åˆ—è¡¨å’Œå…ƒç»„}
\index{zip function} \index{function!zip}

%ğŸ% {\tt zip} is a built-in function that takes two or more sequences and
%ğŸ% returns a list of tuples where each tuple contains one
%ğŸ% element from each sequence.  The name of the function refers to
%ğŸ% a zipper, which joins and interleaves two rows of teeth.

 \li{zip} æ˜¯ä¸€ä¸ªå†…å»ºå‡½æ•°ï¼Œ å¯ä»¥æ¥å—å°†ä¸¤ä¸ªæˆ–å¤šä¸ªåºåˆ—ç»„ï¼Œ å¹¶è¿”å›ä¸€ä¸ªå…ƒç»„åˆ—è¡¨ï¼Œ
å…¶ä¸­æ¯ä¸ªå…ƒç»„åŒ…å«äº†å„ä¸ªåºåˆ—ä¸­ç›¸å¯¹ä½ç½®çš„ä¸€ä¸ªå…ƒç´ ã€‚
è¿™ä¸ªå‡½æ•°çš„åç§°æ¥è‡ªåè¯æ‹‰é“¾ (zipper)ï¼Œ åè€…å°†ä¸¤ç‰‡é“¾é½¿è¿æ¥æ‹¼åˆåœ¨ä¸€èµ·ã€‚


%ğŸ% This example zips a string and a list:

ä¸‹é¢çš„ç¤ºä¾‹å¯¹ä¸€ä¸ªå­—ç¬¦ä¸²å’Œåˆ—è¡¨ä½¿ç”¨ \li{zip} å‡½æ•°ï¼š

\begin{lstlisting}
>>> s = 'abc'
>>> t = [0, 1, 2]
>>> zip(s, t)
<zip object at 0x7f7d0a9e7c48>
\end{lstlisting}

%
%ğŸ% The result is a {\bf zip object} that knows how to iterate through
%ğŸ% the pairs.  The most common use of {\tt zip} is in a {\tt for} loop:

è¾“å‡ºçš„ç»“æœæ˜¯ä¸€ä¸ª {\em \li{zip} å¯¹è±¡}ï¼Œ åŒ…å«äº†å¦‚ä½•å¯¹å…¶ä¸­å…ƒç´ è¿›è¡Œè¿­ä»£çš„ä¿¡æ¯ã€‚
\li{zip} å‡½æ•°æœ€å¸¸ç”¨äº \li{for} å¾ªç¯ï¼š

\begin{lstlisting}
>>> for pair in zip(s, t):
...     print(pair)
...
('a', 0)
('b', 1)
('c', 2)
\end{lstlisting}

%
%ğŸ% A zip object is a kind of {\bf iterator}, which is any object
%ğŸ% that iterates through a sequence.  Iterators are similar to lists in some
%ğŸ% ways, but unlike lists, you can't use an index to select an element from
%ğŸ% an iterator.

\href{https://docs.python.org/3/library/functions.html#zip}{\li{zip}}å¯¹è±¡æ˜¯ä¸€ä¸ªå‹å–„çš„ {\bf è¿­ä»£å™¨}ï¼Œ æ˜¯æŒ‡ä»»ä½•ä¸€ç§èƒ½å¤ŸæŒ‰ç…§æŸä¸ªåºåˆ—è¿­ä»£çš„å¯¹è±¡ã€‚  è¿­ä»£å™¨åœ¨æŸäº›æ–¹é¢ä¸åˆ—è¡¨éå¸¸ç›¸ä¼¼ï¼Œ ä¸åŒä¹‹å¤„åœ¨äºï¼Œ ä½ æ— æ³•é€šè¿‡ç´¢å¼•æ¥é€‰æ‹©è¿­ä»£å™¨ä¸­çš„æŸä¸ªå…ƒç´ ã€‚
\index{iterator} \index{è¿­ä»£å™¨}

%ğŸ% If you want to use list operators and methods, you can
%ğŸ% use a zip object to make a list:

å¦‚æœä½ æƒ³ä½¿ç”¨åˆ—è¡¨æ“ä½œç¬¦å’Œæ–¹æ³•ï¼Œ ä½ å¯ä»¥é€šè¿‡ \li {zip}å¯¹è±¡åˆ›é€ ä¸€ä¸ªåˆ—è¡¨ï¼š

\begin{lstlisting}
>>> list(zip(s, t))
[('a', 0), ('b', 1), ('c', 2)]
\end{lstlisting}

%
%ğŸ% The result is a list of tuples; in this example, each tuple contains
%ğŸ% a character from the string and the corresponding element from
%ğŸ% the list.

ç»“æœå°±æ˜¯ä¸€ä¸ªåŒ…å«è‹¥å¹²å…ƒç»„çš„åˆ—è¡¨ï¼›åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œ æ¯ä¸ªå…ƒç»„åˆåŒ…å«äº†å­—ç¬¦ä¸²ä¸­çš„ä¸€ä¸ªå­—ç¬¦å’Œåˆ—è¡¨ \li {t} ä¸­å¯¹åº”çš„ä¸€ä¸ªå…ƒç´ ã€‚
\index{list!of tuples}

%ğŸ% If the sequences are not the same length, the result has the
%ğŸ% length of the shorter one.

å¦‚æœç”¨äºåˆ›å»ºçš„åºåˆ—é•¿åº¦ä¸ä¸€ï¼Œ è¿”å›çš„å¯¹è±¡çš„é•¿åº¦ä»¥æœ€çŸ­åºåˆ—çš„é•¿åº¦ä¸ºå‡†ã€‚

\begin{lstlisting}
>>> list(zip('Anne', 'Elk'))
[('A', 'E'), ('n', 'l'), ('n', 'k')]
\end{lstlisting}

%
%ğŸ% You can use tuple assignment in a {\tt for} loop to traverse a list of
%ğŸ% tuples:

ä½ å¯ä»¥åœ¨ \li{for} å¾ªç¯ä¸­ä½¿ç”¨å…ƒç»„èµ‹å€¼ï¼Œ éå†åŒ…å«å…ƒç»„çš„åˆ—è¡¨ï¼š

\index{traversal} \index{tuple assignment} \index{assignment!tuple}

\begin{lstlisting}
t = [('a', 0), ('b', 1), ('c', 2)]
for letter, number in t:
    print(number, letter)
\end{lstlisting}

%
%ğŸ% Each time through the loop, Python selects the next tuple in
%ğŸ% the list and assigns the elements to {\tt letter} and
%ğŸ% {\tt number}.  The output of this loop is:

å¾ªç¯ä¸­çš„æ¯æ¬¡æ‰§è¡Œï¼Œ Python ä¼šé€‰æ‹©åˆ—è¡¨ä¸­çš„ä¸‹ä¸€ä¸ªå…ƒç»„ï¼Œ
å¹¶å°†å…¶å†…å®¹èµ‹ç»™  \li{letter} å’Œ  \li{number}ã€‚
å› æ­¤å¾ªç¯æ‰“å°çš„è¾“å‡ºä¼šæ˜¯è¿™æ ·ï¼š
\index{loop}

\begin{lstlisting}
0 a
1 b
2 c
\end{lstlisting}

%
%ğŸ% If you combine {\tt zip}, {\tt for} and tuple assignment, you get a
%ğŸ% useful idiom for traversing two (or more) sequences at the same
%ğŸ% time.  For example, \verb"has_match" takes two sequences, {\tt t1} and
%ğŸ% {\tt t2}, and returns {\tt True} if there is an index {\tt i}
%ğŸ% such that {\tt t1[i] == t2[i]}:

å¦‚æœå°† \li{zip}ã€ \li{for}å¾ªç¯å’Œå…ƒç»„èµ‹å€¼ç»“åˆèµ·æ¥ä½¿ç”¨ï¼Œ
ä½ ä¼šå¾—åˆ°ä¸€ä¸ªå¯ä»¥åŒæ—¶éå†ä¸¤ä¸ª(ç”šè‡³å¤šä¸ª)åºåˆ—çš„æƒ¯ç”¨æ³•ã€‚
ä¾‹å¦‚ï¼Œ \li{has_match} æ¥å—ä¸¤ä¸ªåºåˆ—ï¼Œ \li{t1} å’Œ \li{t2}ï¼Œ
å¦‚æœå­˜åœ¨ç´¢å¼•æ»¡è¶³ \li{t1[i] == t2[i]} \li {i}ï¼Œ åˆ™è¿”å› \li{True}ï¼š
\index{for loop}

\begin{lstlisting}
def has_match(t1, t2):
    for x, y in zip(t1, t2):
        if x == y:
            return True
    return False
\end{lstlisting}

%
%ğŸ% If you need to traverse the elements of a sequence and their
%ğŸ% indices, you can use the built-in function {\tt enumerate}:

å¦‚æœéœ€è¦éå†ä¸€ä¸ªåºåˆ—çš„å…ƒç´ ä»¥åŠå®ƒä»¬çš„ç´¢å¼•å·ï¼Œ ä½ å¯ä»¥ä½¿ç”¨å†…å»ºå‡½æ•° \li{enumerate}ï¼š
\index{traversal} \index{enumerate function} \index{function!enumerate}

\begin{lstlisting}
for index, element in enumerate('abc'):
    print(index, element)
\end{lstlisting}

%
%ğŸ% The result from {\tt enumerate} is an enumerate object, which
%ğŸ% iterates a sequence of pairs; each pair contains an index (starting
%ğŸ% from 0) and an element from the given sequence.
%ğŸ% In this example, the output is

\li{enumerate} çš„è¿”å›ç»“æœæ˜¯ä¸€ä¸ª æšä¸¾å¯¹è±¡(enumerate object)ï¼Œ
å®ƒå¯åŸºäºä¸€ä¸ªåŒ…å«è‹¥å¹²ä¸ª \emph{å¯¹} çš„åºåˆ—è¿›è¡Œè¿­ä»£ï¼Œ
æ¯ä¸ªå¯¹åŒ…å«äº†(ä»0å¼€å§‹è®¡æ•°)çš„ç´¢å¼•å·å’Œç»™å®šåºåˆ—ä¸­å¯¹åº”çš„å…ƒç´ ã€‚
åœ¨åˆšæ‰çš„ä¾‹å­ä¸­ï¼Œ å¯¹åº”çš„è¾“å‡ºç»“æœä¼šå’Œå‰ä¾‹ä¸€æ ·ï¼š

\begin{lstlisting}
0 a
1 b
2 c
\end{lstlisting}

%
%ğŸ% Again.
\index{iterator}    \index{object!enumerate}    \index{enumerate object}


%ğŸ% \section{Dictionaries and tuples | å­—å…¸å’Œå…ƒç»„}
\section{å­—å…¸å’Œå…ƒç»„}
\label{dictuple}
\index{dictionary} \index{items method}
\index{method!items} \index{key-value pair}

%ğŸ% Dictionaries have a method called {\tt items} that returns a sequence of
%ğŸ% tuples, where each tuple is a key-value pair.

å­—å…¸å¯¹è±¡æœ‰ä¸€ä¸ªå†…å»ºæ–¹æ³•å«åš \href{https://docs.python.org/3/library/stdtypes.html?highlight=items#dict.items}{ \li{itmes} }ï¼Œ å®ƒè¿”å›ç”±å¤šä¸ªå…ƒç»„ç»„æˆçš„åºåˆ—ï¼Œ å…¶ä¸­æ¯ä¸ªå…ƒç»„æ˜¯ä¸€ä¸ªé”®å€¼å¯¹ã€‚

\begin{lstlisting}
>>> d = {'a':0, 'b':1, 'c':2}
>>> t = d.items()
>>> t
dict_items([('c', 2), ('a', 0), ('b', 1)])
\end{lstlisting}

%
%ğŸ% The result is a \verb"dict_items" object, which is an iterator that
%ğŸ% iterates the key-value pairs.  You can use it in a {\tt for} loop
%ğŸ% like this:

å…¶ç»“æœæ˜¯ä¸€ä¸ª \li{dict_itmes} å¯¹è±¡ï¼Œ è¿™æ˜¯ä¸€ä¸ªå¯¹é”®å€¼å¯¹è¿›è¡Œè¿­ä»£çš„è¿­ä»£å™¨ã€‚
ä½ å¯ä»¥åœ¨ \li{for} å¾ªç¯ä¸­åƒè¿™æ ·ä½¿ç”¨å®ƒ:
\index{iterator}

\begin{lstlisting}
>>> for key, value in d.items():
...     print(key, value)
...
c 2
a 0
b 1
\end{lstlisting}

%
%ğŸ% As you should expect from a dictionary, the items are in no
%ğŸ% particular order.

ç”±äºæ˜¯å­—å…¸ç”Ÿæˆçš„å¯¹è±¡ï¼Œ ä½ åº”è¯¥çŒœåˆ°äº†è¿™äº›é¡¹æ˜¯æ— åºçš„ã€‚

%ğŸ% Going in the other direction, you can use a list of tuples to
%ğŸ% initialize a new dictionary:

å¦ä¸€æ–¹é¢ï¼Œ ä½ å¯ä»¥ä½¿ç”¨å…ƒç»„çš„åˆ—è¡¨åˆå§‹åŒ–ä¸€ä¸ªæ–°çš„å­—å…¸ï¼š
\index{dictionary!initialize}

\begin{lstlisting}
>>> t = [('a', 0), ('c', 2), ('b', 1)]
>>> d = dict(t)
>>> d
{'a': 0, 'c': 2, 'b': 1}
\end{lstlisting}

%ğŸ% Combining {\tt dict} with {\tt zip} yields a concise way
%ğŸ% to create a dictionary:

å°† \li{dict} å’Œ \li{zip}ç»“åˆä½¿ç”¨ï¼Œ å¯ä»¥å¾ˆç®€æ´åœ°åˆ›å»ºä¸€ä¸ªå­—å…¸ï¼š
\index{zip function!use with dict}

\begin{lstlisting}
>>> d = dict(zip('abc', range(3)))
>>> d
{'a': 0, 'c': 2, 'b': 1}
\end{lstlisting}

%
%ğŸ% The dictionary method {\tt update} also takes a list of tuples
%ğŸ% and adds them, as key-value pairs, to an existing dictionary.


å­—å…¸çš„ \li{update} æ–¹æ³•ä¹Ÿæ¥å—å…ƒç»„çš„åˆ—è¡¨ï¼Œ å¹¶ä½œä¸ºé”®-å€¼å¯¹æŠŠå®ƒä»¬æ·»åŠ åˆ°å·²æœ‰çš„å­—å…¸ä¸­ã€‚

\index{update method}  \index{method!update}
\index{traverse!dictionary}  \index{dictionary!traversal}

%ğŸ% It is common to use tuples as keys in dictionaries (primarily because
%ğŸ% you can't use lists).  For example, a telephone directory might map
%ğŸ% from last-name, first-name pairs to telephone numbers.  Assuming
%ğŸ% that we have defined {\tt last}, {\tt first} and {\tt number}, we
%ğŸ% could write:

åœ¨å­—å…¸ä¸­ä½¿ç”¨å…ƒç»„ä½œä¸ºé”®(ä¸»è¦å› ä¸ºæ— æ³•ä½¿ç”¨åˆ—è¡¨)çš„åšæ³•å¾ˆå¸¸è§ã€‚
ä¾‹å¦‚ï¼Œ ä¸€ä¸ªç”µè¯ç°¿å¯èƒ½ä¼šåŸºäºç”¨æˆ·çš„å§“-åå¯¹ï¼Œ æ¥æ˜ å°„è‡³å·ç ã€‚
å‡è®¾æˆ‘ä»¬å·²ç»å®šä¹‰äº† \li{last} ã€ \li{first} å’Œ \li{number} ä¸‰ä¸ªå˜é‡ï¼Œ
æˆ‘ä»¬å¯ä»¥è¿™æ ·å®ç°æ˜ å°„ï¼š

\index{tuple!as key in dictionary}
\index{hashable}

\begin{lstlisting}
directory[last, first] = number
\end{lstlisting}

%
%ğŸ% The expression in brackets is a tuple.  We could use tuple
%ğŸ% assignment to traverse this dictionary.

æ–¹æ‹¬å·ä¸­çš„è¡¨è¾¾å¼æ˜¯ä¸€ä¸ªå…ƒç»„ã€‚
æˆ‘ä»¬å¯ä»¥é€šè¿‡å…ƒç»„èµ‹å€¼æ¥éå†è¿™ä¸ªå­—å…¸ï¼š
\index{tuple!in brackets}

\begin{lstlisting}
for last, first in directory:
    print(first, last, directory[last,first])
\end{lstlisting}

%
%ğŸ% This loop traverses the keys in {\tt directory}, which are tuples.  It
%ğŸ% assigns the elements of each tuple to {\tt last} and {\tt first}, then
%ğŸ% prints the name and corresponding telephone number.

è¯¥å¾ªç¯éå† ç”µè¯ç°¿ \li{directory}ä¸­çš„é”®ï¼Œ å®ƒä»¬å…¶å®æ˜¯å…ƒç»„ã€‚
å¾ªç¯å°†å…ƒç»„çš„å…ƒç´ èµ‹ç»™ \li{last} å’Œ \li{first} ï¼Œ ç„¶åæ‰“å°å‡ºå§“åå’Œå¯¹åº”çš„ç”µè¯å·ç ã€‚

%ğŸ% There are two ways to represent tuples in a state diagram.  The more
%ğŸ% detailed version shows the indices and elements just as they appear in
%ğŸ% a list.  For example, the tuple \verb"('Cleese', 'John')" would appear
%ğŸ% as in Figure~\ref{fig.tuple1}.

åœ¨çŠ¶æ€å›¾ä¸­æœ‰ä¸¤ç§è¡¨ç¤ºå…ƒç»„çš„æ–¹æ³•ã€‚
æ›´è¯¦ç»†çš„ç‰ˆæœ¬æ˜¯ï¼Œ ç´¢å¼•å·å’Œå¯¹åº”å…ƒç´ å°±åƒåˆ—è¡¨ä¸€æ ·å­˜æ”¾åœ¨å…ƒç»„ä¸­ã€‚
ä¾‹å¦‚ï¼Œ å…ƒç»„ \li{('Cleese', 'John')}å¯åƒå›¾~\ref{fig.tuple1}ä¸­é‚£æ ·å­˜æ”¾ã€‚
\index{state diagram} \index{diagram!state}

\begin{figure}
\centerline
{\includegraphics[scale=0.8]{../source/figs/tuple1.pdf}}
\caption{State diagram.}
\label{fig.tuple1}
\end{figure}

%ğŸ% But in a larger diagram you might want to leave out the
%ğŸ% details.  For example, a diagram of the telephone directory might
%ğŸ% appear as in Figure~\ref{fig.dict2}.

åœ¨æ›´å¤§çš„å›¾ä¸­ï¼Œ æˆ‘ä»¬å¿½ç•¥è¿™äº›ç»†èŠ‚ã€‚
è¯¥ç”µè¯ç°¿çš„çŠ¶æ€å›¾å¯èƒ½å¦‚å›¾~\ref{fig.dict2}æ‰€ç¤ºã€‚

\begin{figure}
\centerline
{\includegraphics[scale=0.8]{../source/figs/dict2.pdf}}
\caption{State diagram.}
\label{fig.dict2}
\end{figure}

%ğŸ% Here the tuples are shown using Python syntax as a graphical
%ğŸ% shorthand.  The telephone number in the diagram is the complaints line
%ğŸ% for the BBC, so please don't call it.

å› æ­¤ï¼Œ Pythoné£æ ¼çš„å…ƒç»„ç”¨æ³•å¯ç”¨è¿™ä¸¤å¹…å›¾æ¥æè¿°ã€‚
æ­¤å›¾ä¸­çš„ç”µè¯å·ç æ˜¯ BBC çš„æŠ•è¯‰çƒ­çº¿ï¼Œ è¯·ä¸è¦æ‹¨æ‰“å®ƒã€‚


%ğŸ% \section{Sequences of sequences | åºåˆ—åµŒå¥—}
\section{åºåˆ—åµŒå¥—}
\index{sequence}

%ğŸ% I have focused on lists of tuples, but almost all of the examples in
%ğŸ% this chapter also work with lists of lists, tuples of tuples, and
%ğŸ% tuples of lists.  To avoid enumerating the possible combinations, it
%ğŸ% is sometimes easier to talk about sequences of sequences.

æˆ‘å·²ç»ä»‹ç»äº†åŒ…å«å…ƒç»„çš„åˆ—è¡¨ï¼Œ äº‹å®ä¸Šï¼Œ æœ¬ç« å¤§å¤šæ•°ä¾‹å­ä¹Ÿé€‚ç”¨äºåˆ—è¡¨åµŒå¥—åˆ—è¡¨ã€ å…ƒç»„åµŒå¥—å…ƒç»„ï¼Œ ä»¥åŠå…ƒç»„åµŒå¥—åˆ—è¡¨ã€‚
ä¸ºäº†é¿å… --- ç©·ä¸¾è¿™ç±»å¯èƒ½çš„åµŒå¥—ç»„åˆï¼Œ æˆ‘ä»¬ç®€ç§°ä¸ºåºåˆ—åµŒå¥—ã€‚

%ğŸ% In many contexts, the different kinds of sequences (strings, lists and
%ğŸ% tuples) can be used interchangeably.  So how should you choose one
%ğŸ% over the others?

åœ¨å¾ˆå¤šæƒ…å†µä¸‹ï¼Œ ä¸åŒç±»å‹çš„åºåˆ—(å­—ç¬¦ä¸²ã€åˆ—è¡¨ã€å…ƒç»„)å¯ä»¥äº’æ¢ä½¿ç”¨ã€‚  å› æ­¤ï¼Œ æˆ‘ä»¬å¦‚ä½•é€‰ç”¨åˆé€‚çš„åµŒå¥—å¯¹è±¡å‘¢ï¼Ÿ
\index{string} \index{list} \index{tuple} \index{mutability}
\index{immutability}

%ğŸ% To start with the obvious, strings are more limited than other
%ğŸ% sequences because the elements have to be characters.  They are
%ğŸ% also immutable.  If you need the ability to change the characters
%ğŸ% in a string (as opposed to creating a new string), you might
%ğŸ% want to use a list of characters instead.

é¦–å…ˆï¼Œ æ˜¾è€Œæ˜“è§çš„æ˜¯ï¼Œ å­—ç¬¦ä¸²æ¯”å…¶ä»–åºåˆ—çš„é™åˆ¶æ›´å¤šï¼Œ å› ä¸ºå®ƒçš„æ‰€æœ‰å…ƒç´ éƒ½æ˜¯å­—ç¬¦ï¼Œ ä¸”å­—ç¬¦ä¸²ä¸å¯å˜ã€‚
å¦‚æœä½ å¸Œæœ›èƒ½å¤Ÿæ”¹å˜å­—ç¬¦åœ¨å­—ç¬¦ä¸²ä¸­çš„ä½ç½®ï¼Œ ä½¿ç”¨åˆ—è¡¨åµŒå¥—å­—ç¬¦æ¯”è¾ƒåˆé€‚ã€‚

%ğŸ% Lists are more common than tuples, mostly because they are mutable.
%ğŸ% But there are a few cases where you might prefer tuples:

åˆ—è¡¨æ¯”å…ƒç»„æ›´å¸¸è§ï¼Œ è¿™æºäºå®ƒä»¬å¯å˜æ€§çš„æ˜“ç”¨ã€‚
ä½†æ˜¯æœ‰äº›æƒ…å†µä¸‹ï¼Œ ä½ ä¼šæ›´å€¾å‘äºä½¿ç”¨å…ƒç»„ï¼š

%ğŸ% \begin{enumerate}
%ğŸ%
%ğŸ% \item In some contexts, like a {\tt return} statement, it is
%ğŸ% syntactically simpler to create a tuple than a list.
%ğŸ%
%ğŸ% \item If you want to use a sequence as a dictionary key, you
%ğŸ% have to use an immutable type like a tuple or string.
%ğŸ%
%ğŸ% \item If you are passing a sequence as an argument to a function,
%ğŸ% using tuples reduces the potential for unexpected behavior
%ğŸ% due to aliasing.
%ğŸ%
%ğŸ% \end{enumerate}

\begin{enumerate}

\item åœ¨ä¸€äº›æƒ…å†µä¸‹(ä¾‹å¦‚ \li{return}è¯­å¥)ï¼Œ ä»å¥å¼ä¸Šç”Ÿæˆä¸€ä¸ªå…ƒç»„æ¯”åˆ—è¡¨è¦ç®€å•ã€‚

\item å¦‚æœä½ æƒ³ä½¿ç”¨ä¸€ä¸ªåºåˆ—ä½œä¸ºå­—å…¸çš„é”®ï¼Œ é‚£ä¹ˆä½ å¿…é¡»ä½¿ç”¨å…ƒç»„æˆ–å­—ç¬¦ä¸²è¿™æ ·çš„ä¸å¯å˜ç±»å‹ã€‚

\item å¦‚æœä½ å‘å‡½æ•°ä¼ å…¥ä¸€ä¸ªåºåˆ—ä½œä¸ºå‚æ•°ï¼Œ é‚£ä¹ˆä½¿ç”¨å…ƒç»„ä»¥é™ä½ç”±äºåˆ«åè€Œäº§ç”Ÿçš„æ„å¤–è¡Œä¸ºçš„å¯èƒ½æ€§ã€‚

\end{enumerate}

%ğŸ% Because tuples are immutable, they don't provide methods like {\tt
%ğŸ%   sort} and {\tt reverse}, which modify existing lists.  But Python
%ğŸ% provides the built-in function {\tt sorted}, which takes any sequence
%ğŸ% and returns a new list with the same elements in sorted order, and
%ğŸ% {\tt reversed}, which takes a sequence and returns an iterator that
%ğŸ% traverses the list in reverse order.

æ­£ç”±äºå…ƒç»„çš„ä¸å¯å˜æ€§ï¼Œ å®ƒä»¬æ²¡æœ‰ç±»ä¼¼ \li{sort} å’Œ \li{reverser} è¿™æ ·ä¿®æ”¹ç°æœ‰åˆ—è¡¨çš„æ–¹æ³•ã€‚
ç„¶è€Œ Python æä¾›äº†å†…å»ºå‡½æ•°  \li{sorted}ï¼Œ ç”¨äºå¯¹ä»»æ„åºåˆ—æ’åºå¹¶è¾“å‡ºç›¸åŒå…ƒç´ çš„åˆ—è¡¨ï¼Œ ä»¥åŠ  \li {reversed}ï¼Œ ç”¨äºå¯¹åºåˆ—é€†å‘æ’åºå¹¶ç”Ÿæˆä¸€ä¸ªå¯ä»¥éå†çš„è¿­ä»£å™¨ã€‚

\index{sorted function} \index{function!sorted} \index{reversed function}
\index{function!reversed} \index{iterator}


%ğŸ% \section{Debugging  |  è°ƒè¯•}
\section{è°ƒè¯•}
\index{debugging} \index{data structure}
\index{shape error} \index{error!shape}

%ğŸ% Lists, dictionaries and tuples are examples of {\bf data
%ğŸ%   structures}; in this chapter we are starting to see compound data
%ğŸ% structures, like lists of tuples, or dictionaries that contain tuples
%ğŸ% as keys and lists as values.  Compound data structures are useful, but
%ğŸ% they are prone to what I call {\bf shape errors}; that is, errors
%ğŸ% caused when a data structure has the wrong type, size, or structure.
%ğŸ% For example, if you are expecting a list with one integer and I
%ğŸ% give you a plain old integer (not in a list), it won't work.

åˆ—è¡¨ã€  å­—å…¸ å’Œ å…ƒç»„ éƒ½æ˜¯ {\em æ•°æ®ç»“æ„} ({\bf data structures})ï¼›
æœ¬ç« ä¸­ï¼Œ æˆ‘ä»¬å¼€å§‹æ¥è§¦åˆ° å¤åˆæ•°æ®ç»“æ„ ({\bf compound data structures})ï¼Œ
å¦‚ï¼š åˆ—è¡¨åµŒå¥—å…ƒç»„ï¼Œ åˆå¦‚ä½¿ç”¨å…ƒç»„ä½œä¸ºé”®è€Œåˆ—è¡¨ä½œä¸ºå€¼çš„å­—å…¸ã€‚
å¤åˆæ•°æ®ç»“æ„éå¸¸å®ç”¨ï¼Œ ç„¶è€Œä½¿ç”¨æ—¶å®¹æ˜“å‡ºç°æ‰€è°“çš„ {\em å½¢çŠ¶é”™è¯¯} ({\bf shape errors})ï¼Œ ä¹Ÿå°±æ˜¯è¯´ç”±äºæ•°æ®ç»“æ„çš„ç±»å‹ã€å¤§å°æˆ–ç»“æ„é—®é¢˜è€Œå¼•å‘çš„é”™è¯¯ã€‚
ä¾‹å¦‚ï¼Œ å½“ä½ å¸Œæœ›ä½¿ç”¨å°è£…æ•´æ•°çš„åˆ—è¡¨æ—¶å´ç”¨æˆäº†æ²¡è¢«åˆ—è¡¨åŒ…å«çš„ä¸€ä¸²æ•´æ•°ã€‚
\index{structshape module} \index{module!structshape}

%ğŸ% To help debug these kinds of errors, I have written a module
%ğŸ% called {\tt structshape} that provides a function, also called
%ğŸ% {\tt structshape}, that takes any kind of data structure as
%ğŸ% an argument and returns a string that summarizes its shape.
%ğŸ% You can download it from \url{http://thinkpython2.com/code/structshape.py}

ä¸ºäº†æ–¹é¢è°ƒè¯•è¿™ç±»é”™è¯¯ï¼Œ æˆ‘ç¼–å†™äº†ä¸€ä¸ªå«åš  \li{structshape} çš„æ¨¡å—ï¼Œ
å®ƒæä¾›äº†ä¸€ä¸ªåä¸º \li{structshape} çš„å‡½æ•°ï¼Œ å¯ä»¥æ¥å—ä»»æ„ç±»å‹çš„æ•°æ®ç»“æ„ä½œä¸ºå®å‚ï¼Œ ç„¶åè¿”å›ä¸€ä¸ªæè¿°å®ƒå½¢çŠ¶çš„å­—ç¬¦ä¸²ã€‚
ä½ å¯ä»¥åœ¨\href{http://thinkpython2.com/code/structshape.py}{è¿™é‡Œ}ä¸‹è½½åˆ°å®ƒ(\url{http://thinkpython2.com/code/structshape.py})ã€‚

%ğŸ% Here's the result for a simple list:

ä¸‹é¢æ˜¯ç”¨è¯¥æ¨¡å—è°ƒè¯•ä¸€ä¸ªç®€å•åˆ—è¡¨çš„ç¤ºä¾‹ï¼š

\begin{lstlisting}
>>> from structshape import structshape
>>> t = [1, 2, 3]
>>> structshape(t)
'list of 3 int'
\end{lstlisting}

%
%ğŸ% A fancier program might write ``list of 3 int{\em s}'', but it
%ğŸ% was easier not to deal with plurals.  Here's a list of lists:

æ›´å®Œç¾çš„ç¨‹åºåº”è¯¥æ˜¾ç¤º ``list of 3 int{\em s}''ï¼Œ ä½†æ˜¯å¿½ç•¥è‹±æ–‡å¤æ•°ä½¿ç¨‹åºç®€å•çš„å¤šã€‚
æˆ‘ä»¬å†çœ‹ä¸€ä¸ªåˆ—è¡¨åµŒå¥—çš„ä¾‹å­ï¼š

\begin{lstlisting}
>>> t2 = [[1,2], [3,4], [5,6]]
>>> structshape(t2)
'list of 3 list of 2 int'
\end{lstlisting}

%
%ğŸ% If the elements of the list are not the same type,
%ğŸ% {\tt structshape} groups them, in order, by type:

å¦‚æœåˆ—è¡¨å†…çš„å…ƒç´ ä¸æ˜¯ç›¸åŒç±»å‹ï¼Œ \li{structshape} ä¼šæŒ‰ç…§ç±»å‹çš„é¡ºåºè¿›è¡Œåˆ†ç»„ï¼š

\begin{lstlisting}
>>> t3 = [1, 2, 3, 4.0, '5', '6', [7], [8], 9]
>>> structshape(t3)
'list of (3 int, float, 2 str, 2 list of int, int)'
\end{lstlisting}

%
%ğŸ% Here's a list of tuples:

ä¸‹é¢æ˜¯ä¸€ä¸ªå…ƒç»„åˆ—è¡¨çš„ä¾‹å­ï¼š

\begin{lstlisting}
>>> s = 'abc'
>>> lt = list(zip(t, s))
>>> structshape(lt)
'list of 3 tuple of (int, str)'
\end{lstlisting}

%
%ğŸ% And here's a dictionary with 3 items that map integers to strings.

ä¸‹é¢æ˜¯ä¸€ä¸ªå­—å…¸çš„ä¾‹å­ï¼Œ å…¶ä¸­åŒ…å«ä¸‰ä¸ªå°†æ•´æ•°æ˜ å°„è‡³å­—ç¬¦ä¸²çš„é¡¹ï¼š

\begin{lstlisting}
>>> d = dict(lt)
>>> structshape(d)
'dict of 3 int->str'
\end{lstlisting}

%
%ğŸ% If you are having trouble keeping track of your data structures,
%ğŸ% {\tt structshape} can help.

å¦‚æœä½ åœ¨è¿½è¸ªæ•°æ®ç»“æ„çš„ç±»å‹ä¸Šé‡åˆ°äº†å›°éš¾ï¼Œ å¯ä»¥ä½¿ç”¨ \li{structshape} æ¥å¸®åŠ©åˆ†æã€‚

%ğŸ% \section{Glossary  |  æœ¯è¯­è¡¨}
\section{æœ¯è¯­è¡¨}

\begin{description}

%ğŸ% \item[tuple:] An immutable sequence of elements.

\item[å…ƒç»„ (tuple)ï¼š] ä¸€ç»„ä¸å¯å˜çš„å…ƒç´ çš„åºåˆ—ã€‚
\index{tuple}

%ğŸ% \item[tuple assignment:] An assignment with a sequence on the
%ğŸ% right side and a tuple of variables on the left.  The right
%ğŸ% side is evaluated and then its elements are assigned to the
%ğŸ% variables on the left.

\item[å…ƒç»„èµ‹å€¼ (tuple assignment)ï¼š] ä¸€ç§èµ‹å€¼æ–¹å¼ï¼Œ é€šè¿‡ç­‰å·å³ä¾§çš„åºåˆ—å‘ç­‰å·å·¦ä¾§çš„ä¸€ç»„å˜é‡çš„å…ƒç»„è¿›è¡Œèµ‹å€¼ã€‚
å³ä¾§çš„è¡¨è¾¾å¼å…ˆæ±‚å€¼ï¼Œ ç„¶åå…¶å…ƒç´ è¢«èµ‹å€¼ç»™å·¦ä¾§å…ƒç»„ä¸­å¯¹åº”çš„å˜é‡ã€‚
\index{tuple assignment} \index{assignment!tuple}

%ğŸ% \item[gather:] The operation of assembling a variable-length
%ğŸ% argument tuple.
\index{gather}

\item[æ±‡é›† (gather)ï¼š] ç»„è£…å¯å˜é•¿åº¦å˜é‡å…ƒç»„çš„ä¸€ç§æ“ä½œã€‚

%ğŸ% \item[scatter:] The operation of treating a sequence as a list of
%ğŸ% arguments.
\index{scatter}

\item[åˆ†æ•£ (scatter)ï¼š] å°†ä¸€ä¸ªåºåˆ—å˜æ¢æˆä¸€ä¸ªå‚æ•°åˆ—è¡¨çš„æ“ä½œã€‚


%ğŸ% \item[zip object:] The result of calling a built-in function {\tt zip};
%ğŸ% an object that iterates through a sequence of tuples.

\item[zip å¯¹è±¡ï¼š] ä½¿ç”¨å†…å»ºå‡½æ•° \li{zip} æ‰€è¿”å›çš„ç»“æœï¼› å®ƒæ˜¯ä¸€ä¸ªå¯é€šè¿‡å…ƒç»„åºåˆ—é€ä¸ªè¿­ä»£çš„å¯¹è±¡ã€‚
\index{zip object} \index{object!zip}

%ğŸ% \item[iterator:] An object that can iterate through a sequence, but
%ğŸ% which does not provide list operators and methods.

\item[è¿­ä»£å™¨ (iterator)ï¼š]: ä¸€ä¸ªå¯ä»¥å¯¹åºåˆ—è¿›è¡Œè¿­ä»£çš„å¯¹è±¡ï¼Œ ä½†æ˜¯å¹¶ä¸æä¾›åˆ—è¡¨æ“ä½œç¬¦å’Œæ–¹æ³•ã€‚
\index{iterator}

%ğŸ% \item[data structure:] A collection of related values, often
%ğŸ% organized in lists, dictionaries, tuples, etc.

\item[æ•°æ®ç»“æ„ (data structure)ï¼š] ä¸€ä¸ªç”±å…³è”å€¼ç»„æˆçš„æ•°æ®é›†åˆï¼Œ é€šå¸¸ç»„ç»‡æˆåˆ—è¡¨ã€ å­—å…¸ã€ å…ƒç»„ç­‰ã€‚
\index{data structure}

%ğŸ% \item[shape error:] An error caused because a value has the
%ğŸ% wrong shape; that is, the wrong type or size.

\item[å½¢çŠ¶é”™è¯¯ï¼š] ç”±äºæŸä¸ªå€¼çš„å½¢çŠ¶å‡ºé”™ï¼Œ è€Œå¯¼è‡´çš„é”™è¯¯ï¼› å³æ‹¥æœ‰é”™è¯¯çš„ç±»å‹æˆ–å¤§å°ã€‚
\index{shape}

\end{description}


%ğŸ% \section{Exercises  |  ç»ƒä¹ }

\section{ç»ƒä¹ }

\begin{exercise}
%ğŸ% Write a function called \verb"most_frequent" that takes a string and
%ğŸ% prints the letters in decreasing order of frequency.  Find text
%ğŸ% samples from several different languages and see how letter frequency
%ğŸ% varies between languages.  Compare your results with the tables at
%ğŸ% \url{http://en.wikipedia.org/wiki/Letter_frequencies}.  Solution:
%ğŸ% \url{http://thinkpython2.com/code/most_frequent.py}.

ç¼–å†™ä¸€ä¸ªåä¸º {\em  \li{most_frequent}} çš„å‡½æ•°ï¼Œ
æ¥å—ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œ å¹¶æŒ‰å­—ç¬¦å‡ºç°çš„é¢‘ç‡ é™åºæ‰“å°å­—æ¯ã€‚
æ‰¾ä¸€äº›ä¸åŒè¯­è¨€çš„æ–‡æœ¬æ ·æœ¬ï¼Œ æ¥è¯•è¯•çœ‹ä¸åŒè¯­è¨€ä¹‹é—´å­—æ¯é¢‘ç‡çš„åŒºåˆ«ã€‚
å°†ä½ çš„ç»“æœå’Œç»´åŸºç™¾ç§‘çš„
\href{http://en.wikipedia.org/wiki/Letter_frequencies}{å­—æ¯é¢‘ç‡} è¿›è¡Œæ¯”è¾ƒã€‚

\href{http://thinkpython2.com/code/most_frequent.py}{å‚è€ƒç­”æ¡ˆ}

\index{letter frequency} \index{frequency!letter}
\index{å­—æ¯é¢‘åº¦} \index{é¢‘åº¦!å­—æ¯}

\index{ç»´åŸºç™¾ç§‘}


\end{exercise}


\begin{exercise}
\label{anagrams}
\index{anagram set}  \index{set!anagram}

%ğŸ% More anagrams!
æ˜“ä½æ„è¯æ¸¸æˆ {\em (\href{https://zh.wikipedia.org/wiki/%E6%98%93%E4%BD%8D%E6%9E%84%E8%AF%8D%E6%B8%B8%E6%88%8F}{anagrams})}ï¼

\begin{enumerate}

%ğŸ% \item Write a program
%ğŸ% that reads a word list from a file (see Section~\ref{wordlist}) and
%ğŸ% prints all the sets of words that are anagrams.
%ğŸ%
%ğŸ% Here is an example of what the output might look like:
%ğŸ%
%ğŸ% \begin{lstlisting}
%ğŸ% ['deltas', 'desalt', 'lasted', 'salted', 'slated', 'staled']
%ğŸ% ['retainers', 'ternaries']
%ğŸ% ['generating', 'greatening']
%ğŸ% ['resmelts', 'smelters', 'termless']
%ğŸ% \end{lstlisting}
%ğŸ%
%ğŸ% %
%ğŸ% Hint: you might want to build a dictionary that maps from a
%ğŸ% collection of letters to a list of words that can be spelled with those
%ğŸ% letters.  The question is, how can you represent the collection of
%ğŸ% letters in a way that can be used as a key?
%ğŸ%
%ğŸ% \item Modify the previous program so that it prints the longest list
%ğŸ% of anagrams first, followed by the second longest, and so on.
%ğŸ% \index{Scrabble}
%ğŸ% \index{bingo}
%ğŸ%
%ğŸ% \item In Scrabble a ``bingo'' is when you play all seven tiles in
%ğŸ% your rack, along with a letter on the board, to form an eight-letter
%ğŸ% word.  What collection of 8 letters forms the most possible bingos?
%ğŸ% Hint: there are seven.
%ğŸ%
%ğŸ% % (7, ['angriest', 'astringe', 'ganister', 'gantries', 'granites',
%ğŸ% % 'ingrates', 'rangiest'])
%ğŸ%
%ğŸ% Solution: \url{http://thinkpython2.com/code/anagram_sets.py}.



\item ç¼–å†™ä¸€ä¸ªç¨‹åºï¼Œ ä½¿ä¹‹èƒ½ä»æ–‡ä»¶ä¸­è¯»å–å•è¯çš„åˆ—è¡¨ (å‚è€ƒç« èŠ‚~{\em \ref{wordlist}}) å¹¶ä¸”æ‰“å°å‡ºæ‰€æœ‰ç¬¦åˆå¼‚ä½æ„è¯çš„ç»„åˆã€‚

ä¸‹é¢æ˜¯ä¸€ä¸ªè¾“å‡ºå¼‚ä½æ„è¯çš„æ ·ä¾‹ï¼š

{\em
\begin{lstlisting}
['deltas', 'desalt', 'lasted', 'salted', 'slated', 'staled']
['retainers', 'ternaries']
['generating', 'greatening']
['resmelts', 'smelters', 'termless']
\end{lstlisting}
}

æç¤ºï¼šä¹Ÿè®¸ä½ å¯ä»¥å»ºç«‹ä¸€ä¸ªå­—å…¸ï¼Œ ç”¨äºæ˜ å°„ä¸€ä¸ªå­—ç¬¦é›†åˆåˆ°ä¸€ä¸ªè¯¥é›†åˆå¯å¼‚ä½æ„è¯çš„è¯æ±‡é›†åˆã€‚

\item æ”¹å†™å‰é¢çš„ç¨‹åºï¼Œ ä½¿ä¹‹é¦–å…ˆæ‰“å°åŒ…å«å¼‚ä½æ„è¯æ•°é‡æœ€å¤šçš„è¯æ±‡åˆ—è¡¨ï¼Œ ç¬¬äºŒå¤šæ¬¡ä¹‹ï¼Œ ä¾æ¬¡æŒ‰å¼‚ä½æ„è¯æ•°é‡æ’åˆ—ã€‚

\item \href{https://en.wikipedia.org/wiki/Scrabble}{{\em Scrabble}} \href{https://zh.wikipedia.org/wiki/Scrabble}{æ‹¼å­—æ¸¸æˆ} ä¸­ï¼Œ æ¸¸æˆèƒœåˆ©{\em (``bingo'')}æŒ‡çš„æ˜¯ä½ åˆ©ç”¨æ‰‹é‡Œçš„å…¨éƒ¨ä¸ƒä¸ªå­—æ¯ï¼Œ ä¸å›¾ç‰ˆä¸Šçš„é‚£ä¸ªå­—æ¯ä¸€èµ·æ„æˆä¸€ä¸ª {\em 8} ä¸ªå­—æ¯çš„å•è¯ã€‚  å“ªå…«ä¸ªå­—æ¯èƒ½å¤Ÿè¾¾æˆæœ€å¤šçš„ {\em ``bingo''ï¼Ÿ} æç¤ºï¼šæœ€å¤šæœ‰7ç§èƒœåˆ©æ–¹å¼ã€‚

\href{http://thinkpython2.com/code/anagram_sets.py}{å‚è€ƒç­”æ¡ˆ}

\end{enumerate}

\end{exercise}

\begin{exercise}
\index{metathesis}

%ğŸ% Two words form a ``metathesis pair'' if you can transform one into the
%ğŸ% other by swapping two letters; for example, ``converse'' and
%ğŸ% ``conserve''.  Write a program that finds all of the metathesis pairs
%ğŸ% in the dictionary.  Hint: don't test all pairs of words, and don't
%ğŸ% test all possible swaps.  Solution:
%ğŸ% \url{http://thinkpython2.com/code/metathesis.py}.  Credit: This
%ğŸ% exercise is inspired by an example at \url{http://puzzlers.org}.

å¦‚æœä¸¤ä¸ªå•è¯ä¸­çš„æŸä¸€å•è¯å¯ä»¥é€šè¿‡è°ƒæ¢ä¸¤ä¸ªå­—æ¯å˜ä¸ºå¦ä¸€ä¸ªï¼Œ è¿™ä¸¤ä¸ªå•è¯å°±æ„æˆäº†
``æ¢ä½å¯¹ {\em (metatheisi pair)}''ï¼› æ¯”å¦‚ {\em ``converse''} å’Œ {\em ``conserve''}ã€‚
ç¼–å†™ä¸€ä¸ªç¨‹åºï¼Œ æ‰¾å‡ºç»™å®šå­—å…¸é‡Œæ‰€æœ‰çš„ ``æ¢ä½å¯¹''ã€‚\footnote{æç¤ºï¼š ä¸ç”¨æµ‹è¯•æ‰€æœ‰çš„å•è¯ç»„åˆï¼Œ ä¹Ÿä¸ç”¨æµ‹è¯•æ‰€æœ‰çš„å­—æ¯è°ƒæ¢ç»„åˆã€‚  }

\href{http://thinkpython2.com/code/metathesis.py}{å‚è€ƒç­”æ¡ˆ}

\footnote{è¿™ä¸ªç»ƒä¹ å—\href{http://puzzlers.org}{http://puzzlers.org}çš„æ¡ˆä¾‹å¯å‘è€Œæˆã€‚  }

\end{exercise}


\begin{exercise}
\index{Car Talk}
\index{Puzzler}

%ğŸ% Here's another Car Talk Puzzler
%ğŸ% (\url{http://www.cartalk.com/content/puzzlers}):
%ğŸ%
%ğŸ% \begin{quote}
%ğŸ% What is the longest English word, that remains a valid English word,
%ğŸ% as you remove its letters one at a time?
%ğŸ%
%ğŸ% Now, letters can be removed from either end, or the middle, but you
%ğŸ% can't rearrange any of the letters. Every time you drop a letter, you
%ğŸ% wind up with another English word. If you do that, you're eventually
%ğŸ% going to wind up with one letter and that too is going to be an
%ğŸ% English word---one that's found in the dictionary. I want to know
%ğŸ% what's the longest word and how many letters does it
%ğŸ% have?
%ğŸ%
%ğŸ% I'm going to give you a little modest example: Sprite. Ok? You start
%ğŸ% off with sprite, you take a letter off, one from the interior of the
%ğŸ% word, take the r away, and we're left with the word spite, then we
%ğŸ% take the e off the end, we're left with spit, we take the s off, we're
%ğŸ% left with pit, it, and I.
%ğŸ% \end{quote}

å¦ä¸€ä¸ªæ¥è‡ª {\em Car Talk} çš„å­—è°œé¢˜ \href{http://www.cartalk.com/content/puzzlers}{{\em car talk puzzler}} ï¼š

\begin{quote}

å¦‚æœä½ æ¯ä¸€æ¬¡ä»å•è¯ä¸­åˆ æ‰ä¸€ä¸ªå­—æ¯ä»¥åï¼Œ å‰©ä¸‹çš„å­—ç¬¦ä»ç„¶èƒ½æ„æˆä¸€ä¸ªå•è¯ï¼Œ è¯·é—®ä¸–ç•Œä¸Šç¬¦åˆæ¡ä»¶çš„æœ€é•¿å•è¯æ˜¯ä»€ä¹ˆï¼Ÿ

æ³¨æ„ï¼Œ è¢«åˆ æ‰çš„å­—æ¯å¯ä»¥ä½äºé¦–å°¾æˆ–æ˜¯ä¸­é—´ï¼Œ ä½†ä¸å…è®¸é‡æ–°å»æ’åˆ—å‰©ä¸‹çš„å­—æ¯ã€‚
æ¯æ¬¡ç§»é™¤ä¸€ä¸ªå­—æ¯å ï¼Œ ä½ ä¼šå¾—åˆ°ä¸€ä¸ªæ–°å•è¯ã€‚
è¿™æ ·ä¸€ç›´ä¸‹å»ï¼Œ æœ€ç»ˆä½ åªå‰©ä¸€ä¸ªå­—æ¯ï¼Œ å¹¶ä¸”å®ƒä¹Ÿæ˜¯ä¸€ä¸ªå•è¯â€”â€”å¯ä»¥åœ¨å­—å…¸ä¸­æŸ¥åˆ°ã€‚  æˆ‘æƒ³çŸ¥é“ï¼Œ ç¬¦åˆæ¡ä»¶çš„æœ€é•¿å•è¯æ˜¯ä»€ä¹ˆï¼Ÿå®ƒç”±å¤šå°‘ä¸ªå­—æ¯æ„æˆï¼Ÿ

æˆ‘å…ˆç»™å‡ºä¸€ä¸ªçŸ­å°çš„ä¾‹å­ï¼š {\em ``Sprite''}ï¼Œ ä¸€å¼€å§‹æ˜¯ {\em sprite} ï¼Œ æˆ‘ä»¬å¯ä»¥æ‹¿æ‰ä¸­é—´çš„ {\em `r'} ä»è€Œè·å¾—å•è¯ {\em spite}ï¼Œ æ‹¿å»å­—æ¯ {\em `e'} å¾—åˆ° {\em spit}ï¼Œ å†å»æ‰ {\em `s'} å‰©ä¸‹ {\em pit}ï¼Œ {\em it}ï¼Œ æœ€å {\em I}ã€‚
\end{quote}

\index{reducible word} \index{word, reducible}

%ğŸ% Write a program to find all words that can be reduced in this way,
%ğŸ% and then find the longest one.
%ğŸ%
%ğŸ% This exercise is a little more challenging than most, so here are
%ğŸ% some suggestions:

%ğŸ% \begin{enumerate}
%ğŸ%
%ğŸ% \item You might want to write a function that takes a word and
%ğŸ%   computes a list of all the words that can be formed by removing one
%ğŸ%   letter.  These are the ``children'' of the word.
%ğŸ% \index{recursive definition}
%ğŸ% \index{definition!recursive}
%ğŸ%
%ğŸ% \item Recursively, a word is reducible if any of its children
%ğŸ% are reducible.  As a base case, you can consider the empty
%ğŸ% string reducible.
%ğŸ%
%ğŸ% \item The wordlist I provided, {\tt words.txt}, doesn't
%ğŸ% contain single letter words.  So you might want to add
%ğŸ% ``I'', ``a'', and the empty string.
%ğŸ%
%ğŸ% \item To improve the performance of your program, you might want
%ğŸ% to memoize the words that are known to be reducible.
%ğŸ%
%ğŸ% \end{enumerate}
%ğŸ%
%ğŸ% Solution: \url{http://thinkpython2.com/code/reducible.py}.

ç¼–å†™ä¸€ä¸ªç¨‹åºï¼Œ æŒ‰ç…§è¿™ç§è§„åˆ™æ‰¾åˆ°æ‰€æœ‰å¯ä»¥ç¼©å‡çš„å•è¯ï¼Œ ç„¶åçœ‹çœ‹å…¶ä¸­å“ªä¸ªè¯æœ€é•¿ã€‚

è¿™é“é¢˜æ¯”å¤§éƒ¨åˆ†çš„ä¹ é¢˜éƒ½è¦éš¾ï¼Œ æ‰€ä»¥æˆ‘ç»™å‡ºä¸€äº›å»ºè®®ï¼š

\begin{enumerate}
\item å¯èƒ½ä½ éœ€è¦å†™ä¸€ä¸ªå‡½æ•°å°†è¾“å…¥å•è¯çš„æ‰€æœ‰``å­è¯''(å³æ‹¿æ‰ä¸€ä¸ªå­—æ¯åæ‰€æœ‰å¯èƒ½çš„æ–°è¯)ä»¥åˆ—è¡¨å½¢å¼è¾“å‡ºã€‚
\index{recursive definition} \index{definition!recursive}

\item é€’å½’åœ°çœ‹ï¼Œ å¦‚æœå•è¯çš„å­è¯ä¹‹ä¸€ä¹Ÿå¯ç¼©å‡ï¼Œ é‚£ä¹ˆè¿™ä¸ªå•è¯ä¹Ÿå¯è¢«ç¼©å‡ã€‚
æˆ‘ä»¬å¯ä»¥å°†ç©ºå­—ç¬¦ä¸²è§†ä½œä¹Ÿå¯ä»¥ç¼©å‡ï¼Œ è§†å…¶ä¸ºåŸºç¡€æƒ…å½¢ã€‚

\item æˆ‘ä»¬æä¾›çš„è¯æ±‡è¡¨ {\em (\li{words.txt})} å¹¶æœªåŒ…å«è¯¸å¦‚ {\em `I'}ã€ {\em `a'} è¿™æ ·çš„å•ä¸ªå­—æ¯è¯æ±‡ï¼Œ å› æ­¤ä½ å¯èƒ½éœ€è¦åŠ ä¸Šå®ƒä»¬ã€‚

\item ä¸ºäº†æé«˜ä½ ç¨‹åºçš„æ€§èƒ½ï¼Œ ä½ å¯èƒ½éœ€è¦æš‚å­˜ {\em (memorize)} å¥½å·²è¢«å‘ç°çš„å¯è¢«ç¼©è¯çš„è¯æ±‡ã€‚

\end{enumerate}

\href{http://thinkpython2.com/code/reducible.py}{å‚è€ƒç­”æ¡ˆ}

\end{exercise}




%\begin{exercise}
%\url{http://en.wikipedia.org/wiki/Word_Ladder}
%\end{exercise}



