


%ğŸ% \chapter{Inheritance}
\chapter{ç»§æ‰¿}

%ğŸ% The language feature most often associated with object-oriented
%ğŸ% programming is {\bf inheritance}.  Inheritance is the ability to
%ğŸ% define a new class that is a modified version of an existing class.
%ğŸ% In this chapter I demonstrate inheritance using classes that represent
%ğŸ% playing cards, decks of cards, and poker hands.

æœ€å¸¸ä¸é¢å‘å¯¹è±¡ç¼–ç¨‹è”ç³»åœ¨ä¸€èµ·çš„è¯­è¨€ç‰¹æ€§å°±æ˜¯ {\em ç»§æ‰¿}ã€‚
ç»§æ‰¿æŒ‡çš„æ˜¯åœ¨ç°æœ‰ç±»çš„åŸºç¡€ä¸‹è¿›è¡Œä¿®æ”¹ï¼Œä»è€Œå®šä¹‰æ–°ç±»çš„èƒ½åŠ›ã€‚
åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä¼šç”¨è¡¨ç¤ºå¡ç‰Œã€ä¸€å‰¯ç‰Œå’Œç‰Œå‹çš„ç±»\footnote{å¡ç‰Œ (playing cards)ï¼›ä¸€å‰¯ç‰Œ
(deck of hands)ï¼›ç‰Œå‹ (poker hands)ã€‚}ï¼Œæ¥å±•ç¤ºç»§æ‰¿è¿™ä¸€ç‰¹æ€§ã€‚

\index{deck}  \index{card, playing}  \index{poker}

%ğŸ% If you don't play
%ğŸ% poker, you can read about it at
%ğŸ% \url{http://en.wikipedia.org/wiki/Poker}, but you don't have to; I'll
%ğŸ% tell you what you need to know for the exercises.

å¦‚æœä½ ä¸ç©æ‰‘å…‹ç‰Œï¼Œä½ å¯ä»¥ \href{http://en.wikipedia.org/wiki/Poker}{é˜…è¯»}äº†è§£ä¸€ä¸‹ï¼Œä½†è¿™ä¸æ˜¯å¿…é¡»çš„ï¼›æˆ‘ä¼šå‘Šè¯‰ä½ å®Œæˆç»ƒä¹ æ‰€éœ€è¦äº†è§£çš„çŸ¥è¯†ç‚¹ã€‚

%ğŸ% Code examples from
%ğŸ% this chapter are available from
%ğŸ% \url{http://thinkpython2.com/code/Card.py}.

%ğŸ% \section{Card objects}
\section{å¡ç‰Œå¯¹è±¡}

%ğŸ% There are fifty-two cards in a deck, each of which belongs to one of
%ğŸ% four suits and one of thirteen ranks.  The suits are Spades, Hearts,
%ğŸ% Diamonds, and Clubs (in descending order in bridge).  The ranks are
%ğŸ% Ace, 2, 3, 4, 5, 6, 7, 8, 9, 10, Jack, Queen, and King.  Depending on
%ğŸ% the game that you are playing, an Ace may be higher than King
%ğŸ% or lower than 2.

ä¸€å‰¯ç‰Œæœ‰52å¼ ç‰Œï¼Œæ¯ä¸€å¼ å±äº4ç§èŠ±è‰²çš„ä¸€ä¸ªå’Œ13ä¸ªç­‰çº§çš„ä¸€ä¸ªã€‚
4ç§èŠ±è‰²æ˜¯é»‘æ¡ƒã€çº¢å¿ƒã€æ–¹å—ã€æ¢…èŠ± \footnote{é»‘æ¡ƒ (Spades)ï¼›çº¢å¿ƒ (Hearts)ï¼›æ–¹å— (Diamonds)ï¼›æ¢…èŠ± (Clubs)ã€‚}ï¼Œ
ä»¥æ¡¥ç‰Œä¸­çš„é€†åºæ’åˆ—ã€‚  13ä¸ªç­‰çº§æ˜¯Aã€2ã€3ã€4ã€5ã€6ã€7ã€8ã€9ã€10ã€Jã€Qã€Kã€‚
æ ¹æ®ä½ ç©çš„æ¸¸æˆçš„ä¸åŒï¼ŒA å¯èƒ½æ¯” K å¤§æˆ–è€…æ¯” 2 å°ã€‚

\index{rank}  \index{suit}

%ğŸ% If we want to define a new object to represent a playing card, it is
%ğŸ% obvious what the attributes should be: {\tt rank} and
%ğŸ% {\tt suit}.  It is not as obvious what type the attributes
%ğŸ% should be.  One possibility is to use strings containing words like
%ğŸ% \verb"'Spade'" for suits and \verb"'Queen'" for ranks.  One problem with
%ğŸ% this implementation is that it would not be easy to compare cards to
%ğŸ% see which had a higher rank or suit.

å¦‚æœæˆ‘ä»¬å®šä¹‰ä¸€ä¸ªæ–°çš„å¯¹è±¡æ¥è¡¨ç¤ºå¡ç‰Œï¼Œæ˜æ˜¾å®ƒåº”è¯¥æœ‰ \li{rank} (ç­‰çº§) å’Œ \li{suit} (èŠ±è‰²)
ä¸¤ä¸ªå±æ€§ã€‚  ä½†ä¸¤ä¸ªå±æ€§çš„ç±»å‹ä¸å¤ªæ˜æ˜¾ã€‚  ä¸€ä¸ªå¯èƒ½æ˜¯ä½¿ç”¨å­—ç¬¦ä¸²ç±»å‹ï¼Œ
å¦‚ \li{'Spade'} è¡¨ç¤ºèŠ±è‰²ï¼Œ\li{'Queen'} è¡¨ç¤ºç­‰çº§ã€‚  è¿™ç§å®ç°çš„ä¸€ä¸ªé—®é¢˜æ˜¯ï¼Œä¸æ˜¯é‚£ä¹ˆå®¹æ˜“æ¯”è¾ƒç‰Œçš„å¤§å°ï¼Œçœ‹å“ªå¼ ç‰Œçš„ç­‰çº§æˆ–èŠ±è‰²æ›´é«˜ã€‚

\index{encode}  \index{encrypt}
\index{map to}  \index{representation}

%ğŸ% An alternative is to use integers to {\bf encode} the ranks and suits.
%ğŸ% In this context, ``encode'' means that we are going to define a mapping
%ğŸ% between numbers and suits, or between numbers and ranks.  This
%ğŸ% kind of encoding is not meant to be a secret (that
%ğŸ% would be ``encryption'').

å¦å¤–ä¸€ç§æ–¹æ³•ï¼Œæ˜¯ä½¿ç”¨ä¸€ä¸ªæ•´å‹æ¥ {\em ç¼–ç } ç­‰çº§ å’Œ èŠ±è‰²ã€‚
åœ¨è¿™é‡Œï¼Œ``ç¼–ç '' è¡¨ç¤ºæˆ‘ä»¬è¦å®šä¹‰ä¸€ä¸ªæ•°å­—åˆ°èŠ±è‰²æˆ–æ•°å­—åˆ°ç­‰çº§çš„æ˜ å°„ã€‚
ä½†æ˜¯è¿™é‡Œçš„ç¼–ç å¹¶ä¸æ˜¯ä¸ºäº†ä¿å¯†(é‚£å°±æˆäº†``åŠ å¯†'')ã€‚

\newcommand{\mymapsto}{$\mapsto$}

%ğŸ% For example, this table shows the suits and the corresponding integer
%ğŸ% codes:

ä¾‹å¦‚ï¼Œä¸‹é¢çš„è¡¨æ ¼åˆ—å‡ºäº†èŠ±è‰²å’Œå¯¹åº”çš„æ•´æ•°ç ï¼š

\begin{tabular}{l c l}
Spades & \mymapsto & 3 \\
Hearts & \mymapsto & 2 \\
Diamonds & \mymapsto & 1 \\
Clubs & \mymapsto & 0
\end{tabular}

%ğŸ% This code makes it easy to compare cards; because higher suits map to
%ğŸ% higher numbers, we can compare suits by comparing their codes.

æ•´æ•°ç ä½¿å¾—å¾ˆå®¹æ˜“æ¯”è¾ƒç‰Œçš„å¤§å°ï¼›å› ä¸ºæ›´é«˜çš„èŠ±è‰²å¯¹åº”æ›´é«˜çš„æ•°å­—ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡æ¯”è¾ƒæ•°å­—ï¼Œæ¥åˆ¤æ–­èŠ±è‰²çš„çš„å¤§å°ã€‚

%ğŸ% The mapping for ranks is fairly obvious; each of the numerical ranks
%ğŸ% maps to the corresponding integer, and for face cards:

ç­‰çº§çš„æ˜ å°„ç±»å‹é€‰æ‹©å°±æ˜¾è€Œæ˜“è§ï¼›æ¯ä¸ªæ•°å­—ç­‰çº§å¯¹åº”ç›¸åº”çš„æ•´æ•°ï¼Œç„¶åå¯¹äºJï¼ŒKï¼ŒQï¼š

\begin{tabular}{l c l}
Jack & \mymapsto & 11 \\
Queen & \mymapsto & 12 \\
King & \mymapsto & 13 \\
\end{tabular}

%ğŸ% I am using the \mymapsto~symbol to make it clear that these mappings
%ğŸ% are not part of the Python program.  They are part of the program
%ğŸ% design, but they don't appear explicitly in the code.

è¿™é‡Œï¼Œæˆ‘ä½¿ç”¨ \mymapsto~ç¬¦å·æ¥æ¸…æ¥šçš„è¡¨ç¤ºï¼Œè¿™äº›ä¸æ˜¯ Python ç¨‹åºçš„ä¸€éƒ¨åˆ†ã€‚  å®ƒä»¬å±äºç¨‹åºè®¾è®¡çš„ä¸€éƒ¨åˆ†ï¼Œä½†æ˜¯ä¸ä¼šå‡ºç°åœ¨ä»£ç ä¸­ã€‚

\index{Card class}  \index{class!Card}

%ğŸ% The class definition for {\tt Card} looks like this:

\li{Card}ç±»çš„å®šä¹‰å¦‚ä¸‹ï¼š

\begin{lstlisting}
class Card:
    """Represents a standard playing card."""

    def __init__(self, suit=0, rank=2):
        self.suit = suit
        self.rank = rank
\end{lstlisting}

%
%ğŸ% As usual, the init method takes an optional
%ğŸ% parameter for each attribute.  The default card is
%ğŸ% the 2 of Clubs.

é€šå¸¸ï¼Œinit æ–¹æ³•æ¥å—é’ˆå¯¹æ¯ä¸ªå±æ€§çš„å¯é€‰å½¢å‚ã€‚é»˜è®¤çš„å¡ç‰Œæ˜¯æ¢…èŠ± 2ã€‚

\index{init method}  \index{method!init}

%ğŸ% To create a Card, you call {\tt Card} with the
%ğŸ% suit and rank of the card you want.

å¯ä»¥ä½¿ç”¨ä½ éœ€è¦çš„èŠ±è‰²å’Œç­‰çº§è°ƒç”¨ \li{Card} ï¼Œåˆ›å»ºä¸€ä¸ª \li{Card} å¯¹è±¡ã€‚

\begin{lstlisting}
queen_of_diamonds = Card(1, 12)
\end{lstlisting}
%

%ğŸ% \section{Class attributes}
\section{ç±»å±æ€§}

\label{class.attribute}
\index{class attribute}  \index{attribute!class}

%ğŸ% In order to print Card objects in a way that people can easily
%ğŸ% read, we need a mapping from the integer codes to the corresponding
%ğŸ% ranks and suits.  A natural way to
%ğŸ% do that is with lists of strings.  We assign these lists to {\bf class
%ğŸ% attributes}:

ä¸ºäº†ä»¥å¤§å®¶èƒ½å¤Ÿè½»æ¾çœ‹æ‡‚çš„æ–¹å¼æ¥æ‰“å°å¡ç‰Œå¯¹è±¡ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªä»æ•´æ•°ç åˆ°å¯¹åº”çš„ç­‰çº§å’ŒèŠ±è‰²çš„æ˜ å°„ã€‚
ä¸€ç§ç›´æ¥çš„æ–¹æ³•æ˜¯ä½¿ç”¨å­—ç¬¦ä¸²åˆ—è¡¨ã€‚æˆ‘ä»¬æŠŠè¿™äº›åˆ—è¡¨èµ‹å€¼åˆ° {\em ç±»å±æ€§} ï¼š

\begin{lstlisting}
# inside class Card:

    suit_names = ['Clubs', 'Diamonds', 'Hearts', 'Spades']
    rank_names = [None, 'Ace', '2', '3', '4', '5', '6', '7',
              '8', '9', '10', 'Jack', 'Queen', 'King']

    def __str__(self):
        return '%s of %s' % (Card.rank_names[self.rank],
                             Card.suit_names[self.suit])
\end{lstlisting}

%ğŸ% %
%ğŸ% Variables like \verb"suit_names" and \verb"rank_names", which are
%ğŸ% defined inside a class but outside of any method, are called
%ğŸ% class attributes because they are associated with the class object
%ğŸ% {\tt Card}.

åƒ \li{suit_names} å’Œ \li{rank_names} è¿™æ ·çš„å˜é‡ï¼Œæ˜¯å®šä¹‰åœ¨ç±»å†…éƒ¨ä½†åœ¨æ–¹æ³•ä¹‹å¤–ï¼Œ
è¢«ç§°ä¸ºç±»å±æ€§ã€‚å› ä¸ºä»–ä»¬æ˜¯è¢«å…³è”åˆ° \li{Card} ç±»å¯¹è±¡ä¸Šçš„ã€‚

\index{instance attribute}  \index{attribute!instance}

%ğŸ% This term distinguishes them from variables like {\tt suit} and {\tt
%ğŸ%   rank}, which are called {\bf instance attributes} because they are
%ğŸ% associated with a particular instance.
%ğŸ% \index{dot notation}

è¿™ä¸ªæœ¯è¯­å°†å®ƒä»¬åŒ \li{suit} å’Œ \li{rank} è¿™æ ·çš„å˜é‡åŒºåˆ†å¼€æ¥ï¼Œåè€…è¢«ç§°ä¸º {\em å®ä¾‹å±æ€§}ï¼Œ
å› ä¸ºä»–ä»¬è¢«å…³è”åˆ°äº†ç‰¹å®šçš„å®ä¾‹ã€‚

%ğŸ% Both kinds of attribute are accessed using dot notation.  For
%ğŸ% example, in \verb"__str__", {\tt self} is a Card object,
%ğŸ% and {\tt self.rank} is its rank.  Similarly, {\tt Card}
%ğŸ% is a class object, and \verb"Card.rank_names" is a
%ğŸ% list of strings associated with the class.

è¿™ä¸¤ç§å±æ€§éƒ½ä½¿ç”¨ç‚¹æ ‡è®°æ³•æ¥è®¿é—®ã€‚
ä¾‹å¦‚ï¼Œåœ¨ \li{__str__} ä¸­ï¼Œ \li{self} æ˜¯ä¸€ä¸ªå¡ç‰Œå¯¹è±¡ï¼Œ \li{self.rank} æ˜¯å®ƒçš„ç­‰çº§ã€‚
åŒæ ·çš„ï¼Œ \li{Card} æ˜¯ä¸€ä¸ªç±»å¯¹è±¡ï¼Œ \li{Card.rank_names} æ˜¯ä¸€ä¸ªå’Œç±»å…³è”çš„å­—ç¬¦ä¸²åˆ—è¡¨ã€‚

%ğŸ% Every card has its own {\tt suit} and {\tt rank}, but there
%ğŸ% is only one copy of \verb"suit_names" and \verb"rank_names".

æ¯ä¸€å¼ å¡ç‰Œéƒ½æœ‰è‡ªå·±çš„èŠ±è‰²å’Œç­‰çº§ï¼Œ
ä½†æ˜¯è¿™é‡Œåªæœ‰ä¸€ä»½ \li{suit_names} å’Œ \li{rank_names} æ‹·è´ã€‚

%ğŸ% Putting it all together, the expression
%ğŸ% \verb"Card.rank_names[self.rank]" means ``use the attribute {\tt rank}
%ğŸ% from the object {\tt self} as an index into the list \verb"rank_names"
%ğŸ% from the class {\tt Card}, and select the appropriate string.''

ç»¼åˆæ¥è¯´ï¼Œè¡¨è¾¾å¼ \li{Card.rank_names[self.rank]} è¡¨ç¤º ``ä½¿ç”¨ \li{self} å¯¹è±¡
ä¸­çš„ \li{rank} å±æ€§ä½œä¸º \li{Card} ç±»çš„ \li{rank_names}
åˆ—è¡¨çš„ç´¢å¼•ä¸‹æ ‡ï¼Œç„¶åè·å–ç›¸åº”çš„å­—ç¬¦ä¸²ã€‚''

%ğŸ% The first element of \verb"rank_names" is {\tt None} because there
%ğŸ% is no card with rank zero.  By including {\tt None} as a place-keeper,
%ğŸ% we get a mapping with the nice property that the index 2 maps to the
%ğŸ% string \verb"'2'", and so on.  To avoid this tweak, we could have
%ğŸ% used a dictionary instead of a list.

\li{rank_names} çš„ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯ \li{None} ï¼Œå› ä¸ºæ²¡æœ‰å¡ç‰Œçš„ç­‰çº§æ˜¯ 0 ã€‚
é€šè¿‡ä½¿ç”¨ \li{None} ä½œä¸ºå ä½ç¬¦ï¼Œæˆ‘ä»¬å¯ä»¥å¾ˆå¥½åœ°å°†ç´¢å¼• 2 æ˜ å°„åˆ°å­—ç¬¦ä¸² \li{'2'} ï¼Œç­‰ç­‰ã€‚
ä¸ºäº†é¿å…ä½¿ç”¨è¿™ç§å°æŠ€å·§ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥ä½¿ç”¨ä¸€ä¸ªå­—å…¸æ¥ä»£æ›¿åˆ—è¡¨ã€‚

%ğŸ% With the methods we have so far, we can create and print cards:

åˆ©ç”¨ç°æœ‰çš„æ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥åˆ›å»ºå’Œæ‰“å°å¡ç‰Œï¼š

\begin{lstlisting}
>>> card1 = Card(2, 11)
>>> print(card1)
Jack of Hearts
\end{lstlisting}

\begin{figure}
\centerline
{\includegraphics[scale=0.8]{../source/figs/card1.pdf}}
%ğŸ% \caption{Object diagram.}
\caption{å¯¹è±¡å›¾ã€‚}
\label{fig.card1}
\end{figure}

%ğŸ% Figure~\ref{fig.card1} is a diagram of the {\tt Card} class object and
%ğŸ% one Card instance.  {\tt Card} is a class object; its type is {\tt
%ğŸ%   type}.  {\tt card1} is an instance of {\tt Card}, so its type is
%ğŸ% {\tt Card}.  To save space, I didn't draw the contents of
%ğŸ% \verb"suit_names" and \verb"rank_names".

å›¾~\ref{fig.card1} æ˜¯ \li{Card} ç±»å¯¹è±¡å’Œä¸€ä¸ª \li{Card} å®ä¾‹çš„å›¾ç¤ºã€‚ \li{Card} æ˜¯ä¸€ä¸ªç±»å¯¹è±¡ï¼›å®ƒçš„ç±»å‹æ˜¯ \li{type} ã€‚ \li{card1} æ˜¯ \li{Card} çš„ä¸€ä¸ªå®ä¾‹ï¼Œå› æ­¤å®ƒçš„ç±»å‹æ˜¯ \li{Card}ã€‚ ä¸ºäº†èŠ‚çœç©ºé—´ï¼Œæˆ‘æ²¡æœ‰ç”»å‡º \li{suit_names} å’Œ \li{rank_names} çš„å†…å®¹ã€‚

\index{state diagram}  \index{diagram!state}
\index{object diagram}  \index{diagram!object}


%ğŸ% \section{Comparing cards}
\section{å¡ç‰Œæ¯”è¾ƒ}

\label{comparecard}
\index{operator!relational}
\index{relational operator}

%ğŸ% For built-in types, there are relational operators
%ğŸ% ({\tt <}, {\tt >}, {\tt ==}, etc.)
%ğŸ% that compare
%ğŸ% values and determine when one is greater than, less than, or equal to
%ğŸ% another.  For programmer-defined types, we can override the behavior of
%ğŸ% the built-in operators by providing a method named
%ğŸ% \verb"__lt__", which stands for ``less than''.

å¯¹äºå†…å»ºç±»å‹ï¼Œæœ‰å…³ç³»è¿ç®—ç¬¦(<, >, ==, ç­‰ç­‰)å¯ä»¥æ¯”è¾ƒå€¼ï¼Œåˆ¤æ–­å“ªä¸€ä¸ªæ˜¯å¤§äºã€å°äºæˆ–ç­‰äºå¦å¤–ä¸€ä¸ªã€‚
å¯¹äºç¨‹åºå‘˜è‡ªå®šä¹‰çš„ç±»å‹ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡æä¾›ä¸€ä¸ªå« \li{__lt__} (ä»£è¡¨â€œå°äºâ€)çš„æ–¹æ³•ï¼Œæ¥è¦†ç›–å†…å»ºè¿ç®—ç¬¦çš„è¡Œä¸ºã€‚

\index{programmer-defined type}
\index{type!programmer-defined}

%ğŸ% \verb"__lt__" takes two parameters, {\tt self} and {\tt other},
%ğŸ% and {\tt True} if {\tt self} is strictly less than {\tt other}.

\li{__lt__} æ¥å— 2 ä¸ªå‚æ•°, \li{self} å’Œ \li{other}ï¼Œå¦‚æœ \li{self} æ¯” \li{other} çš„å€¼è¦å°åˆ™è¿”å› \li{True} ã€‚

\index{override}
\index{operator overloading}

%ğŸ% The correct ordering for cards is not obvious.
%ğŸ% For example, which
%ğŸ% is better, the 3 of Clubs or the 2 of Diamonds?  One has a higher
%ğŸ% rank, but the other has a higher suit.  In order to compare
%ğŸ% cards, you have to decide whether rank or suit is more important.

å¡ç‰Œçš„æ­£ç¡®é¡ºåºå¹¶ä¸æ˜æ˜¾ã€‚
ä¾‹å¦‚ï¼Œæ¢…èŠ± 3 å’Œæ–¹å— 2 å“ªä¸ªæ›´é«˜ï¼Ÿ
ä¸€ä¸ªç­‰çº§æ›´é«˜ï¼Œå¦ä¸€ä¸ªèŠ±è‰²æ›´é«˜ã€‚
ä¸ºäº†æ¯”è¾ƒå¡ç‰Œï¼Œä½ å¿…é¡»å†³å®šç­‰çº§è¿˜æ˜¯èŠ±è‰²æ›´é‡è¦ã€‚

%ğŸ% The answer might depend on what game you are playing, but to keep
%ğŸ% things simple, we'll make the arbitrary choice that suit is more
%ğŸ% important, so all of the Spades outrank all of the Diamonds,
%ğŸ% and so on.

ç­”æ¡ˆå¯èƒ½æ ¹æ®ä½ ç©çš„æ˜¯ä»€ä¹ˆæ¸¸æˆè€Œä¸åŒï¼Œä½†æ˜¯ç®€æ´èµ·è§ï¼Œ
æˆ‘ä»¬å°†è§„å®šèŠ±è‰²æ›´é‡è¦ï¼Œæ‰€ä»¥æ‰€æœ‰çš„é»‘æ¡ƒå¤§äºä»»ä½•æ–¹å—å¡ç‰Œï¼Œä»¥æ­¤ç±»æ¨ã€‚

\index{cmp method@\_\_cmp\_\_ method}
\index{method!\_\_cmp\_\_}

%ğŸ% With that decided, we can write \verb"__lt__":

å®šå¥½äº†è¿™ä¸ªè§„åˆ™åï¼Œæˆ‘ä»¬å¯ä»¥ç¼–å†™ \li{__lt__} äº†ï¼š

\begin{lstlisting}
# inside class Card:
# åœ¨Cardç±»å†…éƒ¨:

    def __lt__(self, other):
        # check the suits
        # åˆ¤æ–­èŠ±è‰²
        if self.suit < other.suit: return True
        if self.suit > other.suit: return False

        # suits are the same... check ranks
        # èŠ±è‰²ç›¸åŒ...åˆ¤æ–­ç­‰çº§
        return self.rank < other.rank
\end{lstlisting}

%ğŸ% %
%ğŸ% You can write this more concisely using tuple comparison:

ä½ å¯ä»¥ä½¿ç”¨å…ƒç»„æ¯”è¾ƒæ¥ä½¿å¾—ä»£ç æ›´åŠ ç®€æ´ï¼š

\index{tuple!comparison}
\index{comparison!tuple}

\begin{lstlisting}
# inside class Card:

    def __lt__(self, other):
        t1 = self.suit, self.rank
        t2 = other.suit, other.rank
        return t1 < t2
\end{lstlisting}

%
%ğŸ% As an exercise, write an \verb"__lt__" method for Time objects.  You
%ğŸ% can use tuple comparison, but you also might consider
%ğŸ% comparing integers.

æˆ‘ä»¬åšä¸ªç»ƒä¹ ï¼Œç¼–å†™ä¸€ä¸ª \li{Time} å¯¹è±¡çš„ \li{__lt__}æ–¹æ³•ã€‚
ä½ å¯ä»¥ä½¿ç”¨å…ƒç»„æ¯”è¾ƒï¼Œä¹Ÿå¯ä»¥è€ƒè™‘æ¯”è¾ƒæ•´æ•°ã€‚


%ğŸ% \section{Decks}
\section{ä¸€å‰¯ç‰Œ}

\index{list!of objects}
\index{deck, playing cards}

%ğŸ% Now that we have Cards, the next step is to define Decks.  Since a
%ğŸ% deck is made up of cards, it is natural for each Deck to contain a
%ğŸ% list of cards as an attribute.

ç°åœ¨æˆ‘ä»¬æœ‰ \li{Card} ç±»äº†ï¼Œä¸‹ä¸€æ­¥æ˜¯å®šä¹‰å®Œæ•´çš„ä¸€å‰¯ç‰Œ (Deck)äº†ã€‚
å› ä¸ºä¸€å‰¯ç‰Œç”±è®¸å¤šç‰Œç»„æˆï¼Œè‡ªç„¶åœ°æ¯ä¸€ä¸ª \li{Deck} éƒ½æœ‰ä¸€ä¸ªå¡ç‰Œåˆ—è¡¨ä½œä¸ºå±æ€§ã€‚

\index{init method}
\index{method!init}

%ğŸ% The following is a class definition for {\tt Deck}.  The
%ğŸ% init method creates the attribute {\tt cards} and generates
%ğŸ% the standard set of fifty-two cards:

ä¸‹é¢æ˜¯ä¸€ä¸ª \li{Deck} çš„ç±»å®šä¹‰ã€‚
åˆå§‹åŒ–æ–¹æ³•åˆ›å»ºäº† \li{cards} å±æ€§ï¼Œ ç„¶åç”Ÿæˆäº†ç”± 52 å¼ ç‰Œç»„æˆä¸€å‰¯æ ‡å‡†å¡ç‰Œã€‚

\index{composition}  \index{loop!nested}
\index{Deck class}  \index{class!Deck}

\begin{lstlisting}
class Deck:

    def __init__(self):
        self.cards = []
        for suit in range(4):
            for rank in range(1, 14):
                card = Card(suit, rank)
                self.cards.append(card)
\end{lstlisting}

%ğŸ% %
%ğŸ% The easiest way to populate the deck is with a nested loop.  The outer
%ğŸ% loop enumerates the suits from 0 to 3.  The inner loop enumerates the
%ğŸ% ranks from 1 to 13.  Each iteration
%ğŸ% creates a new Card with the current suit and rank,
%ğŸ% and appends it to {\tt self.cards}.

ç”Ÿæˆä¸€å‰¯ç‰Œçš„æœ€ç®€å•æ–¹æ³•æ˜¯ä½¿ç”¨åµŒå¥—å¾ªç¯ã€‚
å¤–å±‚å¾ªç¯æšä¸¾ 0 åˆ° 3 çš„èŠ±è‰²ã€‚
å†…å±‚å¾ªç¯æšä¸¾ 1 åˆ° 13 çš„ç­‰çº§ã€‚
æ¯ä¸€ä¸ªè¿­ä»£éƒ½ç”¨å½“å‰çš„èŠ±è‰²å’Œç­‰çº§åˆ›å»ºä¸€å¼ æ–°çš„ç‰Œã€‚
ç„¶åæ”¾å…¥ \li{self.cards} ä¸­ã€‚

\index{append method}
\index{method!append}


%ğŸ% \section{Printing the deck}
\section{æ‰“å°ä¸€å‰¯ç‰Œ}

\label{printdeck}
\index{str method@\_\_str\_\_ method}
\index{method!\_\_str\_\_}

%ğŸ% Here is a \verb"__str__" method for {\tt Deck}:

ä¸‹é¢æ˜¯ä¸º \li{Deck} å®šä¹‰çš„ \li{__str__} æ–¹æ³•ï¼š

\begin{lstlisting}
#inside class Deck:

    def __str__(self):
        res = []
        for card in self.cards:
            res.append(str(card))
        return '\n'.join(res)
\end{lstlisting}

%
%ğŸ% This method demonstrates an efficient way to accumulate a large
%ğŸ% string: building a list of strings and then using the string method
%ğŸ% {\tt join}.  The built-in function {\tt str} invokes the
%ğŸ% \verb"__str__" method on each card and returns the string
%ğŸ% representation.

è¿™ä¸ªæ–¹æ³•å±•ç¤ºäº†ç´¯ç§¯å¤§å­—ç¬¦ä¸²çš„é«˜æ•ˆæ–¹æ³•ï¼šå»ºç«‹ä¸€ä¸ªå­—ç¬¦ä¸²åˆ—è¡¨ç„¶åä½¿ç”¨å­—ç¬¦ä¸²æ–¹æ³• \li{join}ã€‚
å†…å»ºå‡½æ•° \li{str} ä¼šè°ƒç”¨æ¯ä¸ªå¡ç‰Œä¸Šçš„ \li{__str__} æ–¹æ³•ï¼Œå¹¶è¿”å›å®ƒä»¬çš„å­—ç¬¦ä¸²è¡¨ç¤ºã€‚

\index{accumulator!string} \index{string!accumulator}
\index{join method} \index{method!join} \index{newline}

%ğŸ% Since we invoke {\tt join} on a newline character, the cards
%ğŸ% are separated by newlines.  Here's what the result looks like:

ç”±äºæˆ‘ä»¬æ˜¯åœ¨ä¸€ä¸ªæ¢è¡Œç¬¦ä¸Šè°ƒç”¨çš„ \li{join} ï¼Œå¡ç‰Œä¹‹é—´è¢«æ¢è¡Œç¬¦åˆ†éš”ã€‚  ä¸‹é¢æ˜¯ç»“æœç¤ºä¾‹ï¼š

\begin{lstlisting}
>>> deck = Deck()
>>> print(deck)
Ace of Clubs
2 of Clubs
3 of Clubs
...
10 of Spades
Jack of Spades
Queen of Spades
King of Spades
\end{lstlisting}

%
%ğŸ% Even though the result appears on 52 lines, it is
%ğŸ% one long string that contains newlines.

è™½ç„¶è¿™ä¸ªç»“æœæœ‰52è¡Œï¼Œä½†ä»–å®é™…ä¸Šæ˜¯åŒ…å«æ¢è¡Œç¬¦çš„ä¸€ä¸ªé•¿å­—ç¬¦ä¸²ã€‚

%ğŸ% \section{Add, remove, shuffle and sort}
\section{æ·»åŠ ï¼Œç§»é™¤ï¼Œæ´—ç‰Œå’Œæ’åº}

%ğŸ% To deal cards, we would like a method that
%ğŸ% removes a card from the deck and returns it.
%ğŸ% The list method {\tt pop} provides a convenient way to do that:

ä¸ºäº†å‘ç‰Œï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªå¯ä»¥æŠŠå¡ç‰Œä»ä¸€å‰¯ç‰Œä¸­ç§»é™¤å¹¶è¿”å›çš„æ–¹æ³•ã€‚
åˆ—è¡¨çš„ \li{pop} æ–¹æ³•æä¾›äº†ä¸€ä¸ªä¾¿æ·çš„å®ç°ï¼š

\index{pop method}
\index{method!pop}

\begin{lstlisting}
#inside class Deck:

    def pop_card(self):
        return self.cards.pop()
\end{lstlisting}

%ğŸ% %
%ğŸ% Since {\tt pop} removes the {\em last} card in the list, we are
%ğŸ% dealing from the bottom of the deck.

ç”±äº \li{pop} ç§»é™¤åˆ—è¡¨çš„ {\bf æœ€åä¸€å¼ } å¡ç‰Œï¼Œæ‰€ä»¥æˆ‘ä»¬ä»ç‰Œåº•å¼€å§‹å‘ç‰Œã€‚

\index{append method}
\index{method!append}

%ğŸ% To add a card, we can use the list method {\tt append}:

\begin{lstlisting}
#inside class Deck:

    def add_card(self, card):
        self.cards.append(card)
\end{lstlisting}

%ğŸ% %
%ğŸ% A method like this that uses another method without doing
%ğŸ% much work is sometimes called a {\bf veneer}.  The metaphor
%ğŸ% comes from woodworking, where a veneer is a thin
%ğŸ% layer of good quality wood glued to the surface of a cheaper piece of
%ğŸ% wood to improve the appearance.

åƒä¸Šé¢è¿™æ ·åˆ©ç”¨åˆ«çš„æ–¹æ³• (method)ï¼Œè‡ªå·±å´æ²¡æœ‰åšå¤ªå¤šå¤„ç†çš„æ–¹æ³•ï¼Œ
æœ‰æ—¶å€™è¢«ç§°ä¸º {\em ä¼ªè£…æ–¹æ³•} (veneer)ã€‚
è¿™ä¸ªéšå–»æ¥æºäºæœ¨å·¥è¡Œä¸šï¼Œ ä»–ä»¬é€šå¸¸ç”¨ä¸€ç‰‡é«˜è´¨é‡çš„æœ¨è´¨è–„å±‚ç²˜è´´åœ¨ä¸€å—ä¾¿å®œæœ¨æçš„è¡¨é¢ï¼Œæ”¹å–„å¤–è§‚å½¢è±¡ã€‚

\index{veneer}

%ğŸ% In this case \verb"add_card" is a ``thin'' method that expresses
%ğŸ% a list operation in terms appropriate for decks.  It
%ğŸ% improves the appearance, or interface, of the
%ğŸ% implementation.

åœ¨è¿™é‡Œï¼Œ\li{add_card} æ˜¯ä¸€ä¸ª ``ç˜¦'' æ–¹æ³•ï¼Œä»¥å¡ç‰Œçš„æœ¯è¯­æ¥è¡¨è¿°ä¸€ä¸ªåˆ—è¡¨æ“ä½œã€‚
å®ƒæ”¹å–„äº†å®ç°çš„å¤–è§‚ï¼Œæˆ–è€…è¯´æ¥å£ã€‚

%ğŸ% As another example, we can write a Deck method named {\tt shuffle}
%ğŸ% using the function {\tt shuffle} from the {\tt random} module:

å†ä¸¾ä¸€ä¸ªä¾‹å­ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ \li{random} æ¨¡å—ä¸­çš„
\li{shuffle} å‡½æ•°ï¼Œç»™ \li{Deck} å†™ä¸€ä¸ªå« \li{shuffle} çš„æ–¹æ³•ã€‚

\index{random module}
\index{module!random}
\index{shuffle function}
\index{function!shuffle}

\begin{lstlisting}
# inside class Deck:

    def shuffle(self):
        random.shuffle(self.cards)
\end{lstlisting}

%ğŸ% %
%ğŸ% Don't forget to import {\tt random}.

ä¸è¦å¿˜è®°äº†å¯¼å…¥ \li{random} ã€‚

%ğŸ% As an exercise, write a Deck method named {\tt sort} that uses the
%ğŸ% list method {\tt sort} to sort the cards in a {\tt Deck}.  {\tt sort}
%ğŸ% uses the \verb"__lt__" method we defined to determine the order.

æˆ‘ä»¬åšä¸ªç»ƒä¹ ï¼Œç”¨åˆ—è¡¨çš„ \li{sort} æ–¹æ³•æ¥å†™ä¸€ä¸ª \li{Deck} çš„ \li{sort} æ–¹æ³•ï¼Œç»™å¡ç‰Œæ’åºã€‚
 \li{sort} ä½¿ç”¨æˆ‘ä»¬å®šä¹‰çš„ \li{__cmp__} æ¥å†³å®šæ’åºé¡ºåºã€‚

\index{sort method} \index{method!sort}


%ğŸ% \section{Inheritance}
\section{ç»§æ‰¿}

\index{inheritance}
\index{object-oriented programming}

%ğŸ% Inheritance is the ability to define a new class that is a modified
%ğŸ% version of an existing class.  As an example, let's say we want a
%ğŸ% class to represent a ``hand'', that is, the cards held by one player.
%ğŸ% A hand is similar to a deck: both are made up of a collection of
%ğŸ% cards, and both require operations like adding and removing cards.

ç»§æ‰¿æŒ‡çš„æ˜¯åœ¨ç°æœ‰ç±»çš„åŸºç¡€ä¸‹è¿›è¡Œä¿®æ”¹ï¼Œä»è€Œå®šä¹‰æ–°ç±»çš„èƒ½åŠ›ã€‚
ä¾‹å¦‚ï¼Œå‡è®¾æˆ‘ä»¬æƒ³å®šä¹‰ä¸€ä¸ªç±»æ¥ä»£è¡¨æ‰‹ç‰Œ (hand) ï¼Œå³ç©å®¶ç›®å‰æ‰‹é‡Œæœ‰çš„ç‰Œã€‚
æ‰‹ç‰Œä¸ä¸€å‰¯ç‰Œ (deck)ç±»ä¼¼ï¼šäºŒè€…éƒ½ç”±å¡ç‰Œç»„æˆï¼Œéƒ½è¦æ±‚æ”¯æŒæ·»åŠ å’Œç§»é™¤å¡ç‰Œçš„æ“ä½œã€‚

%ğŸ% A hand is also different from a deck; there are operations we want for
%ğŸ% hands that don't make sense for a deck.  For example, in poker we
%ğŸ% might compare two hands to see which one wins.  In bridge, we might
%ğŸ% compute a score for a hand in order to make a bid.

ä½†äºŒè€…ä¹Ÿæœ‰åŒºåˆ«ï¼›æœ‰äº›æˆ‘ä»¬å¸Œæœ›æ‰‹ç‰Œå…·å¤‡çš„æ“ä½œï¼Œå¯¹äº deck æ¥è¯´å¹¶ä¸åˆç†ã€‚
ä¾‹å¦‚ï¼Œåœ¨æ‰‘å…‹ç‰Œä¸­ï¼Œæˆ‘ä»¬å¯èƒ½éœ€è¦æ¯”è¾ƒä¸¤ä¸ªæ‰‹ç‰Œï¼Œæ¯”è¾ƒå“ªæ–¹èµ¢äº†ã€‚
åœ¨æ¡¥ç‰Œä¸­ï¼Œæˆ‘ä»¬å¯èƒ½éœ€è¦è®¡ç®—æ‰‹ç‰Œçš„å¾—åˆ†ï¼Œæ‰å¥½ä¸‹æ³¨ã€‚

%ğŸ% This relationship between classes---similar, but different---lends
%ğŸ% itself to inheritance.
%ğŸ% To define a new class that inherits from an existing class,
%ğŸ% you put the name of the existing class in parentheses:

ç±»ä¹‹é—´æœ‰ç›¸ä¼¼ä¹‹å¤„ï¼Œä½†ä¹Ÿå­˜åœ¨ä¸åŒï¼Œè¿™æ—¶å°±å¯ä»¥ç”¨ä¸Šç»§æ‰¿äº†ã€‚
ä½ åªéœ€è¦åœ¨å®šä¹‰æ–°ç±»æ—¶ï¼Œå°†ç°æœ‰ç±»çš„åç§°æ”¾åœ¨æ‹¬å·é‡Œï¼Œå³å¯ç»§æ‰¿ç°æœ‰ç±»ï¼š

\index{parentheses!parent class in}
\index{parent class}
\index{class!parent}
\index{Hand class}
\index{class!Hand}

\begin{lstlisting}
class Hand(Deck):
    """Represents a hand of playing cards."""
\end{lstlisting}

%ğŸ% %
%ğŸ% This definition indicates that {\tt Hand} inherits from {\tt Deck};
%ğŸ% that means we can use methods like \verb"pop_card" and \verb"add_card"
%ğŸ% for Hands as well as Decks.

è¿™ä¸ªå®šä¹‰è¡¨æ˜ï¼Œ\li{Hand} ç»§æ‰¿è‡ª \li{Deck} ï¼›  è¿™æ„å‘³ç€æˆ‘ä»¬ä¹Ÿå¯ä»¥å¯¹ \li{Hands} ä½¿ç”¨ \li{Deck} çš„ \li{pop_card} å’Œ \li{add_card} æ–¹æ³•ã€‚

%ğŸ% When a new class inherits from an existing one, the existing
%ğŸ% one is called the {\bf parent} and the new class is
%ğŸ% called the {\bf child}.

å½“ä¸€ä¸ªæ–°ç±»ç»§æ‰¿è‡ªä¸€ä¸ªç°æœ‰ç±»æ—¶ï¼Œç°æœ‰ç±»è¢«ç§°ä¸º {\em çˆ¶ç±»} (parent) ï¼Œæ–°ç±»è¢«ç§°ä¸º {\em å­ç±»} (child) ã€‚

\index{parent class}
\index{child class}
\index{class!child}

%ğŸ% In this example, {\tt Hand} inherits \verb"__init__" from {\tt Deck},
%ğŸ% but it doesn't really do what we want: instead of populating the hand
%ğŸ% with 52 new cards, the init method for Hands should initialize {\tt
%ğŸ%   cards} with an empty list.  \index{override} \index{init method}

åœ¨æ­¤ä¾‹ä¸­ï¼Œ \li{Hand} ç»§æ‰¿äº† \li{Deck} çš„ \li{__init__} æ–¹æ³•ï¼Œ
ä½†æ˜¯å®ƒå¹¶æ²¡æœ‰æ»¡è¶³æˆ‘ä»¬çš„è¦æ±‚ï¼šinit æ–¹æ³•åº”è¯¥ä¸º \li{Hand} åˆå§‹åŒ–ä¸€ä¸ªç©ºçš„ \li{cards}
åˆ—è¡¨ï¼Œè€Œä¸æ˜¯å¾€æ‰‹ç‰Œé‡Œæ·»åŠ  52 å¼ æ–°ç‰Œã€‚

\index{method!init}

%ğŸ% If we provide an init method in the {\tt Hand} class, it overrides the
%ğŸ% one in the {\tt Deck} class:

å¦‚æœæˆ‘ä»¬æä¾›ä¸€ä¸ª \li{Hand} çš„ init æ–¹æ³•ï¼Œå®ƒä¼šè¦†ç›–ä» \li{Deck} ç±»ç»§æ‰¿æ¥çš„åŒåæ–¹æ³•ã€‚

\begin{lstlisting}
# inside class Hand:

    def __init__(self, label=''):
        self.cards = []
        self.label = label
\end{lstlisting}

%ğŸ% %
%ğŸ% When you create a Hand, Python invokes this init method, not the
%ğŸ% one in {\tt Deck}.

å½“ä½ åˆ›å»ºä¸€ä¸ª \li{Hand} æ—¶ï¼ŒPython ä¼šè°ƒç”¨è¿™ä¸ª init æ–¹æ³•ï¼Œè€Œä¸æ˜¯ \li{Deck} ä¸­çš„åŒåæ–¹æ³•ã€‚

\begin{lstlisting}
>>> hand = Hand('new hand')
>>> hand.cards
[]
>>> hand.label
'new hand'
\end{lstlisting}

%ğŸ% %
%ğŸ% The other methods are inherited from {\tt Deck}, so we can use
%ğŸ% \verb"pop_card" and \verb"add_card" to deal a card:

å…¶å®ƒæ–¹æ³•æ˜¯ä» \li{Deck} ç»§æ‰¿æ¥çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ \li{pop_card} å’Œ
\li{add_card} æ¥å‘ç‰Œï¼š

\begin{lstlisting}
>>> deck = Deck()
>>> card = deck.pop_card()
>>> hand.add_card(card)
>>> print(hand)
King of Spades
\end{lstlisting}

%ğŸ% %
%ğŸ% A natural next step is to encapsulate this code in a method
%ğŸ% called \verb"move_cards":

å¾ˆè‡ªç„¶åœ°ï¼Œä¸‹ä¸€æ­¥å°±æ˜¯æŠŠè¿™äº›ä»£ç å°è£…è¿›ä¸€ä¸ªå« \li{move_cards} çš„æ–¹æ³•ï¼š

\index{encapsulation}

\begin{lstlisting}
#inside class Deck:

    def move_cards(self, hand, num):
        for i in range(num):
            hand.add_card(self.pop_card())
\end{lstlisting}

%ğŸ% %
%ğŸ% \verb"move_cards" takes two arguments, a Hand object and the number of
%ğŸ% cards to deal.  It modifies both {\tt self} and {\tt hand}, and
%ğŸ% returns {\tt None}.

\li{move_cards} æ¥å—ä¸¤ä¸ªå‚æ•°ï¼Œä¸€ä¸ªæ˜¯ \li{Hand} å¯¹è±¡ï¼Œå¦ä¸€ä¸ªæ˜¯å‘ç‰Œçš„æ•°é‡ã€‚
å®ƒä¼šåŒæ—¶ä¿®æ”¹ \li{self} å’Œ \li{hand} ï¼Œç„¶åè¿”å› \li{None} ã€‚

%ğŸ% In some games, cards are moved from one hand to another,
%ğŸ% or from a hand back to the deck.  You can use \verb"move_cards"
%ğŸ% for any of these operations: {\tt self} can be either a Deck
%ğŸ% or a Hand, and {\tt hand}, despite the name, can also be a {\tt Deck}.

åœ¨æœ‰äº›æ¸¸æˆé‡Œé¢ï¼Œå¡ç‰Œä»ä¸€ä¸ªæ‰‹ç‰Œç§»åŠ¨åˆ°å¦å¤–ä¸€ä¸ªæ‰‹ç‰Œï¼Œæˆ–è€…ä»æ‰‹ç‰Œé€€è¿˜åˆ°ç‰Œå †é‡Œé¢ã€‚
ä»»ä½•è¿™äº›æ“ä½œéƒ½å¯ä»¥ä½¿ç”¨ \li{move_cards} ï¼š \li{self} å¯ä»¥æ˜¯ä¸€ä¸ª \li{Deck} æˆ–è€…ä¸€ä¸ª \li{Hand} ï¼Œè€Œä¸”å°½ç®¡åå­—å« \li{hand} ï¼Œå®ƒä¹Ÿå¯ä»¥æ˜¯ä¸€ä¸ª \li{Deck} ã€‚

%ğŸ% Inheritance is a useful feature.  Some programs that would be
%ğŸ% repetitive without inheritance can be written more elegantly
%ğŸ% with it.  Inheritance can facilitate code reuse, since you can
%ğŸ% customize the behavior of parent classes without having to modify
%ğŸ% them.  In some cases, the inheritance structure reflects the natural
%ğŸ% structure of the problem, which makes the design easier to
%ğŸ% understand.

ç»§æ‰¿æ˜¯ä¸€ä¸ªéå¸¸æœ‰ç”¨çš„ç‰¹æ€§ã€‚æœ‰äº†ç»§æ‰¿ï¼Œä¸€äº›é‡å¤æ€§çš„ä»£ç å¯ä»¥å†™å¾—éå¸¸çš„ä¼˜é›…ã€‚
ç»§æ‰¿æœ‰åŠ©äºä»£ç é‡ç”¨ï¼Œå› ä¸ºä½ å¯ä»¥åœ¨ä¸ä¿®æ”¹çˆ¶ç±»å®šä¹‰çš„å‰æä¸‹ï¼Œå°±æ”¹å˜çˆ¶ç±»çš„è¡Œä¸ºã€‚
åœ¨æœ‰äº›æƒ…å†µä¸‹ï¼Œç»§æ‰¿çš„ç»“æ„åæ˜ äº†çœŸå®é—®é¢˜çš„ç»“æ„ï¼Œä½¿å¾—ç¨‹åºæ›´æ˜“äºç†è§£ã€‚

%ğŸ% On the other hand, inheritance can make programs difficult to read.
%ğŸ% When a method is invoked, it is sometimes not clear where to find its
%ğŸ% definition.  The relevant code may be spread across several modules.
%ğŸ% Also, many of the things that can be done using inheritance can be
%ğŸ% done as well or better without it.

å¦ä¸€æ–¹é¢ï¼Œç»§æ‰¿åˆæœ‰å¯èƒ½ä¼šä½¿å¾—ç¨‹åºæ›´åŠ éš¾è¯»ã€‚
å½“è°ƒç”¨ä¸€ä¸ªæ–¹æ³•æ—¶ï¼Œæœ‰æ—¶å€™æä¸æ¸…æ¥šå»å“ªæ‰¾å®ƒçš„å®šä¹‰ã€‚
ç›¸å…³çš„ä»£ç å¯èƒ½è¢«åˆ†æ•£åœ¨å‡ ä¸ªæ¨¡å—ä¹‹ä¸­ã€‚
è€Œä¸”ï¼Œè®¸å¤šç”¨ç»§æ‰¿èƒ½å®Œæˆçš„äº‹æƒ…ï¼Œä¸ç”¨ç»§æ‰¿ä¹Ÿå¯ä»¥å®Œæˆï¼Œæœ‰å¯èƒ½è¿˜å®Œæˆå¾—æ›´å¥½ã€‚

%ğŸ% \section{Class diagrams}
\section{ç±»å›¾}
\label{class.diagram}

%ğŸ% So far we have seen stack diagrams, which show the state of
%ğŸ% a program, and object diagrams, which show the attributes
%ğŸ% of an object and their values.  These diagrams represent a snapshot
%ğŸ% in the execution of a program, so they change as the program
%ğŸ% runs.

åˆ°ç›®å‰ä¸ºæ­¢æˆ‘ä»¬å·²ç»äº†è§£è¿‡æ ˆå›¾ï¼Œå®ƒæ˜¾ç¤ºçš„æ˜¯ä¸€ä¸ªç¨‹åºçš„çŠ¶æ€ï¼›
ä»¥åŠå¯¹è±¡å›¾ï¼Œå®ƒæ˜¾ç¤ºçš„æ˜¯ä¸€ä¸ªå¯¹è±¡çš„å±æ€§åŠå…¶å€¼ã€‚
è¿™äº›å›¾ä»£è¡¨äº†ç¨‹åºæ‰§è¡Œä¸­çš„ä¸€ä¸ªå¿«ç…§ï¼Œæ‰€ä»¥å®ƒä»¬éšç€ç¨‹åºçš„è¿è¡Œè€Œå˜åŒ–ã€‚

%ğŸ% They are also highly detailed; for some purposes, too
%ğŸ% detailed.  A class diagram is a more abstract representation
%ğŸ% of the structure of a program.  Instead of showing individual
%ğŸ% objects, it shows classes and the relationships between them.

å®ƒä»¬ä¹Ÿååˆ†çš„è¯¦ç»†ï¼›ä½†æœ‰äº›æ—¶å€™æ˜¾å¾—è¿‡äºè¯¦ç»†äº†ã€‚
ç±»å›¾æ˜¯ç¨‹åºç»“æ„çš„ä¸€ç§æ›´åŠ æŠ½è±¡çš„è¡¨è¾¾ã€‚
å®ƒæ˜¾ç¤ºçš„æ˜¯ç±»å’Œç±»ä¹‹é—´çš„å…³ç³»ï¼Œè€Œä¸æ˜¯æ¯ä¸ªç‹¬ç«‹çš„å¯¹è±¡ã€‚

%ğŸ% There are several kinds of relationship between classes:

ç±»ä¹‹é—´æœ‰å¦‚ä¸‹å‡ ç§å…³ç³»ï¼š

\begin{itemize}

%ğŸ% \item Objects in one class might contain references to objects
%ğŸ% in another class.  For example, each Rectangle contains a reference
%ğŸ% to a Point, and each Deck contains references to many Cards.
%ğŸ% This kind of relationship is called {\bf HAS-A}, as in, ``a Rectangle
%ğŸ% has a Point.''

\item ä¸€ä¸ªç±»ä¸­çš„å¯¹è±¡å¯ä»¥åŒ…å«å¯¹å¦å¤–ä¸€ä¸ªç±»çš„å¯¹è±¡çš„å¼•ç”¨ã€‚
ä¾‹å¦‚ï¼Œæ¯ä¸€ä¸ªçŸ©å½¢åŒ…å«å¯¹ç‚¹çš„å¼•ç”¨ï¼Œæ¯ä¸€ä¸ª \li{Deck} åŒ…å«å¯¹è®¸å¤š \li{Card} çš„å¼•ç”¨ã€‚ è¿™ç§å…³ç³»è¢«ç§°ä¸º{\em ç»„åˆ} ({\bf HAS-A})ï¼Œå¯ä»¥ç±»ä¼¼è¿™æ ·æè¿°ï¼š``ä¸€ä¸ªçŸ©å½¢æœ‰ä¸€ä¸ªç‚¹\footnote{``a Rectangle has a Point.''}''ã€‚

%ğŸ% \item One class might inherit from another.  This relationship
%ğŸ% is called {\bf IS-A}, as in, ``a Hand is a kind of a Deck.''

\item ä¸€ä¸ªç±»å¯èƒ½ç»§æ‰¿è‡ªå¦å¤–ä¸€ä¸ªç±»ã€‚
è¿™ç§å…³ç³»è¢«ç§°ä¸º {\em ç»§æ‰¿} ({\bf IS-A})ï¼Œ å¯ä»¥ç±»ä¼¼è¿™æ ·æè¿°ï¼š``Hand is a kind of Deck''ã€‚

%ğŸ% \item One class might depend on another in the sense that objects
%ğŸ% in one class take objects in the second class as parameters, or
%ğŸ% use objects in the second class as part of a computation.  This
%ğŸ% kind of relationship is called a {\bf dependency}.

\item ä¸€ä¸ªç±»å¯èƒ½å¼ºèµ–å¦ä¸€ä¸ªç±»ï¼Œå› ä¸ºå‰è€…ä¸­çš„å¯¹è±¡æ¥å—åè€…ä¸­çš„å¯¹è±¡ä½œä¸ºå‚æ•°ï¼Œ
æˆ–è€…ä½¿ç”¨åè€…ä¸­çš„å¯¹è±¡ä½œä¸ºè®¡ç®—çš„ä¸€éƒ¨åˆ†ã€‚è¿™ç§å…³ç³»è¢«ç§°ä¸º {\em ä¾èµ–} ({\bf dependency})ã€‚

\end{itemize}

\index{IS-A relationship}
\index{HAS-A relationship}
\index{class diagram}
\index{diagram!class}

%ğŸ% A {\bf class diagram} is a graphical representation of these
%ğŸ% relationships.  For example, Figure~\ref{fig.class1} shows the
%ğŸ% relationships between {\tt Card}, {\tt Deck} and {\tt Hand}.

ç±»å›¾æ˜¯è¿™äº›å…³ç³»çš„å›¾å½¢åŒ–è¡¨ç¤ºã€‚  ä¾‹å¦‚ï¼Œå›¾~\ref{fig.class1} æ ‡æ˜äº† \li{Card} ï¼Œ \li{Deck} å’Œ
\li{Hand} ä¹‹é—´çš„å…³ç³»ã€‚

\begin{figure}
\centerline
{\includegraphics[scale=0.8]{../source/figs/class1.pdf}}
%ğŸ% \caption{Class diagram.}
\caption{ç±»å›¾ã€‚}
\label{fig.class1}
\end{figure}

%ğŸ% The arrow with a hollow triangle head represents an IS-A
%ğŸ% relationship; in this case it indicates that Hand inherits
%ğŸ% from Deck.

å¸¦ç©ºå¿ƒä¸‰è§’çš„ç®­å¤´è¡¨ç¤º IS-A çš„å…³ç³»ï¼› è¿™é‡Œå®ƒè¡¨ç¤º \li{Hand} ç»§æ‰¿è‡ª \li{Deck} ã€‚

%ğŸ% The standard arrow head represents a HAS-A
%ğŸ% relationship; in this case a Deck has references to Card
%ğŸ% objects.

æ ‡å‡†ç®­å¤´è¡¨ç¤º HAS-A çš„å…³ç³»ï¼› è¿™é‡Œè¡¨ç¤º \li{Deck} åŒ…å«å¯¹ \li{Card} å¯¹è±¡çš„å¼•ç”¨ã€‚

\index{multiplicity (in class diagram)}

%ğŸ% The star ({\tt *}) near the arrow head is a
%ğŸ% {\bf multiplicity}; it indicates how many Cards a Deck has.
%ğŸ% A multiplicity can be a simple number, like {\tt 52}, a range,
%ğŸ% like {\tt 5..7} or a star, which indicates that a Deck can
%ğŸ% have any number of Cards.

ç®­å¤´æ—è¾¹çš„æ˜Ÿå·æ˜¯ä¸€ä¸ªå¤æ•° ({\bf multiplicity})è¡¨è¾¾ï¼›
å®ƒè¡¨ç¤º \li{Deck} åŒ…å«å¤šå°‘ä¸ª \li{Card}ã€‚
ä¸€ä¸ªå¤æ•°è¡¨è¾¾å¯ä»¥æ˜¯ä¸€ä¸ªç®€å•çš„æ•°å­—(å¦‚ 52 )ï¼Œ
ä¸€ä¸ªèŒƒå›´(å¦‚ \li{5..7} æˆ–è€…æ˜¯ \li{*}ï¼Œè¡¨ç¤ºæœ‰ä»»æ„æ•°é‡çš„ \li{Card} ã€‚

%ğŸ% There are no dependencies in this diagram.  They would normally
%ğŸ% be shown with a dashed arrow.  Or if there are a lot of
%ğŸ% dependencies, they are sometimes omitted.

å›¾ä¸­æ²¡æœ‰æ ‡å‡ºä¾èµ–å…³ç³»ã€‚  è¿™ç§å…³ç³»é€šå¸¸ä½¿ç”¨è™šçº¿ç®­å¤´è¡¨ç¤ºã€‚
æˆ–è€…ï¼Œå¦‚æœæœ‰å¾ˆå¤šä¾èµ–å…³ç³»çš„è¯ï¼Œæœ‰æ—¶å€™ä¼šçœç•¥ã€‚

%ğŸ% A more detailed diagram might show that a Deck actually
%ğŸ% contains a {\em list} of Cards, but built-in types
%ğŸ% like list and dict are usually not included in class diagrams.

ä¸€ä¸ªæ›´è¯¦ç»†çš„ç±»å›¾å¯èƒ½ä¼šæ˜¾ç¤º \li{Deck} å®é™…åŒ…å«äº†ä¸€ä¸ªç”± \li{Cards} ç»„æˆçš„åˆ—è¡¨ï¼Œä½†æ˜¯é€šå¸¸ç±»å›¾ä¸­ä¸ä¼šåŒ…å« \li{list} å’Œ \li{dict} ç­‰å†…å»ºç±»å‹ã€‚


%ğŸ% \section{Data encapsulation}
\section{æ•°æ®å°è£…}

%ğŸ% The previous chapters demonstrate a development plan we might call
%ğŸ% ``object-oriented design''.  We identified objects we needed---like
%ğŸ% {\tt Point}, {\tt Rectangle} and {\tt Time}---and defined classes to
%ğŸ% represent them.  In each case there is an obvious correspondence
%ğŸ% between the object and some entity in the real world (or at least a
%ğŸ% mathematical world).

å‰é¢å‡ ç« ä¸­æè¿°äº†ä¸€ç§å¯ä»¥ç§°ä¸º ``é¢å‘å¯¹è±¡è®¾è®¡'' çš„å¼€å‘è®¡åˆ’ã€‚
æˆ‘ä»¬ç¡®å®šæ‰€éœ€è¦çš„å¯¹è±¡ --- å¦‚ \li{Point}ã€ \li{Rectangle} å’Œ \li{Time} --- ç„¶åå®šä¹‰ä»£è¡¨å®ƒä»¬çš„ç±»ã€‚
å¯¹äºæ¯ä¸ªç±»æ¥è¯´ï¼Œè¿™ä¸ªç±»å¯¹è±¡å’ŒçœŸå®ä¸–ç•Œ(æˆ–è‡³å°‘æ˜¯æ•°å­¦ä¸–ç•Œ)ä¸­çš„æŸç§å®ä½“å…·æœ‰æ˜æ˜¾çš„å¯¹åº”å…³ç³»ã€‚

\index{development plan!data encapsulation}

%ğŸ% But sometimes it is less obvious what objects you need
%ğŸ% and how they should interact.  In that case you need a different
%ğŸ% development plan.  In the same way that we discovered function
%ğŸ% interfaces by encapsulation and generalization, we can discover
%ğŸ% class interfaces by {\bf data encapsulation}.

ä½†æ˜¯æœ‰æ—¶æœ‰å¾ˆéš¾ç•Œå®šä½ éœ€è¦çš„å¯¹è±¡ä»¥åŠå®ƒä»¬å¦‚ä½•äº¤äº’ã€‚
åœ¨è¿™ä¸ªæ—¶å€™ï¼Œ ä½ éœ€è¦ä¸€ä¸ªä¸åŒçš„å¼€å‘è®¡åˆ’ã€‚
ä¹‹å‰æˆ‘ä»¬é€šè¿‡å°è£…å’Œæ³›åŒ–æ¥ç¼–å†™å‡½æ•°æ¥å£ï¼Œ æˆ‘ä»¬åŒæ ·å¯ä»¥é€šè¿‡ {\em æ•°æ®å°è£…} æ¥ç¼–å†™ç±»æ¥å£ã€‚

\index{data encapsulation}

%ğŸ% Markov analysis, from Section~\ref{markov}, provides a good example.
%ğŸ% If you download my code from \url{http://thinkpython2.com/code/markov.py},
%ğŸ% you'll see that it uses two global variables---\verb"suffix_map" and
%ğŸ% \verb"prefix"---that are read and written from several functions.

\ref{markov}~èŠ‚ ä¸­ä»‹ç»çš„é©¬å°”ç§‘å¤«åˆ†æå°±æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„ä¾‹å­ã€‚
å¦‚æœä½ ä¸‹è½½æˆ‘çš„\href{http://thinkpython2.com/code/markov.py}{ä»£ç }ï¼Œ ä½ ä¼šå‘ç°å®ƒä½¿ç”¨äº†ä¸¤ä¸ªå…¨å±€å˜é‡ â€”â€” \li{suffix_map} å’Œ \li{prefix}ï¼Œ å®ƒä»¬è¢«å¤šä¸ªå‡½æ•°è¿›è¡Œè¯»å†™ã€‚

\begin{lstlisting}
suffix_map = {}
prefix = ()
\end{lstlisting}

%ğŸ% Because these variables are global, we can only run one analysis at a
%ğŸ% time.  If we read two texts, their prefixes and suffixes would be
%ğŸ% added to the same data structures (which makes for some interesting
%ğŸ% generated text).

å› ä¸ºè¿™äº›å˜é‡æ˜¯å…¨å±€çš„ï¼Œæˆ‘ä»¬ä¸€æ¬¡åªèƒ½è¿è¡Œä¸€ä¸ªåˆ†æã€‚å¦‚æœæˆ‘ä»¬è¯»å–äº†ä¸¤ä¸ªæ–‡æœ¬ï¼Œ
å®ƒä»¬çš„å‰ç¼€å’Œåç¼€ä¼šè¢«åŠ å…¥ç›¸åŒçš„æ•°æ®ç»“æ„(ä¼šä½¿å¾—è¾“å‡ºæ–‡æœ¬æ··ä¹±)ã€‚

%ğŸ% To run multiple analyses, and keep them separate, we can encapsulate
%ğŸ% the state of each analysis in an object.
%ğŸ% Here's what that looks like:

å¦‚æœæƒ³åŒæ—¶è¿è¡Œå¤šä¸ªåˆ†æï¼Œå¹¶ä¸”ä¿æŒå®ƒä»¬çš„ç›¸äº’ç‹¬ç«‹ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠæ¯ä¸ªåˆ†æçš„çŠ¶æ€å°è£…åˆ°ä¸€ä¸ªå¯¹è±¡ä¸­ã€‚
ä¸‹é¢æ˜¯ä¸€ä¸ªç¤ºä¾‹ï¼š

\begin{lstlisting}
class Markov:

    def __init__(self):
        self.suffix_map = {}
        self.prefix = ()
\end{lstlisting}

%ğŸ% Next, we transform the functions into methods.  For example,
%ğŸ% here's \verb"process_word":

ä¸‹ä¸€æ­¥ï¼Œæˆ‘ä»¬æŠŠè¿™äº›å‡½æ•°è½¬æ¢ä¸ºæ–¹æ³•ã€‚
ä¾‹å¦‚ï¼šä¸‹é¢æ˜¯ \li{process_word} ï¼š

\begin{lstlisting}
    def process_word(self, word, order=2):
        if len(self.prefix) < order:
            self.prefix += (word,)
            return

        try:
            self.suffix_map[self.prefix].append(word)
        except KeyError:
            # if there is no entry for this prefix, make one
            self.suffix_map[self.prefix] = [word]

        self.prefix = shift(self.prefix, word)
\end{lstlisting}

%ğŸ% Transforming a program like this---changing the design without
%ğŸ% changing the behavior---is another example of refactoring
%ğŸ% (see Section~\ref{refactoring}).

åƒè¿™æ ·æ”¹å˜ä¸€ä¸ªç¨‹åº --- æ”¹å˜è®¾è®¡è€Œä¿æŒåŠŸèƒ½ä¸å˜ --- æ˜¯ä»£ç é‡æ„çš„å¦ä¸€ä¸ªä¾‹å­
(å‚è§\ref{refactoring}~èŠ‚)ã€‚

\index{refactoring}

%ğŸ% This example suggests a development plan for designing objects and
%ğŸ% methods:

ä¸‹é¢çš„ä¾‹å­ç»™å‡ºäº†ä¸€ç§è®¾è®¡å¯¹è±¡å’Œæ–¹æ³•çš„å¼€å‘è®¡åˆ’ï¼š

\begin{enumerate}

%ğŸ% \item Start by writing functions that read and write global
%ğŸ% variables (when necessary).
%ğŸ%
%ğŸ% \item Once you get the program working, look for associations
%ğŸ% between global variables and the functions that use them.
%ğŸ%
%ğŸ% \item Encapsulate related variables as attributes of an object.
%ğŸ%
%ğŸ% \item Transform the associated functions into methods of the new
%ğŸ% class.

\item é¦–å…ˆç¼–å†™è¯»å–å…¨å±€å˜é‡çš„å‡½æ•°(å¦‚æœ‰å¿…è¦)ã€‚

\item ä¸€æ—¦ä½ è®©ç¨‹åºè·‘èµ·æ¥äº†ï¼Œå¼€å§‹æŸ¥æ‰¾å…¨å±€å˜é‡å’Œä½¿ç”¨å®ƒä»¬çš„å‡½æ•°çš„è”ç³»ã€‚

\item å°è£…ç›¸å…³çš„å˜é‡ä½œä¸ºä¸€ä¸ªå¯¹è±¡çš„å±æ€§ã€‚

\item è½¬æ¢ç›¸å…³å‡½æ•°ä¸ºæ–°ç±»çš„æ–¹æ³•ã€‚

\end{enumerate}

%ğŸ% As an exercise, download my Markov code from
%ğŸ% \url{http://thinkpython2.com/code/markov.py}, and follow the steps
%ğŸ% described above to encapsulate the global variables as attributes of a
%ğŸ% new class called {\tt Markov}.  Solution:
%ğŸ% \url{http://thinkpython2.com/code/Markov.py} (note the capital M).

æˆ‘ä»¬åšä¸ªç»ƒä¹ ï¼Œä¸‹è½½æˆ‘çš„\href{http://thinkpython2.com/code/markov.py}{é©¬å°”ç§‘å¤«åˆ†æä»£ç }ï¼Œç„¶åæŒ‰ç…§ä¸Šé¢æ‰€è¿°çš„æ­¥éª¤ï¼Œå°†å…¨å±€å˜é‡å°è£…ä¸ºæ–°ç±» \li{Markov} (æ³¨æ„Mä¸ºå¤§å†™)çš„å±æ€§ã€‚


%ğŸ% \section{Debugging}
\section{è°ƒè¯•}
\index{debugging}

%ğŸ% Inheritance can make debugging difficult because when you invoke a
%ğŸ% method on an object, it might be hard to figure out which method will
%ğŸ% be invoked.

ç»§æ‰¿ä¼šä½¿å¾—è°ƒè¯•å˜å¾—æ›´åŠ å¤æ‚ï¼Œå› ä¸ºä½ å¯èƒ½ä¸çŸ¥é“å®é™…è°ƒç”¨çš„æ˜¯å“ªä¸ªç±»çš„æ–¹æ³•ã€‚

\index{inheritance}

%ğŸ% Suppose you are writing a function that works with Hand objects.
%ğŸ% You would like it to work with all kinds of Hands, like
%ğŸ% PokerHands, BridgeHands, etc.  If you invoke a method like
%ğŸ% {\tt shuffle}, you might get the one defined in {\tt Deck},
%ğŸ% but if any of the subclasses override this method, you'll
%ğŸ% get that version instead.  This behavior is usually a good
%ğŸ% thing, but it can be confusing.

å‡è®¾ä½ åœ¨å†™ä¸€ä¸ªå¤„ç† \li{Hand} å¯¹è±¡çš„å‡½æ•°ã€‚
ä½ å¯èƒ½ä¼šæƒ³è®©å®ƒå¯ä»¥å¤„ç†æ‰€æœ‰ç§ç±»çš„ \li{Hand} ï¼Œ
å¦‚ \li{PockerHands} ï¼Œ \li{BridgeHands} ï¼Œç­‰ç­‰ã€‚
å¦‚æœä½ è°ƒç”¨ç±»ä¼¼ \li{shuffle} è¿™æ ·çš„æ–¹æ³•ï¼Œä½ å¯èƒ½ä¼šå¾—åˆ° \li{Deck} ä¸­å®šä¹‰çš„é‚£ä¸ªï¼Œ
ä½†æ˜¯å¦‚æœæœ‰ä»»ä½•ä¸€ä¸ªå­ç±»è¦†ç›–äº†è¿™ä¸ªæ–¹æ³•ã€‚ä½ å®é™…ä¸Šå¾—åˆ°çš„æ˜¯å­ç±»çš„é‚£ä¸ªæ–¹æ³•ã€‚
è¿™ä¸ªè¡Œä¸ºé€šå¸¸æ˜¯ä¸€ä»¶å¥½äº‹ï¼Œä½†æ˜¯å®¹æ˜“è®©äººæ··æ·†ã€‚

%ğŸ% Any time you are unsure about the flow of execution through your
%ğŸ% program, the simplest solution is to add print statements at the
%ğŸ% beginning of the relevant methods.  If {\tt Deck.shuffle} prints a
%ğŸ% message that says something like {\tt Running Deck.shuffle}, then as
%ğŸ% the program runs it traces the flow of execution.

åªè¦ä½ ä¸ç¡®å®šç¨‹åºçš„æ‰§è¡Œæµç¨‹ï¼Œæœ€ç®€å•çš„æ–¹æ³•æ˜¯åœ¨ç›¸å…³æ–¹æ³•çš„å¼€å§‹å¤„æ·»åŠ  \li{print} è¯­
å¥ã€‚  å¦‚æœ \li{Deck.shuffle} æ‰“å°ä¸€æ¡å¦‚åƒ \li{Running Deck.shuffle} çš„æ¶ˆæ¯ï¼Œ
é‚£ä¹ˆéšç€ç¨‹åºçš„è¿è¡Œï¼Œå®ƒä¼šè¿½è¸ªæ‰§è¡Œçš„æµç¨‹ã€‚

\index{flow of execution}

%ğŸ% As an alternative, you could use this function, which takes an
%ğŸ% object and a method name (as a string) and returns the class that
%ğŸ% provides the definition of the method:

å¦å¤–ä¸€ç§æ–¹æ³•æ˜¯ä½¿ç”¨ä¸‹é¢çš„å‡½æ•°ï¼Œå®ƒæ¥å—ä¸€ä¸ªå¯¹è±¡å’Œä¸€ä¸ªæ–¹æ³•çš„åå­—(å­—ç¬¦ä¸²æ ¼å¼)ä½œ
ä¸ºå‚æ•°ï¼Œç„¶åè¿”å›æä¾›è¿™ä¸ªæ–¹æ³•å®šä¹‰çš„ç±»ï¼š

\begin{lstlisting}
def find_defining_class(obj, meth_name):
    for ty in type(obj).mro():
        if meth_name in ty.__dict__:
            return ty
\end{lstlisting}

%ğŸ% %
%ğŸ% Here's an example:
ä¾‹å¦‚ï¼š

\begin{lstlisting}
>>> hand = Hand()
>>> find_defining_class(hand, 'shuffle')
<class 'Card.Deck'>
\end{lstlisting}

%ğŸ% %
%ğŸ% So the {\tt shuffle} method for this Hand is the one in {\tt Deck}.

æ‰€ä»¥ \li{Hand} çš„ \li{shuffle} æ–¹æ³•æ˜¯æ¥è‡ªäº \li{Deck} çš„ã€‚

\index{mro method}
\index{method!mro}
\index{method resolution order}

%ğŸ% \verb"find_defining_class" uses the {\tt mro} method to get the list
%ğŸ% of class objects (types) that will be searched for methods.  ``MRO''
%ğŸ% stands for ``method resolution order'', which is the sequence of
%ğŸ% classes Python searches to ``resolve'' a method name.

\li{find_defining_class} ä½¿ç”¨ \li{mro} æ–¹æ³•è·å¾—å°†ç±»å¯¹è±¡(ç±»å‹)çš„åˆ—è¡¨ï¼Œ
è§£é‡Šå™¨å°†ä¼šä»è¿™é‡Œä¾æ¬¡æœç´¢å“ªä¸ªç±»æä¾›äº†è¿™ä¸ªæ–¹æ³•ã€‚
``MOR'' æ˜¯ ``method resolution order''çš„ç®€ç§°ï¼Œ æŒ‡çš„æ˜¯Python ``è§£æ'' æ–¹æ³•åæ—¶å°†æœç´¢çš„ä¸€ä¸ªç±»åºåˆ—ã€‚

%ğŸ% Here's a design suggestion: when you override a method,
%ğŸ% the interface of the new method should be the same as the old.  It
%ğŸ% should take the same parameters, return the same type, and obey the
%ğŸ% same preconditions and postconditions.  If you follow this rule, you
%ğŸ% will find that any function designed to work with an instance of a
%ğŸ% parent class, like a Deck, will also work with instances of child
%ğŸ% classes like a Hand and PokerHand.


æˆ‘æä¸€ä¸ªå¯¹ç¨‹åºè®¾è®¡çš„å»ºè®®ï¼šå½“ä½ è¦†ç›–ä¸€ä¸ªæ–¹æ³•æ—¶ï¼Œæ–°æ–¹æ³•çš„æ¥å£åº”è¯¥ä¸æ—§æ–¹æ³•ä¿æŒä¸€è‡´ã€‚
å®ƒä»¬åº”è¯¥æ¥å—ç›¸åŒçš„å‚æ•°ï¼Œè¿”å›ç›¸åŒçš„ç±»å‹ï¼Œéµå®ˆç›¸åŒçš„å…ˆå†³æ¡ä»¶å’Œåç½®æ¡ä»¶ã€‚
å¦‚æœä½ éµå¾ªè¿™ä¸ªåŸåˆ™ï¼Œä½ ä¼šå‘ç°ï¼šä»»ä½•ä½ è®¾è®¡çš„å‡½æ•°ï¼Œåªè¦èƒ½ç”¨äºä¸€ä¸ªçˆ¶ç±»çš„å¯¹è±¡(
å¦‚ \li{Deck} )ï¼Œå°±èƒ½å¤Ÿç”¨äºä»»ä½•å­ç±»çš„å®ä¾‹(å¦‚ \li{Hand} å’Œ \li{PockerHand} )ã€‚

\index{override}
\index{interface}
\index{precondition}
\index{postcondition}

%ğŸ% If you violate this rule, which is called the ``Liskov substitution
%ğŸ% principle'', your code will collapse like (sorry) a house of cards.

å¦‚æœä½ è¿èƒŒè¿™æ¡è§„åˆ™(è¯¥åŸåˆ™è¢«ç§°ä¸º``é‡Œæ°ä»£æ¢åŸç†''ï¼ŒLiskov substitution
principle)ï¼Œä½ çš„ä»£ç é€»è¾‘å°±ä¼šå˜å¾—ä¹±ä¸ƒå…«ç³Ÿã€‚

\index{Liskov substitution principle}

%ğŸ% \section{Glossary}
\section{æœ¯è¯­è¡¨}

\begin{description}

%ğŸ% \item[encode:]  To represent one set of values using another
%ğŸ% set of values by constructing a mapping between them.

\item[ç¼–ç  (encode)]  åˆ©ç”¨å¦ä¸€ç»„å€¼ä»£è¡¨ä¸€ç»„å€¼ï¼Œæ–¹æ³•æ—¶æ„å»ºäºŒè€…ä¹‹é—´çš„æ˜ å°„ã€‚
\index{encode}

%ğŸ% \item[class attribute:] An attribute associated with a class
%ğŸ% object.  Class attributes are defined inside
%ğŸ% a class definition but outside any method.

\item[ç±»å±æ€§ (class attribute)]  ä¸ç±»å¯¹è±¡ç›¸å…³è”çš„å±æ€§ã€‚  ç±»å±æ€§å®šä¹‰åœ¨ç±»å®šä¹‰çš„å†…éƒ¨ï¼Œä½†åœ¨æ–¹æ³•çš„å¤–éƒ¨ã€‚
\index{class attribute}
\index{attribute!class}

%ğŸ% \item[instance attribute:] An attribute associated with an
%ğŸ% instance of a class.

\item[å®ä¾‹å±æ€§ (instance attribute)]  ä¸ç±»çš„å®ä¾‹ç›¸å…³è”çš„å±æ€§ã€‚
\index{instance attribute}
\index{attribute!instance}

%ğŸ% \item[veneer:] A method or function that provides a different
%ğŸ% interface to another function without doing much computation.

\item[ä¼ªè£…æ–¹æ³•(veneer)]  æä¾›å¦ä¸€ä¸ªå‡½æ•°çš„ä¸åŒæ¥å£ï¼Œä½†ä¸åšå¤ªå¤šè®¡ç®—çš„å‡½æ•°æˆ–æ–¹æ³•ã€‚
\index{veneer}

%ğŸ% \item[inheritance:] The ability to define a new class that is a
%ğŸ% modified version of a previously defined class.

\item[ç»§æ‰¿(inheritance)]  åœ¨æ­¤å‰å®šä¹‰çš„ç±»çš„åŸºç¡€ä¸‹è¿›è¡Œä¿®æ”¹ï¼Œä»è€Œå®šä¹‰ä¸€ä¸ªæ–°ç±»çš„èƒ½åŠ›ã€‚
\index{inheritance}

%ğŸ% \item[parent class:] The class from which a child class inherits.

\item[çˆ¶ç±»(parent class)]  å­ç±»æ‰€ç»§æ‰¿è‡ªçš„ç±»ã€‚
\index{parent class}

%ğŸ% \item[child class:] A new class created by inheriting from an
%ğŸ% existing class; also called a ``subclass''.

\item[å­ç±»(child class)]  é€šè¿‡ç»§æ‰¿ä¸€ä¸ªç°æœ‰ç±»åˆ›å»ºçš„æ–°ç±»ã€‚
\index{child class}
\index{class!child}

%ğŸ% \item[IS-A relationship:] A relationship between a child class
%ğŸ% and its parent class.

\item[IS-A å…³ç³» (IS-A relationship)]  å­ç±»å’Œçˆ¶ç±»ä¹‹é—´çš„å…³ç³»ã€‚
\index{IS-A relationship}

%ğŸ% \item[HAS-A relationship:] A relationship between two classes
%ğŸ% where instances of one class contain references to instances of
%ğŸ% the other.

\item[HAS-A å…³ç³» (HAS-A relationship)]  ä¸¤ä¸ªç±»ä¹‹ä¸­ï¼Œæœ‰ä¸€ä¸ªç±»åŒ…å«å¯¹å¦ä¸€ä¸ªç±»çš„å®ä¾‹çš„å¼•ç”¨çš„å…³ç³»ã€‚
\index{HAS-A relationship}

%ğŸ% \item[dependency:] A relationship between two classes
%ğŸ% where instances of one class use instances of the other class,
%ğŸ% but do not store them as attributes.

\item[ä¾èµ– (dependency)]  ä¸¤ä¸ªç±»ä¹‹ä¸­ï¼Œ ä¸€ä¸ªç±»çš„å®ä¾‹ä½¿ç”¨äº†å¦ä¸€ä¸ªç±»çš„å®ä¾‹ï¼Œ ä½†æ²¡æœ‰å°†å…¶ä¿å­˜ä¸ºå±æ€§çš„å…³ç³»ã€‚
\index{dependency}

%ğŸ% \item[class diagram:] A diagram that shows the classes in a program
%ğŸ% and the relationships between them.

\item[ç±»å›¾ (class diagram)] è¡¨æ˜ç¨‹åºä¸­åŒ…å«çš„ç±»åŠå…¶ä¹‹é—´çš„å…³ç³»çš„å›¾ç¤ºã€‚
\index{class diagram}
\index{diagram!class}

%ğŸ% \item[multiplicity:] A notation in a class diagram that shows, for
%ğŸ% a HAS-A relationship, how many references there are to instances
%ğŸ% of another class.

\item[å¤æ•° (multiplicity)]  ç±»å›¾ä¸­çš„ä¸€ç§æ ‡è®°ï¼Œè¡¨æ˜åœ¨ HAS-A å…³ç³»ä¸­ï¼ŒæŸä¸ªå¯¹åŒ…å«äº†å¤šå°‘ä¸ªå¯¹å¦ä¸€ä¸ªç±»å®ä¾‹çš„å¼•ç”¨ã€‚
\index{multiplicity (in class diagram)}

%ğŸ% \item[data encapsulation:]  A program development plan that
%ğŸ% involves a prototype using global variables and a final version
%ğŸ% that makes the global variables into instance attributes.

\item[æ•°æ®å°è£… (data encapsulation)]  ä¸€ç§ç¨‹åºå¼€å‘è®¡åˆ’ï¼Œ åŒ…æ‹¬é¦–å…ˆç¼–å†™ä¸€ä¸ªä½¿ç”¨å…¨å±€å˜é‡çš„åŸå‹ï¼Œ ç„¶åå†è®²å…¨å±€å˜é‡å˜æˆå®ä¾‹å±æ€§çš„æœ€ç»ˆç‰ˆä»£ç ã€‚
\index{data encapsulation}
\index{development plan!data encapsulation}

\end{description}

%ğŸ% \section{Exercises}
\section{ç»ƒä¹ }

\begin{exercise}
%ğŸ% For the following program, draw a UML class diagram that shows
%ğŸ% these classes and the relationships among them.

é’ˆå¯¹ä»¥ä¸‹ç¨‹åºï¼Œç”»ä¸€ä¸ª {\em UML} ç±»å›¾ï¼Œè¯´æ˜å…¶ä¸­åŒ…å«çš„ç±»åŠå…¶ä¹‹é—´çš„å…³ç³»ã€‚

\begin{em}
\begin{lstlisting}
class PingPongParent:
    pass

class Ping(PingPongParent):
    def __init__(self, pong):
        self.pong = pong


class Pong(PingPongParent):
    def __init__(self, pings=None):
        if pings is None:
            self.pings = []
        else:
            self.pings = pings

    def add_ping(self, ping):
        self.pings.append(ping)

pong = Pong()
ping = Ping(pong)
pong.add_ping(ping)
\end{lstlisting}
\end{em}

\end{exercise}


\begin{exercise}
%ğŸ% Write a Deck method called \verb"deal_hands" that
%ğŸ% takes two parameters, the number of hands and the number of cards per
%ğŸ% hand.  It should create the appropriate number of Hand objects, deal
%ğŸ% the appropriate number of cards per hand, and return a list of Hands.

ä¸º {\em \li{Deck}} ç¼–å†™ä¸€ä¸ªå« {\em \li{deal_hands}} çš„æ–¹æ³•ï¼Œ æ¥å—ä¸¤ä¸ªå‚æ•°ï¼š æ‰‹ç‰Œçš„æ•°é‡ä»¥åŠæ¯ä¸ªæ‰‹ç‰Œçš„å¡ç‰Œæ•°ã€‚
å®ƒåº”è¯¥åˆ›å»ºç›¸åº”æ•°é‡çš„ {\em \li{Hand}} å¯¹è±¡ï¼Œ ç»™æ¯ä¸ªæ‰‹ç‰Œå‘æ”¾ç›¸åº”æ•°é‡çš„å¡ç‰Œï¼Œ
ç„¶åè¿”å›ä¸€ä¸ª {\em \li{Hands}} åˆ—è¡¨ã€‚
\end{exercise}


\begin{exercise}
\label{poker}

%ğŸ% The following are the possible hands in poker, in increasing order
%ğŸ% of value and decreasing order of probability:

ä¸‹é¢æ˜¯æ‰‘å…‹ç‰Œä¸­å¯èƒ½çš„æ‰‹ç‰Œ {\em (} ç‰Œå‹ {\em )}ï¼Œè¶Šå¾€ä¸‹å€¼è¶Šå¤§ï¼Œå‡ ç‡è¶Šä½ï¼š
\index{poker}

\begin{description}

%ğŸ% \item[pair:] two cards with the same rank
%ğŸ% \vspace{-0.05in}
%ğŸ%
%ğŸ% \item[two pair:] two pairs of cards with the same rank
%ğŸ% \vspace{-0.05in}
%ğŸ%
%ğŸ% \item[three of a kind:] three cards with the same rank
%ğŸ% \vspace{-0.05in}
%ğŸ%
%ğŸ% \item[straight:] five cards with ranks in sequence (aces can
%ğŸ% be high or low, so {\tt Ace-2-3-4-5} is a straight and so is {\tt
%ğŸ% 10-Jack-Queen-King-Ace}, but {\tt Queen-King-Ace-2-3} is not.)
%ğŸ% \vspace{-0.05in}
%ğŸ%
%ğŸ% \item[flush:] five cards with the same suit
%ğŸ% \vspace{-0.05in}
%ğŸ%
%ğŸ% \item[full house:] three cards with one rank, two cards with another
%ğŸ% \vspace{-0.05in}
%ğŸ%
%ğŸ% \item[four of a kind:] four cards with the same rank
%ğŸ% \vspace{-0.05in}
%ğŸ%
%ğŸ% \item[straight flush:] five cards in sequence (as defined above) and
%ğŸ% with the same suit
%ğŸ% \vspace{-0.05in}

\item [å¯¹ç‰Œï¼š] ä¸¤å¼ ç›¸åŒç‰Œé¢çš„ç‰Œ

\item [ä¸¤å¯¹ç‰Œï¼š] ä¸¤å¯¹ç›¸åŒç‰Œé¢çš„ç‰Œ

\item [ä¸‰æ¡ï¼š] ä¸‰å¼ ç­‰çº§ç›¸åŒçš„ç‰Œ

\item [é¡ºå­ï¼š] äº”å¼ è¿ç»­çš„ç‰Œ {\em (A} å¯é«˜å¯ä½ã€‚  å¦‚ {\em A-2-3-4-5} æ˜¯ä¸€ä¸ªé¡ºå­, {\em 10-J-Q-K-A}ä¹Ÿæ˜¯ã€‚  ä½†æ˜¯ {\em Q-K-A-2-3} å°±ä¸æ˜¯ã€‚{\em )}

\item [åŒèŠ±ï¼š] äº”å¼ èŠ±è‰²ä¸€æ ·çš„ç‰Œ

\item [ä¸‰ä»£äºŒï¼š] ä¸‰å¼ ç­‰çº§ä¸€æ ·çš„ç‰Œï¼Œå¦å¤–ä¸¤å¼ ç­‰çº§ä¸€æ ·çš„ç‰Œ

\item [å››æ¡ï¼š] å››å¼ ç‰Œé¢ä¸€æ ·çš„ç‰Œ

\item [åŒèŠ±é¡ºï¼š] äº”å¼ èŠ±è‰²ç›¸åŒçš„ç­‰çº§è¿ç»­çš„ç‰Œ

\end{description}

%ğŸ% %
%ğŸ% The goal of these exercises is to estimate
%ğŸ% the probability of drawing these various hands.

ä¸‹é¢è¿™äº›ä¹ é¢˜çš„ç›®çš„ï¼Œæ˜¯ä¼°ç®—æŠ½åˆ°ä¸åŒæ‰‹ç‰Œçš„å‡ ç‡ã€‚

\begin{enumerate}

%ğŸ% \item Download the following files from \url{http://thinkpython2.com/code}:

\item ä»\href{http://thinkpython2.com/code}{é¡µé¢}ä¸‹è½½ä»¥ä¸‹æ–‡ä»¶ï¼š

\begin{description}

%ğŸ% \item[{\tt Card.py}]: A complete version of the {\tt Card},
%ğŸ% {\tt Deck} and {\tt Hand} classes in this chapter.

\item[{\tt Card.py}]: æœ¬ç« ä¸­å®Œæ•´ç‰ˆæœ¬çš„ {\em \li{Card} , \li{Deck}} å’Œ {\em \li{Hand}} ç±»ã€‚

%ğŸ% \item[{\tt PokerHand.py}]: An incomplete implementation of a class
%ğŸ% that represents a poker hand, and some code that tests it.

\item[{\tt PokerHand.py}]: ä»£è¡¨ poker hand çš„ä¸å®Œæ•´çš„å®ç°ï¼Œå’Œä¸€äº›æµ‹è¯•ä»£ç ã€‚

\end{description}

%ğŸ% %
%ğŸ% \item If you run {\tt PokerHand.py}, it deals seven 7-card poker hands
%ğŸ% and checks to see if any of them contains a flush.  Read this
%ğŸ% code carefully before you go on.

\item å¦‚æœä½ è¿è¡Œ {\em \li{PokerHand.py}} ,å®ƒä¼šå‘æ”¾ {\em 7} å¼ ç‰Œçš„ {\em poker hand}ï¼Œæ£€æŸ¥æ˜¯å¦å«æœ‰é¡ºå­ã€‚ä»”ç»†é˜…è¯»ä»£ç ï¼Œå†ç»§ç»­ä¸‹é¢çš„å†…å®¹ã€‚

%ğŸ% \item Add methods to {\tt PokerHand.py} named \verb"has_pair",
%ğŸ% \verb"has_twopair", etc. that return True or False according to
%ğŸ% whether or not the hand meets the relevant criteria.  Your code should
%ğŸ% work correctly for ``hands'' that contain any number of cards
%ğŸ% (although 5 and 7 are the most common sizes).

\item å†™ä¸€ä¸ªå« {\em \li{classify}} çš„æ–¹æ³•ï¼Œ è®¡ç®—å‡ºä¸€ä¸ªæ‰‹ç‰Œçš„æœ€é«˜å€¼åˆ†ç±»ï¼Œ ç„¶åè®¾ç½®å¯¹åº”çš„ {\em \li{label}} å±æ€§ã€‚  ä¾‹å¦‚ï¼Œä¸€ä¸ª {\em 7} å¼ ç‰Œçš„æ‰‹ç‰Œå¯èƒ½åŒ…å«ä¸€ä¸ªé¡ºå­å’Œä¸€ä¸ªå¯¹å­ï¼›é‚£ä¹ˆå®ƒåº”è¯¥æ ‡æ³¨ä¸º ``é¡ºå­''ã€‚

%ğŸ% \item Write a method named {\tt classify} that figures out
%ğŸ% the highest-value classification for a hand and sets the
%ğŸ% {\tt label} attribute accordingly.  For example, a 7-card hand
%ğŸ% might contain a flush and a pair; it should be labeled ``flush''.

\item ç¡®ä¿¡ä½ çš„åˆ†ç±»æ–¹æ³•æ˜¯æ­£ç¡®çš„ä¹‹åï¼Œ ä¸‹ä¸€æ­¥æ˜¯ä¼°ç®—è¿™äº›ä¸åŒæ‰‹ç‰Œå‡ºç°çš„å‡ ç‡ã€‚  åœ¨ {\em \li{PokerHand.py}} ä¸­ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œå®Œæˆæ´—ç‰Œï¼Œåˆ†ç‰Œï¼Œå¯¹ç‰Œåˆ†ç±»ï¼Œç„¶åè®°å½•æ¯ç§åˆ†ç±»å‡ºç°çš„æ¬¡æ•°ã€‚

%ğŸ% \item When you are convinced that your classification methods are
%ğŸ% working, the next step is to estimate the probabilities of the various
%ğŸ% hands.  Write a function in {\tt PokerHand.py} that shuffles a deck of
%ğŸ% cards, divides it into hands, classifies the hands, and counts the
%ğŸ% number of times various classifications appear.

\item æ‰“å°æ¯ç§åˆ†ç±»å’Œå¯¹åº”é¢‘ç‡çš„è¡¨æ ¼ã€‚  è¿è¡Œä½ çš„ç¨‹åºï¼Œ ä¸æ–­å¢åŠ æ‰‹ç‰Œçš„å¡ç‰Œæ•°é‡ï¼Œ ç›´åˆ°è¾“å‡ºçš„å€¼ä¿æŒåœ¨è¶³å¤Ÿå‡†ç¡®çš„èŒƒå›´ã€‚  å°†ä½ çš„ç»“æœå’Œ \href{http://en.wikipedia.org/wiki/Hand_rankings}{é¡µé¢}ä¸­çš„çš„å€¼è¿›è¡Œæ¯”è¾ƒã€‚

%ğŸ% \item Print a table of the classifications and their probabilities.
%ğŸ% Run your program with larger and larger numbers of hands until the
%ğŸ% output values converge to a reasonable degree of accuracy.  Compare
%ğŸ% your results to the values at \url{http://en.wikipedia.org/wiki/Hand_rankings}.

\end{enumerate}

%ğŸ% Solution: \url{http://thinkpython2.com/code/PokerHandSoln.py}.

\href{http://thinkpython2.com/code/PokerHandSoln.py}{ç­”æ¡ˆ}

\end{exercise}