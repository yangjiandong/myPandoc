

%ğŸ% \chapter{Classes and methods}
\chapter{ç±»å’Œæ–¹æ³•}

%ğŸ% Although we are using some of Python's object-oriented features,
%ğŸ% the programs from the last two chapters are not really
%ğŸ% object-oriented because they don't represent the relationships
%ğŸ% between programmer-defined types and the functions that operate
%ğŸ% on them.  The next step is to transform those functions into
%ğŸ% methods that make the relationships explicit.

è™½ç„¶æˆ‘ä»¬å·²ç»åœ¨ä½¿ç”¨éƒ¨åˆ† Python å‘å¯¹è±¡çš„ç‰¹æ€§ï¼Œ
å‰ä¸¤ä¸ªç« èŠ‚ä¸­çš„ç¨‹åºå¹¶ä¸æ˜¯çœŸæ­£é¢å‘å¯¹è±¡çš„ï¼Œ
å› ä¸ºå®ƒä»¬æ²¡æœ‰å‘ˆç°å‡ºç¨‹åºå‘˜è‡ªå®šä¹‰ç±»å‹ä¸å¯¹å…¶è¿›è¡Œæ“ä½œçš„å‡½æ•°ä¹‹é—´çš„å…³ç³»ã€‚
ä¸‹ä¸€æ­¥ï¼Œ æˆ‘ä»¬å°†ä¼šæŠŠè¿™äº›å‡½æ•°è½¬æ¢æˆæ˜æ˜¾çªå‡ºè¿™ä¸€å…³ç³»çš„æ–¹æ³•ã€‚


%ğŸ% Code examples from this chapter are available from
%ğŸ% \url{http://thinkpython2.com/code/Time2.py}, and solutions
%ğŸ% to the exercises are in \url{http://thinkpython2.com/code/Point2_soln.py}.

æœ¬ç« ä»£ç å¯ä»¥ä» \href{http://thinkpython2.com/code/Time2.py}{è¿™é‡Œ} è·å–ï¼Œ
ç»ƒä¹ é¢˜çš„ç­”æ¡ˆä½äº\href{http://thinkpython2.com/code/Point2_soln.py}{æ­¤å¤„} ã€‚


%ğŸ% \section{Object-oriented features}
\section{é¢å‘å¯¹è±¡çš„ç‰¹æ€§}
\index{object-oriented programming}  \index{é¢å‘å¯¹è±¡ç¼–ç¨‹}

%ğŸ% Python is an {\bf object-oriented programming language}, which means
%ğŸ% that it provides features that support object-oriented
%ğŸ% programming, which has these defining characteristics:

Python æ˜¯ä¸€é—¨ {\em é¢å‘å¯¹è±¡çš„ç¼–ç¨‹è¯­è¨€} (object-oriented programming language)ï¼Œ
è¿™æ„å‘³å®ƒæä¾›äº†èƒ½å¤Ÿæ”¯æŒé¢å‘å¯¹è±¡ç¼–ç¨‹çš„ç‰¹æ€§ã€‚
é¢å‘å¯¹è±¡ç¼–ç¨‹å…·æœ‰ä»¥ä¸‹ç‰¹å¾ï¼š

%ğŸ% \begin{itemize}
%ğŸ%
%ğŸ% \item Programs include class and method definitions.
%ğŸ%
%ğŸ% \item Most of the computation is expressed in terms of operations on
%ğŸ%   objects.
%ğŸ%
%ğŸ% \item Objects often represent things
%ğŸ% in the real world, and methods often
%ğŸ% correspond to the ways things in the real world interact.
%ğŸ%
%ğŸ% \end{itemize}

\begin{itemize}

\item ç¨‹åºåŒ…å«ç±»å’Œæ–¹æ³•å®šä¹‰ã€‚

\item å¤§éƒ¨åˆ†è®¡ç®—ä»¥å¯¹è±¡ä¸Šçš„æ“ä½œè¡¨ç¤ºã€‚

\item å¯¹è±¡é€šå¸¸ä»£è¡¨ç°å®ä¸–ç•Œçš„ç‰©ä½“ï¼Œ æ–¹æ³•å¯¹åº”ç°å®ä¸–ç•Œä¸­ç‰©ä½“äº¤äº’çš„æ–¹å¼ã€‚

\end{itemize}

%ğŸ% For example, the {\tt Time} class defined in Chapter~\ref{time}
%ğŸ% corresponds to the way people record the time of day, and the
%ğŸ% functions we defined correspond to the kinds of things people do with
%ğŸ% times.  Similarly, the {\tt Point} and {\tt Rectangle} classes
%ğŸ% in Chapter~\ref{clobjects}
%ğŸ% correspond to the mathematical concepts of a point and a rectangle.

ä¾‹å¦‚ï¼Œ ç¬¬~\ref{time}ç« ä¸­å®šä¹‰çš„ \li{Time} ç±»å¯¹åº”äººä»¬ç”¨æ¥è®°å½•ä¸€å¤©ä¸­çš„æ—¶é—´ï¼Œ å…¶ä¸­å®šä¹‰çš„å„ç§å‡½æ•°å¯¹åº”äººä»¬ä½¿ç”¨æ—¶é—´çš„æ–¹å¼ã€‚
ç±»ä¼¼çš„ï¼Œ ç¬¬~\ref{clobjects}ç« ä¸­çš„ \li{Point} ç±»å’Œ \li{Rectangle} ç±»å¯¹åº”æ•°å­¦ä¸­ç‚¹å’ŒçŸ©å½¢çš„æ¦‚å¿µã€‚

%ğŸ% So far, we have not taken advantage of the features Python provides to
%ğŸ% support object-oriented programming.  These
%ğŸ% features are not strictly necessary; most of them provide
%ğŸ% alternative syntax for things we have already done.  But in many cases,
%ğŸ% the alternative is more concise and more accurately conveys the
%ğŸ% structure of the program.

åˆ°ç›®å‰ä¸ºæ­¢ï¼Œ æˆ‘ä»¬è¿˜æ²¡æœ‰åˆ©ç”¨Pythonæä¾›çš„æ”¯æŒé¢å‘å¯¹è±¡ç¼–ç¨‹çš„ç‰¹æ€§ã€‚
è¿™äº›ç‰¹æ€§ä¸¥æ ¼æ¥è¯´å¹¶ä¸æ˜¯å¿…é¡»çš„ï¼›å¤§éƒ¨åˆ†æä¾›çš„æ˜¯æˆ‘ä»¬å·²ç»å®ç°çš„åŠŸèƒ½çš„æ›¿ä»£è¯­æ³•ã€‚
ä½†åœ¨å¾ˆå¤šæƒ…å†µä¸‹ï¼Œ è¿™äº›æ›¿ä»£è¯­æ³•æ›´åŠ ç®€æ´ï¼Œ æ›´å‡†ç¡®åœ°è¡¨è¾¾äº†ç¨‹åºçš„ç»“æ„ã€‚

%ğŸ% For example, in {\tt Time1.py} there is no obvious
%ğŸ% connection between the class definition and the function definitions
%ğŸ% that follow.  With some examination, it is apparent that every function
%ğŸ% takes at least one {\tt Time} object as an argument.
%ğŸ% \index{method}
%ğŸ% \index{function}

ä¾‹å¦‚ï¼Œ åœ¨ \li{Time1.py} ä¸­ï¼Œ ç±»å®šä¹‰ä¸ä¹‹åçš„å‡½æ•°å®šä¹‰ä¹‹é—´æ²¡æœ‰æ˜æ˜¾çš„è”ç³»ã€‚
ä»”ç»†æ£€æŸ¥ä¹‹åï¼Œ æ‰ä¼šå‘ç°æ¯ä¸ªå‡½æ•°éƒ½è‡³å°‘æ¥å—ä¸€ä¸ª \li{Time} å¯¹è±¡ä½œä¸ºå‚æ•°ã€‚

%ğŸ% This observation is the motivation for {\bf methods}; a method is
%ğŸ% a function that is associated with a particular class.
%ğŸ% We have seen methods for strings, lists, dictionaries and tuples.
%ğŸ% In this chapter, we will define methods for programmer-defined types.

ä»è¿™ä¸ªè§‚å¯Ÿä¸­æˆ‘ä»¬å‘ç°äº† {\em æ–¹æ³•} ï¼› æ–¹æ³•æ˜¯ä¸€ä¸ªä¸ç‰¹å®šçš„ç±»ç›¸å…³è”çš„å‡½æ•°ã€‚
æˆ‘ä»¬å·²ç»æ¥è§¦äº†å­—ç¬¦ä¸²ã€åˆ—è¡¨ã€å­—å…¸å’Œå…ƒç»„çš„æ–¹æ³•ã€‚
åœ¨è¿™ç« ä¸­ï¼Œ æˆ‘ä»¬å°†ä¼šå®šä¹‰ç¨‹åºå‘˜è‡ªå®šä¹‰ç±»å‹çš„æ–¹æ³•ã€‚

\index{syntax}
\index{semantics}
\index{programmer-defined type}
\index{type!programmer-defined}

%ğŸ% Methods are semantically the same as functions, but there are
%ğŸ% two syntactic differences:

æ–¹æ³•å’Œå‡½æ•°çš„è¯­ä¹‰ç›¸åŒï¼Œ ä½†æ˜¯æœ‰ä¸¤å¤„å¥æ³•çš„ä¸åŒï¼š

%ğŸ% \begin{itemize}
%ğŸ%
%ğŸ% \item Methods are defined inside a class definition in order
%ğŸ% to make the relationship between the class and the method explicit.
%ğŸ%
%ğŸ% \item The syntax for invoking a method is different from the
%ğŸ% syntax for calling a function.
%ğŸ%
%ğŸ% \end{itemize}

\begin{itemize}

\item æ–¹æ³•åœ¨ä¸€ä¸ªç±»å®šä¹‰å†…éƒ¨å£°æ˜ï¼Œ ä¸ºçš„æ˜¯æ˜¾ç¤ºåœ°ä¸ç±»è¿›è¡Œå…³è”ã€‚

\item è°ƒç”¨æ–¹æ³•çš„è¯­æ³•å’Œè°ƒç”¨å‡½æ•°çš„è¯­æ³•ä¸åŒã€‚

\end{itemize}

%ğŸ% In the next few sections, we will take the functions from the previous
%ğŸ% two chapters and transform them into methods.  This transformation is
%ğŸ% purely mechanical; you can do it by following a sequence of
%ğŸ% steps.  If you are comfortable converting from one form to another,
%ğŸ% you will be able to choose the best form for whatever you are doing.

åœ¨æ¥ä¸‹æ¥çš„å‡ èŠ‚ä¸­ï¼Œ  æˆ‘ä»¬ä¼šæŠŠå‰é¢ä¸¤ç« ä¸­çš„å‡½æ•°è½¬åŒ–ä¸ºæ–¹æ³•ã€‚
è¿™ä¸ªè½¬åŒ–æ˜¯çº¯æœºæ¢°å¼çš„ï¼› ä½ å¯ä»¥é€šè¿‡ä¸€ç³»åˆ—æ­¥éª¤å®Œæˆã€‚
å¦‚æœä½ èƒ½å¤Ÿè½»æ¾åœ°å°†ä¸€ç§å½¢å¼è½¬æ¢æˆå¦ä¸€ç§å½¢å¼ï¼Œ  å°±å¯ä»¥é€‰æ‹©æœ€é€‚åˆç›®å‰éœ€æ±‚çš„å½¢å¼ã€‚

%ğŸ% \section{Printing objects}
\section{æ‰“å°å¯¹è±¡ }
\index{object!printing}

%ğŸ% In Chapter~\ref{time}, we defined a class named
%ğŸ% {\tt Time} and in Section~\ref{isafter}, you
%ğŸ% wrote a function named \verb"print_time":

åœ¨ç¬¬16ç« ä¸­ï¼Œ æˆ‘ä»¬å®šä¹‰äº†ä¸€ä¸ªåå« \li{Time} çš„ç±»ï¼Œ  åœ¨ \ref{isafter}~èŠ‚ä¸­ï¼Œ
ä½ ç¼–å†™äº†ä¸€ä¸ªå«åš \li{print_time} çš„å‡½æ•°ï¼š

\begin{lstlisting}
class Time:
    """Represents the time of day."""

def print_time(time):
    print('%.2d:%.2d:%.2d' % (time.hour, time.minute, time.second))
\end{lstlisting}

%ğŸ% %
%ğŸ% To call this function, you have to pass a {\tt Time} object as an
%ğŸ% argument:

æƒ³è¦è°ƒç”¨è¿™ä¸ªå‡½æ•°ï¼Œ ä½ å¿…é¡»æŠŠä¸€ä¸ª \li{Time} å¯¹è±¡ä½œä¸ºä¸€ä¸ªå‚æ•°ä¼ é€’ç»™å‡½æ•°ã€‚

\begin{lstlisting}
>>> start = Time()
>>> start.hour = 9
>>> start.minute = 45
>>> start.second = 00
>>> print_time(start)
09:45:00
\end{lstlisting}

%ğŸ% %
%ğŸ% To make \verb"print_time" a method, all we have to do is
%ğŸ% move the function definition inside the class definition.  Notice
%ğŸ% the change in indentation.

å°† \li{print_time} å˜æˆä¸€ä¸ªæ–¹æ³•ï¼Œ æˆ‘ä»¬åªéœ€è¦å°†å‡½æ•°å®šä¹‰ç§»åˆ°ç±»å®šä¹‰é‡Œé¢å³å¯ã€‚  æ³¨æ„ç¼©è¿›
çš„å˜åŒ–ã€‚
\index{indentation}  \index{ç¼©è¿›}

\begin{lstlisting}
class Time:
    def print_time(time):
        print('%.2d:%.2d:%.2d' % (time.hour, time.minute, time.second))
\end{lstlisting}

%ğŸ% %
%ğŸ% Now there are two ways to call \verb"print_time".  The first
%ğŸ% (and less common) way is to use function syntax:

ç°åœ¨æœ‰ä¸¤ç§æ–¹æ³•å¯ä»¥è°ƒç”¨ \li{print_time}ã€‚   ç¬¬ä¸€ç§(ä¹Ÿæ˜¯ä¸å¸¸ç”¨çš„)æ˜¯ä½¿ç”¨å‡½æ•°çš„è¯­æ³•ï¼š
\index{function syntax}  \index{dot notation}

\begin{lstlisting}
>>> Time.print_time(start)
09:45:00
\end{lstlisting}

%ğŸ% %
%ğŸ% In this use of dot notation, {\tt Time} is the name of the class,
%ğŸ% and \verb"print_time" is the name of the method.  {\tt start} is
%ğŸ% passed as a parameter.

åœ¨è¿™ä¸ªç‚¹æ ‡è®°æ³•çš„ç”¨æ³•ä¸­ï¼Œ  \li{Time} æ˜¯ç±»çš„åå­—ï¼Œ \li{print_time} æ˜¯æ–¹æ³•çš„åå­—ã€‚
\li{start} æ˜¯ä¼ é€’çš„å‚æ•°ã€‚

%ğŸ% The second (and more concise) way is to use method syntax:
ç¬¬äºŒç§è¯­æ³•(ä¹Ÿæ›´ç®€æ´)æ˜¯ä½¿ç”¨æ–¹æ³•è¯­æ³•ï¼š
\index{method syntax}

\begin{lstlisting}
>>> start.print_time()
09:45:00
\end{lstlisting}

%ğŸ% %
%ğŸ% In this use of dot notation, \verb"print_time" is the name of the
%ğŸ% method (again), and {\tt start} is the object the method is
%ğŸ% invoked on, which is called the {\bf subject}.  Just as the
%ğŸ% subject of a sentence is what the sentence is about, the subject
%ğŸ% of a method invocation is what the method is about.
åœ¨è¿™ä¸ªç‚¹æ ‡è®°æ³•çš„ç”¨æ³•ä¸­ï¼Œ \li{print_time} æ˜¯æ–¹æ³•çš„åç§°ï¼Œ
ç„¶å \li{start} æ˜¯è°ƒç”¨æ–¹æ³•çš„å¯¹è±¡ï¼Œ è¢«ç§°ä¸º {\bf ä¸»è¯­}({\bf subject})ã€‚
å°±åƒä¸€ä¸ªå¥å­çš„ä¸»è¯­æ˜¯å¥å­çš„æ ¸å¿ƒï¼Œ æ–¹æ³•çš„ä¸»è¯­ä¹Ÿæ˜¯æ–¹æ³•ä½œç”¨çš„ä¸»è¦å¯¹è±¡ã€‚
\index{subject}

%ğŸ% Inside the method, the subject is assigned to the first
%ğŸ% parameter, so in this case {\tt start} is assigned
%ğŸ% to {\tt time}.
åœ¨æ–¹æ³•ä¸­ï¼Œ ä¸»è¯­è¢«èµ‹å€¼ä¸ºç¬¬ä¸€ä¸ªå‚æ•°ï¼Œ æ‰€ä»¥åœ¨è¿™é‡Œ \li{start} è¢«èµ‹å€¼ç»™ \li{time} ä¸Šäº†ã€‚
\index{self (parameter name)}  \index{parameter!self}

%ğŸ% By convention, the first parameter of a method is
%ğŸ% called {\tt self}, so it would be more common to write
%ğŸ% \verb"print_time" like this:

æ ¹æ®çº¦å®šï¼Œ æ–¹æ³•çš„ç¬¬ä¸€ä¸ªå‚æ•°å†™ä½œ \li{self} ï¼Œ æ‰€ä»¥ \li{print_time} å†™æˆè¿™æ ·æ›´å¸¸è§ï¼š

\begin{lstlisting}
class Time:
    def print_time(self):
        print('%.2d:%.2d:%.2d' % (self.hour, self.minute, self.second))
\end{lstlisting}

%
%ğŸ% The reason for this convention is an implicit metaphor:
ä½¿ç”¨è¯¥çº¦å®šåŸå› åœ¨äºä¸€ç§æš—å–»ï¼š
\index{metaphor, method invocation}

%ğŸ% \begin{itemize}
%ğŸ%
%ğŸ% \item The syntax for a function call, \verb"print_time(start)",
%ğŸ%   suggests that the function is the active agent.  It says something
%ğŸ%   like, ``Hey \verb"print_time"!  Here's an object for you to print.''
%ğŸ%
%ğŸ% \item In object-oriented programming, the objects are the active
%ğŸ%   agents.  A method invocation like \verb"start.print_time()" says
%ğŸ%   ``Hey {\tt start}!  Please print yourself.''
%ğŸ%
%ğŸ% \end{itemize}

\begin{itemize}

\item åœ¨å‡½æ•°è°ƒç”¨çš„è¯­æ³•ä¸­ï¼Œ \li{print_time(start)} è¡¨ç¤ºå‡½æ•°æ˜¯ä¸€ä¸ªæ´»è·ƒçš„ä»£ç†ã€‚
å°±åƒæ˜¯åœ¨è¯´ ``Hi, print\_time! è¿™æœ‰ä¸€ä¸ªå¯¹è±¡éœ€è¦ä½ æ‰“å°''ã€‚

\item åœ¨é¢å‘å¯¹è±¡ç¼–ç¨‹ä¸­ï¼Œ å¯¹è±¡æ˜¯æ´»è·ƒçš„ä»£ç†ã€‚    ä¸€ä¸ªç±»ä¼¼ \li{start.print_time()} çš„æ–¹æ³•è°ƒç”¨ï¼Œ å°±åƒæ˜¯åœ¨è¯´ ``Hi start! è¯·æ‰“å°ä½ è‡ªå·±''ã€‚

\end{itemize}

%ğŸ% This change in perspective might be more polite, but it is not obvious
%ğŸ% that it is useful.  In the examples we have seen so far, it may not
%ğŸ% be.  But sometimes shifting responsibility from the functions onto the
%ğŸ% objects makes it possible to write more versatile functions (or
%ğŸ% methods), and makes it easier to maintain and reuse code.

è§†è§’çš„è½¬æ¢ä¼¼ä¹è®©è¯­æ°”å˜å¾—æ›´æ–‡é›…äº›äº†ï¼Œ ä½†å¾ˆéš¾çœ‹å‡ºå…¶å¥½å¤„ã€‚
åœ¨å‰é¢çš„ä¾‹å­ä¸­ï¼Œ çš„ç¡®å¦‚æ­¤ã€‚
ä½†æ˜¯å°†èŒè´£ä»å‡½æ•°ä¸Šé¢è½¬ç§»åˆ°å¯¹è±¡ä¸Šï¼Œ å¯ä»¥æ›´åŠ å®¹æ˜“åœ°å†™å‡ºå¤šæ ·åŒ–çš„å‡½æ•°(æˆ–æ–¹æ³•)ï¼Œ
å¹¶ä¸”ä»£ç å°†æ›´åŠ å®¹æ˜“ç»´æŠ¤å’Œå¤ç”¨ã€‚

%ğŸ% As an exercise, rewrite \verb"time_to_int" (from
%ğŸ% Section~\ref{prototype}) as a method.  You might be tempted to
%ğŸ% rewrite \verb"int_to_time" as a method, too, but that doesn't
%ğŸ% really make sense because there would be no object to invoke
%ğŸ% it on.

æˆ‘ä»¬åšä¸ªç»ƒä¹ ï¼Œ å°† \li{time_to_int} (è§ \ref{prototype}~èŠ‚)é‡å†™ä¸ºæ–¹æ³•ã€‚
ä½ æˆ–è®¸ä¹Ÿæƒ³å°† \li{int_to_time} æ”¹å†™ä¸ºæ–¹æ³•ï¼Œ  ä½†æ˜¯é‚£æ ·åšå¹¶æ²¡æœ‰ä»€ä¹ˆæ„ä¹‰ï¼Œ  å› ä¸ºæ²¡æœ‰è°ƒç”¨å®ƒçš„å¯¹è±¡ã€‚

%ğŸ% \section{Another example}
\section{å†ä¸¾ä¸€ä¾‹}
\index{increment}

%ğŸ% Here's a version of {\tt increment} (from Section~\ref{increment})
%ğŸ% rewritten as a method:

ä¸‹é¢æ˜¯ \li{increment} (è§ \ref{increment}~èŠ‚ )æ”¹å†™ä¸ºæ–¹æ³•åçš„ä»£ç ç‰ˆæœ¬ï¼š

\begin{lstlisting}
# inside class Time:

    def increment(self, seconds):
        seconds += self.time_to_int()
        return int_to_time(seconds)
\end{lstlisting}

%
%ğŸ% This version assumes that \verb"time_to_int" is written
%ğŸ% as a method.  Also, note that
%ğŸ% it is a pure function, not a modifier.

è¿™ä¸ªç‰ˆæœ¬å‡è®¾ \li{time_to_int} å·²ç»æ”¹æˆäº†æ–¹æ³•ã€‚    å¦å¤–ï¼Œ æ³¨æ„è¿™æ˜¯ä¸€ä¸ªçº¯å‡½æ•°ï¼Œ ä¸æ˜¯ä¿®æ”¹å™¨ã€‚

%ğŸ% Here's how you would invoke {\tt increment}:

ä¸‹é¢æ˜¯è°ƒç”¨ \li{increment} çš„æ–¹æ³•ï¼š

\begin{lstlisting}
>>> start.print_time()
09:45:00
>>> end = start.increment(1337)
>>> end.print_time()
10:07:17
\end{lstlisting}

%
%ğŸ% The subject, {\tt start}, gets assigned to the first parameter,
%ğŸ% {\tt self}.  The argument, {\tt 1337}, gets assigned to the
%ğŸ% second parameter, {\tt seconds}.

ä¸»è¯­ \li{start} è¢«èµ‹å€¼ç»™ç¬¬ä¸€ä¸ªå½¢å‚ \li{self}ã€‚
å®å‚ \li{1337} è¢«èµ‹å€¼ç»™ç¬¬äºŒä¸ªå½¢å‚ \li{seconds} ã€‚

%ğŸ% This mechanism can be confusing, especially if you make an error.
%ğŸ% For example, if you invoke {\tt increment} with two arguments, you
%ğŸ% get:

è¿™ä¸ªæœºåˆ¶æœ‰æ—¶ä¼šæŠŠäººå¼„æ™•ï¼Œ å°¤å…¶æ˜¯ä½ çŠ¯é”™çš„æ—¶å€™ã€‚
ä¾‹å¦‚ï¼Œ å¦‚æœä½ ä½¿ç”¨ä¸¤ä¸ªå®å‚è°ƒç”¨ \li{increment}ï¼Œ  ä½ ä¼šå¾—åˆ°ï¼š
\index{exception!TypeError}  \index{TypeError}

\begin{lstlisting}
>>> end = start.increment(1337, 460)
TypeError: increment() takes 2 positional arguments but 3 were given
\end{lstlisting}

%
%ğŸ% The error message is initially confusing, because there are
%ğŸ% only two arguments in parentheses.  But the subject is also
%ğŸ% considered an argument, so all together that's three.

é”™è¯¯ä¿¡æ¯ä¸€å¼€å§‹è®©äººå¾ˆéš¾ç†è§£ï¼Œ å› ä¸ºåœ¨æ‹¬å·å†…åªæœ‰ä¸¤ä¸ªå®å‚ã€‚
ä½†æ˜¯ä¸»è¯­ä¹Ÿè¢«è®¤ä¸ºæ˜¯ä¸€ä¸ªå®å‚ï¼Œ æ‰€ä»¥åŠ åœ¨ä¸€èµ·å…±æœ‰ä¸‰ä¸ªå®å‚ã€‚

%ğŸ% By the way, a {\bf positional argument} is an argument that
%ğŸ% doesn't have a parameter name; that is, it is not a keyword
%ğŸ% argument.  In this function call:
å¦å¤–ï¼Œ  {\em ä½ç½®å‚æ•°} æ˜¯æ²¡æœ‰å½¢å‚åçš„å‚æ•°ï¼› ä¹Ÿå°±æ˜¯è¯´ï¼Œ å®ƒä¸æ˜¯ä¸€ä¸ªå…³é”®å­—å‚æ•°ã€‚
åœ¨ä¸‹é¢è¿™ä¸ªå‡½æ•°è°ƒç”¨ä¸­ï¼š
\index{positional argument}  \index{argument!positional}

\begin{lstlisting}
sketch(parrot, cage, dead=True)
\end{lstlisting}

%ğŸ% {\tt parrot} and {\tt cage} are positional, and {\tt dead} is
%ğŸ% a keyword argument.

\li{parrot} å’Œ \li{cage} æ˜¯ä½ç½®å‚æ•°ï¼Œ è€Œ \li{dead} æ˜¯ä¸€ä¸ªå…³é”®å­—å‚æ•°ã€‚

%ğŸ% \section{A more complicated example}
\section{ä¸€ä¸ªæ›´å¤æ‚çš„ä¾‹å­}

%ğŸ% Rewriting \verb"is_after" (from Section~\ref{isafter}) is slightly
%ğŸ% more complicated because it takes two Time objects as parameters.  In
%ğŸ% this case it is conventional to name the first parameter {\tt self}
%ğŸ% and the second parameter {\tt other}: \index{other (parameter name)}

é‡å†™ \li{is_after} (è§ \ref{isafter}~èŠ‚)è¦æ›´åŠ å¤æ‚ä¸€äº›ï¼Œ
å› ä¸ºå®ƒæ¥å—ä¸¤ä¸ª \li{Time} å¯¹è±¡ä½œä¸ºå‚æ•°ã€‚
åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œ æƒ¯ç”¨çš„åšæ³•æ˜¯å°†ç¬¬ä¸€ä¸ªå½¢å‚å‘½åä¸º \li{self}ï¼Œ ç¬¬äºŒä¸ªå½¢å‚å‘½åä¸º \li{other}ï¼š
\index{parameter!other}

\begin{lstlisting}
# inside class Time:

    def is_after(self, other):
        return self.time_to_int() > other.time_to_int()
\end{lstlisting}

%
%ğŸ% To use this method, you have to invoke it on one object and pass
%ğŸ% the other as an argument:

è¦ä½¿ç”¨è¯¥æ–¹æ³•çš„è¯ï¼Œ ä½ å¿…é¡»åœ¨æŸä¸ªå¯¹è±¡ä¸Šè°ƒç”¨å®ƒï¼Œ å¹¶ä¼ å…¥ \li{other} çš„å®å‚ï¼š

\begin{lstlisting}
>>> end.is_after(start)
True
\end{lstlisting}

%
%ğŸ% One nice thing about this syntax is that it almost reads
%ğŸ% like English: ``end is after start?''

è¿™ä¸ªè¯­æ³•æœ‰ä¸€ä¸ªå¥½å¤„ï¼Œ å°±æ˜¯å®ƒè¯»èµ·æ¥å¾ˆåƒè‹±è¯­ï¼š``endæ˜¯å‡ºç°åœ¨startä¹‹åå—ï¼Ÿ''

%ğŸ% \section{The init method}
\section{init æ–¹æ³•}
\index{init method}  \index{method!init}

%ğŸ% The init method (short for ``initialization'') is
%ğŸ% a special method that gets invoked when an object is instantiated.
%ğŸ% Its full name is \verb"__init__" (two underscore characters,
%ğŸ% followed by {\tt init}, and then two more underscores).  An
%ğŸ% init method for the {\tt Time} class might look like this:

init æ–¹æ³•(``initialization''çš„ç®€ç§°)æ˜¯ä¸€ä¸ªç‰¹æ®Šçš„æ–¹æ³•ï¼Œ
å½“ä¸€ä¸ªå¯¹è±¡åˆå§‹åŒ–çš„æ—¶å€™è°ƒç”¨ã€‚
å®ƒçš„å…¨åæ˜¯ \li{__init__} (ä¸¤ä¸ªä¸‹åˆ’çº¿ååŠ  init å†åŠ ä¸¤ä¸ªä¸‹åˆ’çº¿)ã€‚
ä¸€ä¸ª \li{Time} ç±»çš„ \li{init} æ–¹æ³•çœ‹èµ·æ¥åƒæ˜¯è¿™æ ·çš„ï¼š

\begin{lstlisting}
# inside class Time:

    def __init__(self, hour=0, minute=0, second=0):
        self.hour = hour
        self.minute = minute
        self.second = second
\end{lstlisting}

%
%ğŸ% It is common for the parameters of \verb"__init__"
%ğŸ% to have the same names as the attributes.  The statement

é€šå¸¸ \li{__init__} æ–¹æ³•çš„ å‚æ•° å’Œ å±æ€§ çš„åç§°ä¸€æ ·ã€‚


\begin{lstlisting}
        self.hour = hour
\end{lstlisting}

%
%ğŸ% stores the value of the parameter {\tt hour} as an attribute
%ğŸ% of {\tt self}.

ä¸Šé¢çš„è¯­å¥æŠŠ \li{hour} å‚æ•°çš„å€¼å‚¨å­˜ä¸º \li{self} çš„ä¸€ä¸ªå±æ€§ã€‚
\index{optional parameter}  \index{parameter!optional}
\index{default value}  \index{override}

%ğŸ% The parameters are optional, so if you call {\tt Time} with
%ğŸ% no arguments, you get the default values.

å‚æ•°æ˜¯å¯é€‰çš„ï¼Œ æ‰€ä»¥å¦‚æœä½ ä¸å¸¦å‚æ•°çš„è°ƒç”¨ \li{Time} ï¼Œ ä½ ä¼šå¾—åˆ°é»˜è®¤å€¼ã€‚

\begin{lstlisting}
>>> time = Time()
>>> time.print_time()
00:00:00
\end{lstlisting}

%
%ğŸ% If you provide one argument, it overrides {\tt hour}:

å¦‚æœä½ æä¾›ä¸€ä¸ªå‚æ•°ï¼Œ å®ƒä¼šè¦†ç›– \li{hour} ï¼š

\begin{lstlisting}
>>> time = Time (9)
>>> time.print_time()
09:00:00
\end{lstlisting}

%
%ğŸ% If you provide two arguments, they override {\tt hour} and
%ğŸ% {\tt minute}.

å¦‚æœä½ æä¾›ä¸¤ä¸ªå‚æ•°ï¼Œ ä»–ä»¬ä¼šè¦†ç›– \li{hour} å’Œ \li{minute} ã€‚

\begin{lstlisting}
>>> time = Time(9, 45)
>>> time.print_time()
09:45:00
\end{lstlisting}

%
%ğŸ% And if you provide three arguments, they override all three
%ğŸ% default values.

å¦‚æœä½ æä¾›ä¸‰ä¸ªå‚æ•°ï¼Œ å®ƒä»¬ä¼šè¦†ç›–ä¸‰ä¸ªé»˜è®¤å€¼ã€‚

%ğŸ% As an exercise, write an init method for the {\tt Point} class that takes
%ğŸ% {\tt x} and {\tt y} as optional parameters and assigns
%ğŸ% them to the corresponding attributes.

æˆ‘ä»¬åšä¸ªç»ƒä¹ ï¼Œ ä¸º \li{Point} ç±»å†™ä¸€ä¸ª init æ–¹æ³•ï¼Œ ä½¿ç”¨ \li{x} å’Œ \li{y} ä½œä¸ºå¯é€‰å‚æ•°ï¼Œ ç„¶åèµ‹å€¼ç»™å¯¹åº”çš„å±æ€§ã€‚
\index{Point class}  \index{class!Point}


%ğŸ% \section{The {\tt \_\_str\_\_} method}
\section{ {\tt \_\_str\_\_} æ–¹æ³•}

\index{str method@\_\_str\_\_ method}  \index{method!\_\_str\_\_}

%ğŸ% \verb"__str__" is a special method, like \verb"__init__",
%ğŸ% that is supposed to return a string representation of an object.

\li{__str__} æ˜¯ä¸€ä¸ªå’Œ \li{__init__}
æ–¹æ³•ç±»ä¼¼çš„ç‰¹æ®Šæ–¹æ³•ï¼Œ è¿”å›ä¸€ä¸ªå¯¹è±¡çš„å­—ç¬¦ä¸²è¡¨ç°å½¢å¼ã€‚

\index{string representation}

%ğŸ% For example, here is a {\tt str} method for Time objects:

ä¾‹å¦‚ï¼Œ ä¸‹é¢æ˜¯ä¸€ä¸ª \li{Time} å¯¹è±¡çš„ \li{str} æ–¹æ³•ï¼š

\begin{lstlisting}
# inside class Time:

    def __str__(self):
        return '%.2d:%.2d:%.2d' % (self.hour, self.minute, self.second)
\end{lstlisting}

%
%ğŸ% When you {\tt print} an object, Python invokes the {\tt str} method:

å½“ä½ æ‰“å°(\li{print})ä¸€ä¸ªå¯¹è±¡ï¼Œ Python è°ƒç”¨ \li{str} æ–¹æ³•ï¼š

\index{print statement}  \index{statement!print}

\begin{lstlisting}
>>> time = Time(9, 45)
>>> print(time)
09:45:00
\end{lstlisting}

%
%ğŸ% When I write a new class, I almost always start by writing
%ğŸ% \verb"__init__", which makes it easier to instantiate objects, and
%ğŸ% \verb"__str__", which is useful for debugging.

å†™ä¸€ä¸ªæ–°ç±»æ—¶ï¼Œ æˆ‘æ€»æ˜¯ä» \li{__init__} å¼€å§‹ï¼Œ ä½¿å¾—æ›´å®¹æ˜“å®ä¾‹åŒ–å¯¹è±¡ï¼Œ
æ¥ç€å°±æ˜¯å†™ \li{__str__} æ–¹æ³•ï¼Œ æ–¹ä¾¿è°ƒè¯•ã€‚

%ğŸ% As an exercise, write a {\tt str} method for the {\tt Point} class.
%ğŸ% Create a Point object and print it.

æˆ‘ä»¬åšä¸ªç»ƒä¹ ï¼Œ ä¸º \li{Point} ç±»å†™ä¸€ä¸ª \li{str} æ–¹æ³•ã€‚
ç„¶ååˆ›å»ºä¸€ä¸ª \li{Point} å¯¹è±¡å¹¶æ‰“å°ã€‚

%ğŸ% \section{Operator overloading}
\section{è¿ç®—ç¬¦é‡è½½}
\label{operator.overloading}

%ğŸ% By defining other special methods, you can specify the behavior
%ğŸ% of operators on programmer-defined types.  For example, if you define
%ğŸ% a method named \verb"__add__" for the {\tt Time} class, you can use the
%ğŸ% {\tt +} operator on Time objects.

é€šè¿‡å®šä¹‰å…¶å®ƒçš„ä¸€äº›ç‰¹æ®Šæ–¹æ³•ï¼Œ ä½ å¯ä»¥åœ¨ç¨‹åºå‘˜è‡ªå®šä¹‰ç±»å‹ä¸ŠæŒ‡å®šè¿ç®—ç¬¦çš„è¡Œä¸ºã€‚
ä¾‹å¦‚ï¼Œ å¦‚æœä½ ä¸º \li{Time} ç±»å®šä¹‰äº†ä¸€ä¸ªå« \li{__add__} çš„æ–¹æ³•ï¼Œ
ä½ å°±å¯ä»¥åœ¨ \li{Time} å¯¹è±¡ä¸Šä½¿ç”¨ \li{+} è¿ç®—ç¬¦ã€‚

\index{programmer-defined type}  \index{type!programmer-defined}

%ğŸ% Here is what the definition might look like:

å¯ä»¥å¤§è‡´åƒè¿™æ ·å®šä¹‰ï¼š

\index{add method}  \index{method!add}

\begin{lstlisting}
# inside class Time:

    def __add__(self, other):
        seconds = self.time_to_int() + other.time_to_int()
        return int_to_time(seconds)
\end{lstlisting}

%
%ğŸ% And here is how you could use it:

ä¸‹é¢æ˜¯ä½¿ç”¨æ–¹å¼ï¼š

\begin{lstlisting}
>>> start = Time(9, 45)
>>> duration = Time(1, 35)
>>> print(start + duration)
11:20:00
\end{lstlisting}

%
%ğŸ% When you apply the {\tt +} operator to Time objects, Python invokes
%ğŸ% \verb"__add__".  When you print the result, Python invokes
%ğŸ% \verb"__str__".  So there is a lot happening behind the scenes!

å½“ä½ åœ¨ \li{Time} å¯¹è±¡ä¸Šåº”ç”¨ \li{+} è¿ç®—ç¬¦ï¼Œ Python ä¼šè°ƒç”¨ \li{__add__} ã€‚
å½“ä½ æ‰“å°ç»“æœæ—¶ï¼Œ Python ä¼šè°ƒç”¨ \li{__str__} ã€‚
æ‰€ä»¥å®é™…ä¸Šåå°å‘ç”Ÿäº†å¾ˆå¤šæœ‰è¶£çš„äº‹æƒ…ï¼

\index{operator overloading}

%ğŸ% Changing the behavior of an operator so that it works with
%ğŸ% programmer-defined types is called {\bf operator overloading}.  For every
%ğŸ% operator in Python there is a corresponding special method, like
%ğŸ% \verb"__add__".  For more details, see
%ğŸ% \url{http://docs.python.org/3/reference/datamodel.html#specialnames}.

æ”¹å˜ä¸€ä¸ªè¿ç®—ç¬¦çš„è¡Œä¸ºï¼Œ ä½¿å…¶å…¼å®¹ç¨‹åºå‘˜è‡ªå®šä¹‰ç±»å‹ï¼Œ è¿™è¢«ç§°ä¸º
{\em è¿ç®—ç¬¦é‡è½½} (operator overloading)ã€‚
å¯¹äºæ¯ä¸€ä¸ªè¿ç®—ç¬¦ï¼Œ Python æœ‰ä¸€ä¸ªç±»ä¼¼ \li{__add__} çš„å¯¹åº”çš„ç‰¹æ®Šæ–¹æ³•ã€‚
æ›´å¤šçš„è¯¦æƒ…ï¼Œ è¯·å‚è€ƒ\href{http://docs.python.org/3/reference/datamodel.html#specialnames}{å®˜æ–¹æ–‡æ¡£çš„ä»‹ç»} ã€‚

%ğŸ% As an exercise, write an {\tt add} method for the Point class.

æˆ‘ä»¬æ¥åšä¸ªç»ƒä¹ ï¼Œ ä¸º \li{Point} ç±»ç¼–å†™ä¸€ä¸ª \li{add} æ–¹æ³•ã€‚

%ğŸ% \section{Type-based dispatch}
\section{ç±»å‹åˆ†å‘ (type-based dispatch)}

%ğŸ% In the previous section we added two Time objects, but you
%ğŸ% also might want to add an integer to a Time object.  The
%ğŸ% following is a version of \verb"__add__"
%ğŸ% that checks the type of {\tt other} and invokes either
%ğŸ% \verb"add_time" or {\tt increment}:

åœ¨ä¸Šä¸€èŠ‚ä¸­ï¼Œ æˆ‘ä»¬å°†ä¸¤ä¸ª \li{Time}å¯¹è±¡ç›¸åŠ ï¼Œ
ä½†æ˜¯ä½ è¿˜ä¼šæƒ³è¦å°†ä¸€ä¸ªæ•´æ•°ä¸ \li{Time}å¯¹è±¡ç›¸åŠ ã€‚
ä¸‹é¢è¿™ä¸ªç‰ˆæœ¬çš„ \li{__add__}ä¼šæ£€æŸ¥ \li{other}çš„ç±»å‹ï¼Œ
å¹¶ç›¸åº”åœ°è°ƒç”¨ \li{add_time}æˆ–è€… \li{increment}ï¼š

\begin{lstlisting}
# inside class Time:

    def __add__(self, other):
        if isinstance(other, Time):
            return self.add_time(other)
        else:
            return self.increment(other)

    def add_time(self, other):
        seconds = self.time_to_int() + other.time_to_int()
        return int_to_time(seconds)

    def increment(self, seconds):
        seconds += self.time_to_int()
        return int_to_time(seconds)
\end{lstlisting}

%
%ğŸ% The built-in function {\tt isinstance} takes a value and a
%ğŸ% class object, and returns {\tt True} if the value is an instance
%ğŸ% of the class.

å†…å»ºå‡½æ•° \li{isinstance} æ¥å—ä¸€ä¸ªå€¼å’Œä¸€ä¸ªç±»å¯¹è±¡ï¼Œ
å¦‚æœå€¼æ˜¯è¿™ä¸ªç±»çš„å®ä¾‹åˆ™è¿”å› \li{True} ã€‚
\index{isinstance function}  \index{function!isinstance}

%ğŸ% If {\tt other} is a Time object, \verb"__add__" invokes
%ğŸ% \verb"add_time".  Otherwise it assumes that the parameter
%ğŸ% is a number and invokes {\tt increment}.  This operation is
%ğŸ% called a {\bf type-based dispatch} because it dispatches the
%ğŸ% computation to different methods based on the type of the
%ğŸ% arguments.

å¦‚æœ \li{other} æ˜¯ä¸€ä¸ª \li{Time} å¯¹è±¡ï¼Œ \li{__add__} è°ƒç”¨ \li{add_time} ã€‚
å¦åˆ™å®ƒå‡è®¾å‚æ•°æ˜¯ä¸€ä¸ªæ•°å­—ç„¶åè°ƒç”¨ \li{increment} ã€‚
è¿™ä¸ªæ“ä½œè¢«ç§°ä¸º {\em ç±»å‹åˆ†å‘} (type-based dispatch)ï¼Œ  å› ä¸ºå®ƒæ ¹æ®å‚æ•°çš„
ç±»å‹å°†è®¡ç®—ä»»åŠ¡åˆ†å‘ç»™ä¸åŒçš„æ–¹æ³•ã€‚

\index{type-based dispatch}  \index{dispatch, type-based}

%ğŸ% Here are examples that use the {\tt +} operator with different
%ğŸ% types:

ä¸‹é¢æ˜¯ä¸€äº›åœ¨ä¸åŒç±»å‹ä¸Šä½¿ç”¨ \li{+} è¿ç®—ç¬¦çš„ä¾‹å­ï¼š

\begin{lstlisting}
>>> start = Time(9, 45)
>>> duration = Time(1, 35)
>>> print(start + duration)
11:20:00
>>> print(start + 1337)
10:07:17
\end{lstlisting}

%
%ğŸ% Unfortunately, this implementation of addition is not commutative.
%ğŸ% If the integer is the first operand, you get

ä¸å¹¸çš„æ˜¯ï¼Œ è¿™ä¸ªåŠ æ³•çš„å®ç°æ²¡æœ‰äº¤æ¢æ€§ (commutative)ã€‚
å¦‚æœç¬¬ä¸€ä¸ªè¿ç®—æ•°æ˜¯ä¸€ä¸ªæ•´æ•°ï¼Œ ä½ ä¼šå¾—åˆ°ï¼š

\index{commutativity}

\begin{lstlisting}
>>> print(1337 + start)
TypeError: unsupported operand type(s) for +: 'int' and 'instance'
\end{lstlisting}

%
%ğŸ% The problem is, instead of asking the Time object to add an integer,
%ğŸ% Python is asking an integer to add a Time object, and it doesn't know
%ğŸ% how.  But there is a clever solution for this problem: the
%ğŸ% special method \verb"__radd__", which stands for ``right-side add''.
%ğŸ% This method is invoked when a Time object appears on the right side of
%ğŸ% the {\tt +} operator.  Here's the definition:

é—®é¢˜åœ¨äºï¼Œ æˆ‘ä»¬ä¸æ˜¯è®©ä¸€ä¸ª \li{Time} å¯¹è±¡å»åŠ ä¸€ä¸ªæ•´æ•°ï¼Œ
è€Œæ˜¯è®©ä¸€ä¸ªæ•´æ•°å»åŠ ä¸€ä¸ª \li{Time} å¯¹è±¡ï¼Œ ä½†æ˜¯Pythonä¸çŸ¥é“æ€æ ·å»åšã€‚
ä¸è¿‡è¿™ä¸ªé—®é¢˜æœ‰ä¸€ä¸ªä¼˜é›…çš„è§£å†³æ–¹æ¡ˆï¼šç‰¹æ®Šæ–¹æ³• \li{__radd__}ï¼Œ è¡¨ç¤ºâ€œå³æ‰‹åŠ æ³•â€ã€‚
å½“ä¸€ä¸ª \li{Time} å¯¹è±¡åœ¨ \li{+} è¿ç®—ç¬¦çš„å³æ‰‹è¾¹å‡ºç°æ—¶ï¼Œ è°ƒç”¨è¿™ä¸ªæ–¹æ³•ã€‚    ä¸‹é¢æ˜¯å®šä¹‰ï¼š

\index{radd method}  \index{method!radd}

\begin{lstlisting}
# inside class Time:

    def __radd__(self, other):
        return self.__add__(other)
\end{lstlisting}

%
%ğŸ% And here's how it's used:

æ¥ç€æ˜¯ä½¿ç”¨æ–¹æ³•ï¼š

\begin{lstlisting}
>>> print(1337 + start)
10:07:17
\end{lstlisting}

%

%ğŸ% As an exercise, write an {\tt add} method for Points that works with
%ğŸ% either a Point object or a tuple:

æˆ‘ä»¬åšä¸ªç»ƒä¹ ï¼Œ ä¸º \li{Points} ç¼–å†™ä¸€ä¸ª \li{add} æ–¹æ³•ï¼Œ
ä½¿å…¶æ—¢é€‚ç”¨ \li{Point} å¯¹è±¡ï¼Œ ä¹Ÿé€‚ç”¨å…ƒç»„ï¼š

%ğŸ% \begin{itemize}
%ğŸ%
%ğŸ% \item If the second operand is a Point, the method should return a new
%ğŸ% Point whose $x$ coordinate is the sum of the $x$ coordinates of the
%ğŸ% operands, and likewise for the $y$ coordinates.
%ğŸ%
%ğŸ% \item If the second operand is a tuple, the method should add the
%ğŸ% first element of the tuple to the $x$ coordinate and the second
%ğŸ% element to the $y$ coordinate, and return a new Point with the result.
%ğŸ%
%ğŸ% \end{itemize}

\begin{itemize}

\item å¦‚æœç¬¬äºŒä¸ªè¿ç®—æ•°æ˜¯ä¸€ä¸ª \li{Point} ï¼Œ è¯¥æ–¹æ³•å°†è¿”å›ä¸€ä¸ªæ–°çš„ \li{Point}ï¼Œ
$x$ åæ ‡æ˜¯ä¸¤ä¸ªè¿ç®—æ•°çš„ $x$ çš„å’Œï¼Œ  $y$ ä»¥æ­¤ç±»æ¨ã€‚

\item å¦‚æœç¬¬äºŒä¸ªè¿ç®—æ•°æ˜¯ä¸€ä¸ªå…ƒç»„ï¼Œ è¯¥æ–¹æ³•å°†æŠŠå…ƒç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ ä¸ $x$ ç›¸åŠ ï¼Œ
ç¬¬äºŒä¸ªå…ƒç´ ä¸ $y$ ç›¸åŠ ï¼Œ ç„¶åè¿”å›ä»¥ç›¸å…³ç»“æœä¸ºå‚æ•°çš„æ–°çš„ \li{Point}ã€‚

\end{itemize}


%ğŸ% \section{Polymorphism}
\section{å¤šæ€æ€§}
\label{polymorphism}

%ğŸ% Type-based dispatch is useful when it is necessary, but (fortunately)
%ğŸ% it is not always necessary.  Often you can avoid it by writing functions
%ğŸ% that work correctly for arguments with different types.

ç±»å‹åˆ†å‘åœ¨å¿…è¦çš„æ—¶å€™éå¸¸æœ‰ç”¨ï¼Œ ä½†æ˜¯(å¹¸è¿çš„æ˜¯)å®ƒä¸æ˜¯ç»å¯¹å¿…é¡»çš„ã€‚
é€šå¸¸ï¼Œ ä½ å¯ä»¥é€šè¿‡ç¼–å†™å¯¹ä¸åŒå‚æ•°ç±»å‹éƒ½é€‚ç”¨çš„å‡½æ•°ï¼Œ æ¥é¿å…è¿™ç§æƒ…å†µã€‚

\index{type-based dispatch}  \index{dispatch!type-based}

%ğŸ% Many of the functions we wrote for strings also
%ğŸ% work for other sequence types.
%ğŸ% For example, in Section~\ref{histogram}
%ğŸ% we used {\tt histogram} to count the number of times each letter
%ğŸ% appears in a word.

è®¸å¤šæˆ‘ä»¬ä¸ºå­—ç¬¦ä¸²å†™çš„å‡½æ•°ï¼Œ å®é™…ä¸Šä¹Ÿé€‚ç”¨äºå…¶ä»–åºåˆ—ç±»å‹ã€‚
ä¾‹å¦‚ï¼Œ åœ¨ \ref{histogram}~èŠ‚ä¸­ï¼Œ æˆ‘ä»¬ä½¿ç”¨ \li{histogram}
è®¡ç®—äº†å•è¯ä¸­æ¯ä¸ªå­—æ¯å‡ºç°çš„æ¬¡æ•°ã€‚

\begin{lstlisting}
def histogram(s):
    d = dict()
    for c in s:
        if c not in d:
            d[c] = 1
        else:
            d[c] = d[c]+1
    return d
\end{lstlisting}

%
%ğŸ% This function also works for lists, tuples, and even dictionaries,
%ğŸ% as long as the elements of {\tt s} are hashable, so they can be used
%ğŸ% as keys in {\tt d}.

è¿™ä¸ªå‡½æ•°ä¹Ÿé€‚ç”¨äºåˆ—è¡¨ã€å…ƒç»„ç”šè‡³æ˜¯å­—å…¸ï¼Œ åªè¦ \li{s} çš„å…ƒç´ æ˜¯å¯å“ˆå¸Œçš„ï¼Œ ä½ å°±å¯ä»¥æŠŠ
å®ƒç”¨ä½œ \li{d} çš„é”®ã€‚

\begin{lstlisting}
>>> t = ['spam', 'egg', 'spam', 'spam', 'bacon', 'spam']
>>> histogram(t)
{'bacon': 1, 'egg': 1, 'spam': 4}
\end{lstlisting}

%
%ğŸ% Functions that work with several types are called {\bf polymorphic}.
%ğŸ% Polymorphism can facilitate code reuse.  For example, the built-in
%ğŸ% function {\tt sum}, which adds the elements of a sequence, works
%ğŸ% as long as the elements of the sequence support addition.

é€‚ç”¨äºå¤šç§ç±»å‹çš„å‡½æ•°ï¼Œ è¢«ç§°ä¸º {\em å¤šæ€} å‡½æ•°ã€‚
å¤šæ€æ€§æœ‰åŠ©äºä»£ç å¤ç”¨ã€‚  ä¾‹å¦‚ï¼Œ å†…å»ºå‡½æ•° \li{sum} å¯¹ä¸€ä¸ªåºåˆ—çš„å…ƒç´ æ±‚å’Œï¼Œ åªè¦åºåˆ—ä¸­çš„å…ƒç´ æ”¯æŒåŠ æ³•å³å¯ã€‚

\index{polymorphism}

%ğŸ% Since Time objects provide an {\tt add} method, they work
%ğŸ% with {\tt sum}:

å› ä¸º \li{Time} å¯¹è±¡æä¾›äº†ä¸€ä¸ª \li{add} æ–¹æ³•ï¼Œ \li{sum} ä¹Ÿå¯ä»¥åº”ç”¨äºè¯¥å¯¹è±¡ï¼š

\begin{lstlisting}
>>> t1 = Time(7, 43)
>>> t2 = Time(7, 41)
>>> t3 = Time(7, 37)
>>> total = sum([t1, t2, t3])
>>> print(total)
23:01:00
\end{lstlisting}

%
%ğŸ% In general, if all of the operations inside a function
%ğŸ% work with a given type, the function works with that type.

é€šå¸¸ï¼Œ å¦‚æœä¸€ä¸ªå‡½æ•°å†…æ‰€æœ‰çš„æ“ä½œéƒ½é€‚ç”¨äºä¸€ä¸ªç±»å‹ï¼Œ é‚£è¿™ä¸ªå‡½æ•°å°±èƒ½é€‚ç”¨è¯¥ç±»å‹ã€‚

%ğŸ% The best kind of polymorphism is the unintentional kind, where
%ğŸ% you discover that a function you already wrote can be
%ğŸ% applied to a type you never planned for.

æœ€å¥½çš„å¤šæ€æ€§æ˜¯æ— å¿ƒæˆæŸ³æŸ³æˆè«çš„ï¼Œ å°±æ˜¯ä½ å‘ç°ä½ å·²ç»å†™çš„ä¸€ä¸ªå‡½æ•°ï¼Œ
åœ¨ä½ æ²¡æœ‰é¢„è®¡çš„ç±»å‹ä¸Šä¹Ÿèƒ½ä½¿ç”¨ã€‚




%ğŸ% \section{Interface and implementation}
\section{æ¥å£å’Œå®ç°}

%ğŸ% One of the goals of object-oriented design is to make software more
%ğŸ% maintainable, which means that you can keep the program working when
%ğŸ% other parts of the system change, and modify the program to meet new
%ğŸ% requirements.

é¢å‘å¯¹è±¡è®¾è®¡çš„ä¸€ä¸ªç›®æ ‡æ˜¯ä½¿å¾—è½¯ä»¶æ›´å®¹æ˜“ç»´æŠ¤ï¼Œ
è¿™æ„å‘³ç€å½“ç³»ç»Ÿçš„å…¶å®ƒéƒ¨åˆ†æ”¹å˜æ—¶ç¨‹åºè¿˜èƒ½æ­£å¸¸è¿è¡Œï¼Œ ä½ å¯ä»¥ä¿®æ”¹ç¨‹åºæ»¡è¶³æ–°çš„éœ€æ±‚ã€‚
\index{interface}  \index{implementation}
\index{maintainable}  \index{object-oriented design}

%ğŸ% A design principle that helps achieve that goal is to keep
%ğŸ% interfaces separate from implementations.  For objects, that means
%ğŸ% that the methods a class provides should not depend on how the
%ğŸ% attributes are represented.

æœ‰åŠ©äºå®ç°è¯¥ç›®æ ‡çš„ä¸€ä¸ªè®¾è®¡åŸåˆ™æ˜¯ï¼Œ æ¥å£å’Œå®ç°åˆ†ç¦»ã€‚
å¯¹äºå¯¹è±¡ï¼Œ å°±æ„å‘³ç€ä¸€ä¸ªç±»æä¾›çš„æ–¹æ³•ä¸åº”è¯¥ä¾èµ–å±æ€§çš„å½¢å¼ã€‚
\index{attribute}

%ğŸ% For example, in this chapter we developed a class that represents
%ğŸ% a time of day.  Methods provided by this class include
%ğŸ% \verb"time_to_int", \verb"is_after", and \verb"add_time".

ä¾‹å¦‚ï¼Œ åœ¨æœ¬ç« ä¸­ï¼Œ æˆ‘ä»¬è®¾è®¡äº†ä¸€ä¸ªè¡¨ç¤ºä¸€å¤©ä¸­æ—¶é—´çš„ç±»ã€‚  è¿™ä¸ªç±»æä¾›çš„æ–¹æ³•åŒ…æ‹¬
\li{time_to_int} ï¼Œ \li{is_after} å’Œ \li{add_time} ã€‚

%ğŸ% We could implement those methods in several ways.  The details of the
%ğŸ% implementation depend on how we represent time.  In this chapter, the
%ğŸ% attributes of a {\tt Time} object are {\tt hour}, {\tt minute}, and
%ğŸ% {\tt second}.

æˆ‘ä»¬æœ‰å¤šç§æ–¹å¼å¯ä»¥å®ç°è¿™äº›æ–¹æ³•ã€‚  å®ç°çš„ç»†èŠ‚å–å†³äºæˆ‘ä»¬å¦‚ä½•è¡¨ç¤ºæ—¶é—´ã€‚
åœ¨æœ¬ç« ä¸­ï¼Œ \li{Time} å¯¹è±¡çš„å±æ€§æ˜¯ \li{hour} ï¼Œ \li{minute} å’Œ \li{second} ã€‚

%ğŸ% As an alternative, we could replace these attributes with
%ğŸ% a single integer representing the number of seconds
%ğŸ% since midnight.  This implementation would make some methods,
%ğŸ% like \verb"is_after", easier to write, but it makes other methods
%ğŸ% harder.

å¦ä¸€ç§æ–¹å¼æ˜¯ï¼Œ æˆ‘ä»¬ç”¨ä¸€ä¸ªæ•´æ•°è¡¨ç¤ºä»é›¶ç‚¹å¼€å§‹çš„ç§’æ•°ï¼Œ æ¥æ›¿ä»£è¿™äº›å±æ€§ã€‚
è¿™ä¸ªå®ç°ä¼šä½¿å¾—ä¸€äº›æ–¹æ³•(å¦‚ \li{is_after} ) æ›´å®¹æ˜“ç¼–å†™ï¼Œ ä½†ä¹Ÿè®©ç¼–å†™å…¶ä»–æ–¹æ³•å˜å¾—æ›´éš¾ã€‚

%ğŸ% After you deploy a new class, you might discover a better
%ğŸ% implementation.  If other parts of the program are using your
%ğŸ% class, it might be time-consuming and error-prone to change the
%ğŸ% interface.

åœ¨ä½ å®Œæˆä¸€ä¸ªæ–°ç±»åï¼Œ ä½ å¯èƒ½ä¼šå‘ç°æœ‰ä¸€ä¸ªæ›´å¥½çš„å®ç°ã€‚  å¦‚æœç¨‹åºå…¶ä»–éƒ¨åˆ†ä½¿ç”¨äº†ä½ çš„ç±»ï¼Œ
å†æ¥æ”¹å˜æ¥å£éœ€è¦å¾ˆå¤šæ—¶é—´ï¼Œ è€Œä¸”å®¹æ˜“å‡ºé”™ã€‚

%ğŸ% But if you designed the interface carefully, you can
%ğŸ% change the implementation without changing the interface, which
%ğŸ% means that other parts of the program don't have to change.

ä½†æ˜¯å¦‚æœä½ ç»†å¿ƒè®¾è®¡å¥½æ¥å£ï¼Œ ä½ å¯ä»¥æ”¹å˜å®ç°è€Œä¿æŒæ¥å£ä¸å˜ï¼Œ è¿™æ ·ç¨‹åºçš„å…¶å®ƒéƒ¨åˆ†éƒ½ä¸ç”¨æ”¹å˜ã€‚


%ğŸ% \section{Debugging}
\section{è°ƒè¯•}
\index{debugging}

%ğŸ% It is legal to add attributes to objects at any point in the execution
%ğŸ% of a program, but if you have objects with the same type that don't
%ğŸ% have the same attributes, it is easy to make mistakes.
%ğŸ% It is considered a good idea to
%ğŸ% initialize all of an object's attributes in the init method.

åœ¨ç¨‹åºæ‰§è¡Œçš„ä»»ä½•æ—¶é—´ï¼Œ ä¸ºä¸€ä¸ªå¯¹è±¡æ·»åŠ å±æ€§éƒ½æ˜¯åˆæ³•çš„ï¼Œ
ä½†æ˜¯å¦‚æœç›¸åŒç±»å‹çš„å¯¹è±¡æ‹¥æœ‰ä¸åŒçš„å±æ€§ï¼Œ å°±ä¼šå¾ˆå®¹æ˜“å‡ºç°é”™è¯¯ã€‚
é€šå¸¸ä¸€ä¸ªå¥½çš„åšæ³•æ˜¯åœ¨ init æ–¹æ³•ä¸­åˆå§‹åŒ–ä¸€ä¸ªå¯¹è±¡çš„æ‰€æœ‰å±æ€§ã€‚

\index{init method}  \index{attribute!initializing}

%ğŸ% If you are not sure whether an object has a particular attribute, you
%ğŸ% can use the built-in function {\tt hasattr} (see Section~\ref{hasattr}).

å¦‚æœä½ ä¸ç¡®å®šä¸€ä¸ªå¯¹è±¡æ˜¯å¦åº”è¯¥æœ‰æŸä¸ªå±æ€§ï¼Œ ä½ å¯ä»¥ä½¿ç”¨å†…å»ºå‡½æ•° \li{hasattr}
 (å‚è§ \ref{hasattr}~èŠ‚)ã€‚

\index{hasattr function}  \index{function!hasattr}
\index{dict attribute@\_\_dict\_\_ attribute}
\index{attribute!\_\_dict\_\_}

%ğŸ% Another way to access attributes is the built-in function {\tt vars},
%ğŸ% which takes an object and returns a dictionary that maps from
%ğŸ% attribute names (as strings) to their values:

å¦ä¸€ç§è®¿é—®å¯¹è±¡å±æ€§çš„æ–¹æ³•æ˜¯ä½¿ç”¨å†…å»ºå‡½æ•° \li{vars}ï¼Œ
å®ƒæ¥å—ä¸€ä¸ªå¯¹è±¡ï¼Œ å¹¶è¿”å›ä¸€ä¸ªå°†å±æ€§åç§°(å­—ç¬¦ä¸²å½¢å¼)åˆ°å¯¹åº”å€¼çš„å­—å…¸ï¼š

\begin{lstlisting}
>>> p = Point(3, 4)
>>> vars(p)
{'y': 4, 'x': 3}
\end{lstlisting}

%
%ğŸ% For purposes of debugging, you might find it useful to keep this
%ğŸ% function handy:

å®šä¹‰ä¸‹é¢è¿™æ®µä»£ç ï¼Œ å¯èƒ½å¯¹è°ƒè¯•éå¸¸æœ‰ç”¨ï¼š

\begin{lstlisting}
def print_attributes(obj):
    for attr in vars(obj):
        print(attr, getattr(obj, attr))
\end{lstlisting}

%
%ğŸ% \verb"print_attributes" traverses the dictionary
%ğŸ% and prints each attribute name and its corresponding value.

\li{print_attributes} éå†ä¸€ä¸ªå¯¹è±¡çš„å­—å…¸ï¼Œ
ç„¶åæ‰“å°æ¯ä¸ªå±æ€§çš„åç§°å’Œå¯¹åº”çš„å€¼ã€‚

\index{traversal!dictionary}  \index{dictionary!traversal}

%ğŸ% The built-in function {\tt getattr} takes an object and an attribute
%ğŸ% name (as a string) and returns the attribute's value.

å†…å»ºå‡½æ•° \li{getattr}æ¥å—ä¸€ä¸ªå¯¹è±¡å’Œä¸€ä¸ªå±æ€§åç§°(å­—ç¬¦ä¸²)
ä½œä¸ºå‚æ•°ï¼Œ ç„¶åè¿”å›è¯¥å±æ€§çš„å€¼ã€‚

\index{getattr function}  \index{function!getattr}

%ğŸ% \section{Glossary}
\section{æœ¯è¯­è¡¨}

%ğŸ% \begin{description}
%ğŸ%
%ğŸ% \item[object-oriented language:] A language that provides features,
%ğŸ%   such as programmer-defined types and methods, that facilitate
%ğŸ%   object-oriented programming.
%ğŸ% \index{object-oriented language}
%ğŸ%
%ğŸ% \item[object-oriented programming:] A style of programming in which
%ğŸ% data and the operations that manipulate it are organized into classes
%ğŸ% and methods.
%ğŸ% \index{object-oriented programming}
%ğŸ%
%ğŸ% \item[method:] A function that is defined inside a class definition and
%ğŸ% is invoked on instances of that class.
%ğŸ% \index{method}
%ğŸ%
%ğŸ% \item[subject:] The object a method is invoked on.
%ğŸ% \index{subject}
%ğŸ%
%ğŸ% \item[positional argument:]  An argument that does not include
%ğŸ% a parameter name, so it is not a keyword argument.
%ğŸ% \index{positional argument}
%ğŸ% \index{argument!positional}
%ğŸ%
%ğŸ% \item[operator overloading:] Changing the behavior of an operator like
%ğŸ% {\tt +} so it works with a programmer-defined type.
%ğŸ% \index{overloading}
%ğŸ% \index{operator!overloading}
%ğŸ%
%ğŸ% \item[type-based dispatch:] A programming pattern that checks the type
%ğŸ% of an operand and invokes different functions for different types.
%ğŸ% \index{type-based dispatch}
%ğŸ%
%ğŸ% \item[polymorphic:] Pertaining to a function that can work with more
%ğŸ%   than one type.
%ğŸ% \index{polymorphism}
%ğŸ%
%ğŸ% \item[information hiding:] The principle that the interface provided
%ğŸ% by an object should not depend on its implementation, in particular
%ğŸ% the representation of its attributes.
%ğŸ% \index{information hiding}
%ğŸ%
%ğŸ% \end{description}

\begin{description}

\item[é¢å‘å¯¹è±¡çš„è¯­è¨€ (object-oriented language):] æä¾›æœ‰åŠ©äºé¢å‘å¯¹è±¡ç¼–ç¨‹ç‰¹æ€§çš„è¯­è¨€ï¼Œ å¦‚ç¨‹åºå‘˜è‡ªå®šä¹‰ç±»å‹å’Œæ–¹æ³•ã€‚
\index{object-oriented language}

\item[é¢å‘å¯¹è±¡ç¼–ç¨‹ (object-oriented programming):] ä¸€ç§ç¼–ç¨‹é£æ ¼ï¼Œ æ•°æ®å’Œå¤„ç†æ•°æ®çš„æ“ä½œè¢«ç»„ç»‡æˆç±»å’Œæ–¹æ³•ã€‚
\index{object-oriented programming}

\item[æ–¹æ³• (method):] åœ¨ç±»å®šä¹‰å†…éƒ¨å®šä¹‰çš„ä¸€ä¸ªå‡½æ•°ï¼Œ å¿…é¡»åœ¨è¯¥ç±»çš„å®ä¾‹ä¸Šè°ƒç”¨ã€‚
\index{method}

\item[ä¸»è¯­ (subject):] æ–¹æ³•åœ¨è¯¥å¯¹è±¡ä¸Šè°ƒç”¨ã€‚
\index{subject}

\item[ä½ç½®å‚æ•° (positional argument):]  ä¸åŒ…æ‹¬å½¢å‚åçš„å®å‚ï¼Œ æ‰€ä»¥ä¸æ˜¯å…³é”®å­—å®å‚ã€‚
\index{positional argument}  \index{argument!positional}

\item[è¿ç®—ç¬¦é‡è½½ (operator overloading):] æ”¹å˜ç±»ä¼¼ \li{+} çš„è¿ç®—ç¬¦ï¼Œ
ä½¿å…¶å¯ä»¥åº”ç”¨äºç¨‹åºå‘˜è‡ªå®šä¹‰ç±»å‹ã€‚
\index{overloading}  \index{operator!overloading}

\item[ç±»å‹åˆ†å‘ (type-based dispatch):] ä¸€ç§æ£€æŸ¥è¿ç®—ç¬¦çš„ç±»å‹ï¼Œ å¹¶æ ¹æ®ç±»å‹ä¸åŒè°ƒç”¨ä¸åŒå‡½æ•°çš„ç¼–ç¨‹æ¨¡å¼ã€‚
\index{type-based dispatch}

\item[å¤šæ€çš„ (polymorphic):] æè¿°ä¸€ä¸ªå¯åº”ç”¨äºå¤šç§ç±»å‹çš„å‡½æ•°ã€‚
\index{polymorphism}

\item[ä¿¡æ¯éšè— (information hiding):] å¯¹è±¡æä¾›çš„æ¥å£ä¸åº”ä¾èµ–äºå…¶å®ç°çš„åŸåˆ™ï¼Œ å°¤å…¶æ˜¯å…¶å±æ€§çš„è¡¨ç¤ºå½¢å¼ã€‚
\index{information hiding}

\end{description}


%ğŸ% \section{Exercises}
\section{ç»ƒä¹ }

%ğŸ% \begin{exercise}
%ğŸ%
%ğŸ% Download the code from this chapter from
%ğŸ% \url{http://thinkpython2.com/code/Time2.py}.  Change the attributes of
%ğŸ%     {\tt Time} to be a single integer representing seconds since
%ğŸ%     midnight.  Then modify the methods (and the function
%ğŸ%     \verb"int_to_time") to work with the new implementation.  You
%ğŸ%     should not have to modify the test code in {\tt main}.  When you
%ğŸ%     are done, the output should be the same as before.  Solution:
%ğŸ%     \url{http://thinkpython2.com/code/Time2_soln.py}.
%ğŸ%
%ğŸ% \end{exercise}

\begin{exercise}

\href{http://thinkpython2.com/code/Time2.py}{æ­¤å¤„}å¯ä¸‹è½½åˆ°æœ¬ç« çš„ä»£ç ã€‚
ä¿®æ”¹ {\em \li{Time}} ç±»çš„å±æ€§ï¼Œ ä½¿ç”¨ä¸€ä¸ªæ•´æ•°ä»£è¡¨è‡ªåˆå¤œé›¶ç‚¹å¼€å§‹çš„ç§’æ•°ã€‚
ç„¶åä¿®æ”¹ç±»çš„æ–¹æ³•(å’Œ {\em \li{int_to_time}} å‡½æ•° )ï¼Œ ä½¿å…¶é€‚ç”¨äºæ–°çš„å®ç°ã€‚
ä½ ä¸ç”¨ä¿®æ”¹ {\em \li{main}} å‡½æ•°ä¸­çš„æµ‹è¯•ä»£ç ã€‚    å®Œæˆä¹‹åï¼Œ ç¨‹åºçš„è¾“å‡ºåº”è¯¥å’Œä¹‹å‰ä¿æŒä¸€è‡´ã€‚

\href{http://thinkpython2.com/code/Time2_soln.py}{å‚è€ƒç­”æ¡ˆ}

\end{exercise}


\begin{exercise}
\label{kangaroo}
\index{default value!avoiding mutable}
\index{mutable object, as default value}
\index{worst bug}
\index{bug!worst}
\index{Kangaroo class}
\index{class!Kangaroo}

%ğŸ% This exercise is a cautionary tale about one of the most
%ğŸ% common, and difficult to find, errors in Python.
%ğŸ% Write a definition for a class named {\tt Kangaroo} with the following
%ğŸ% methods:

è¿™é“ä¹ é¢˜ä¸­åŒ…å«äº† Python ä¸­æœ€å¸¸è§ã€æœ€éš¾æ‰¾å‡ºæ¥çš„é”™è¯¯ã€‚
ç¼–å†™ä¸€ä¸ªå« {\em \li{Kangaroo}} çš„ç±»ï¼Œ åŒ…å«ä»¥ä¸‹æ–¹æ³•ï¼š

\begin{enumerate}

%ğŸ% \item An \verb"__init__" method that initializes an attribute named
%ğŸ% \verb"pouch_contents" to an empty list.
%ğŸ%
%ğŸ% \item A method named \verb"put_in_pouch" that takes an object
%ğŸ% of any type and adds it to \verb"pouch_contents".
%ğŸ%
%ğŸ% \item A \verb"__str__" method that returns a string representation
%ğŸ% of the Kangaroo object and the contents of the pouch.

\item ä¸€ä¸ª {\em \li{__init__}} æ–¹æ³•ï¼Œ åˆå§‹åŒ–ä¸€ä¸ªå« {\em \li{pounch_contents}} çš„å±æ€§ä¸ºç©ºåˆ—è¡¨ã€‚

\item ä¸€ä¸ªå« {\em \li{put_in_pounch}} çš„æ–¹æ³•ï¼Œ å°†ä¸€ä¸ªä»»æ„ç±»å‹çš„å¯¹è±¡åŠ å…¥ {\em \li{pounch_contents}}ã€‚

\item ä¸€ä¸ª {\em \li{__str__}} æ–¹æ³•ï¼Œ è¿”å› {\em \li{Kangaroo}} å¯¹è±¡çš„å­—ç¬¦ä¸²è¡¨ç¤ºå’Œ {\em \li{pounch}} ä¸­çš„å†…å®¹ã€‚

\end{enumerate}

%
%ğŸ% Test your code
%ğŸ% by creating two {\tt Kangaroo} objects, assigning them to variables
%ğŸ% named {\tt kanga} and {\tt roo}, and then adding {\tt roo} to the
%ğŸ% contents of {\tt kanga}'s pouch.

%ğŸ% Download \url{http://thinkpython2.com/code/BadKangaroo.py}.  It contains
%ğŸ% a solution to the previous problem with one big, nasty bug.
%ğŸ% Find and fix the bug.

%ğŸ% If you get stuck, you can download
%ğŸ% \url{http://thinkpython2.com/code/GoodKangaroo.py}, which explains the
%ğŸ% problem and demonstrates a solution.
%ğŸ% \index{aliasing}  \index{embedded object}  \index{object!embedded}

åˆ›å»ºä¸¤ä¸ª {\em \li{Kangaroo}} å¯¹è±¡ï¼Œ å°†å®ƒä»¬å‘½åä¸º {\em \li{kanga}} å’Œ {\em \li{roo}} ï¼Œ ç„¶åå°† {\em \li{roo}} åŠ å…¥ {\em \li{kanga}} çš„ {\em \li{pounch}} åˆ—è¡¨ï¼Œ ä»¥æ­¤æµ‹è¯•ä½ å†™çš„ä»£ç ã€‚

ä¸‹è½½ \href{http://thinkpython2.com/code/BadKangaroo.py}{è¿™æ®µä»£ç }ã€‚
å…¶ä¸­æœ‰ä¸€ä¸ªä¸Šè¿°ä¹ é¢˜çš„ç­”æ¡ˆï¼Œ ä½†æ˜¯å…¶ä¸­å­˜åœ¨ä¸€ä¸ªåˆå¤§åˆæ£˜æ‰‹çš„ {\em bug} ã€‚
æ‰¾å‡ºè¿™ä¸ª {\em bug} å¹¶ä¿®æ­£ã€‚

å¦‚æœä½ æ‰¾ä¸åˆ° {\em bug} ï¼Œ å¯ä»¥ä¸‹è½½\href{http://thinkpython2.com/code/GoodKangaroo.py}{å‚è€ƒç­”æ¡ˆ} ï¼Œ é‡Œé¢è§£é‡Šäº†é—®é¢˜æ‰€åœ¨å¹¶æä¾›äº†ä¸€ä¸ªè§£å†³æ–¹æ¡ˆã€‚


\end{exercise}

