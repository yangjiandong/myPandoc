
%ğŸ%
%ğŸ% \chapter{Fruitful functions  |  æœ‰è¿”å›å€¼çš„å‡½æ•°}
\chapter{æœ‰è¿”å›å€¼çš„å‡½æ•°}
\label{fruitchap}

%ğŸ% Many of the Python functions we have used, such as the math
%ğŸ% functions, produce return values.  But the functions we've written
%ğŸ% are all void: they have an effect, like printing a value
%ğŸ% or moving a turtle, but they don't have a return value.  In
%ğŸ% this chapter you will learn to write fruitful functions.

è®¸å¤šæˆ‘ä»¬å‰é¢ä½¿ç”¨è¿‡çš„ Python å‡½æ•°éƒ½ä¼šäº§ç”Ÿè¿”å›å€¼ï¼Œ å¦‚æ•°å­¦å‡½æ•°ã€‚
ä½†ç›®å‰æˆ‘ä»¬æ‰€å†™çš„å‡½æ•°éƒ½æ˜¯ç©ºå‡½æ•° (void): å®ƒä»¬äº§ç”ŸæŸç§æ•ˆæœï¼Œ åƒæ‰“å°ä¸€ä¸ªå€¼æˆ–æ˜¯ç§»åŠ¨ä¹Œé¾Ÿï¼Œä½†æ˜¯å¹¶æ²¡æœ‰è¿”å›å€¼ã€‚
åœ¨æœ¬ç« ä¸­ï¼Œ ä½ å°†å­¦ä¹ å¦‚ä½•å†™ä¸€ä¸ªæœ‰è¿”å›å€¼çš„å‡½æ•°ã€‚

%ğŸ% \section{Return values  |  è¿”å›å€¼}
\section{è¿”å›å€¼}
\index{return value}  \index{è¿”å›å€¼}

%ğŸ% Calling the function generates a return
%ğŸ% value, which we usually assign to a variable or use as part of an
%ğŸ% expression.

è°ƒç”¨ä¸€ä¸ªæœ‰è¿”å›å€¼çš„å‡½æ•°ä¼šç”Ÿæˆä¸€ä¸ªè¿”å›å€¼ï¼Œ æˆ‘ä»¬é€šå¸¸å°†å…¶èµ‹å€¼ç»™æŸä¸ªå˜é‡æˆ–æ˜¯ä½œä¸ºè¡¨è¾¾å¼çš„ä¸€éƒ¨åˆ†ã€‚

\begin{lstlisting}
e = math.exp(1.0)
height = radius * math.sin(radians)
\end{lstlisting}

%
%ğŸ% The functions we have written so far are void.  Speaking casually,
%ğŸ% they have no return value; more precisely,
%ğŸ% their return value is {\tt None}.

ç›®å‰æˆ‘ä»¬æ‰€å†™çš„å‡½æ•°éƒ½æ˜¯ç©ºå‡½æ•°ã€‚
æ³›æ³›åœ°æ¥çœ‹ï¼Œ å®ƒä»¬æ²¡æœ‰è¿”å›å€¼ï¼› æ›´å‡†ç¡®åœ°è¯´ï¼Œ å®ƒä»¬çš„è¿”å›å€¼æ˜¯ \li{None} ã€‚

%ğŸ% In this chapter, we are (finally) going to write fruitful functions.
%ğŸ% The first example is {\tt area}, which returns the area of a circle
%ğŸ% with the given radius:

æœ¬ç« ä¸­ï¼Œ æˆ‘ä»¬ï¼ˆç»ˆäºï¼‰è¦å¼€å§‹å†™æœ‰è¿”å›å€¼çš„å‡½æ•°äº†ã€‚
ç¬¬ä¸€ä¸ªä¾‹å­æ˜¯ \li{area} ï¼Œ è¿”å›ç»™å®šåŠå¾„åœ†çš„é¢ç§¯ã€‚

\begin{lstlisting}
def area(radius):
    a = math.pi * radius**2
    return a
\end{lstlisting}

%
%ğŸ% We have seen the {\tt return} statement before, but in a fruitful
%ğŸ% function the {\tt return} statement includes
%ğŸ% an expression.  This statement means: ``Return immediately from
%ğŸ% this function and use the following expression as a return value.''
%ğŸ% The expression can be arbitrarily complicated, so we could
%ğŸ% have written this function more concisely:

æˆ‘ä»¬ä¹‹å‰å·²ç»è§è¿‡ \li{return} è¯­å¥ï¼Œä½†åœ¨æœ‰è¿”å›å€¼çš„å‡½æ•°ä¸­ï¼Œ \li{return} è¯­å¥åŒ…å«ä¸€ä¸ªè¡¨è¾¾å¼ã€‚
æ¡è¯­å¥çš„æ„æ€æ˜¯ï¼š``é©¬ä¸Šä»è¯¥å‡½æ•°è¿”å›ï¼Œå¹¶ä½¿ç”¨æ¥ä¸‹æ¥çš„è¡¨è¾¾å¼ä½œä¸ºè¿”å›å€¼ã€‚''
æ­¤è¡¨è¾¾å¼å¯ä»¥æ˜¯ä»»æ„å¤æ‚çš„ï¼Œ å› æ­¤æˆ‘ä»¬å¯ä»¥å°†è¯¥å‡½æ•°å†™å¾—æ›´ç®€æ´äº›ï¼š
\index{return statement}  \index{statement!return}

\begin{lstlisting}
def area(radius):
    return math.pi * radius**2
\end{lstlisting}

%
%ğŸ% On the other hand, {\bf temporary variables} like {\tt a} can make
%ğŸ% debugging easier.

å¦ä¸€æ–¹é¢ï¼Œ åƒ \li{a} è¿™æ ·çš„ {\em ä¸´æ—¶å˜é‡} (temporary variables) èƒ½ä½¿è°ƒè¯•å˜å¾—æ›´ç®€å•ã€‚

\index{temporary variable}  \index{variable!temporary}

%ğŸ% Sometimes it is useful to have multiple return statements, one in each
%ğŸ% branch of a conditional:

æœ‰æ—¶ï¼Œåœ¨æ¡ä»¶è¯­å¥çš„æ¯ä¸€ä¸ªåˆ†æ”¯å†…å„æœ‰ä¸€ä¸ªè¿”å›è¯­å¥ä¼šå¾ˆæœ‰ç”¨ï¼š

\begin{lstlisting}
def absolute_value(x):
    if x < 0:
        return -x
    else:
        return x
\end{lstlisting}

%
%ğŸ% Since these {\tt return} statements are in an alternative conditional,
%ğŸ% only one runs.

å› ä¸ºè¿™äº› \li{return} è¯­å¥åœ¨ä¸åŒçš„æ¡ä»¶å†…ï¼Œæœ€ååªæœ‰{\bf ä¸€ä¸ª}ä¼šè¢«æ‰§è¡Œã€‚

%ğŸ% As soon as a return statement runs, the function
%ğŸ% terminates without executing any subsequent statements.
%ğŸ% Code that appears after a {\tt return} statement, or any other place
%ğŸ% the flow of execution can never reach, is called {\bf dead code}.

ä¸€æ—¦ä¸€æ¡è¿”å›è¯­å¥æ‰§è¡Œï¼Œå‡½æ•°åˆ™ç»ˆæ­¢ï¼Œä¸å†æ‰§è¡Œåç»­çš„è¯­å¥ã€‚å‡ºç°åœ¨æŸæ¡returnè¯­å¥ä¹‹åçš„ä»£ç ï¼Œæˆ–è€…åœ¨æ‰§è¡Œæµç¨‹æ°¸è¿œä¸ä¼šåˆ°è¾¾ä¹‹å¤„çš„ä»£ç ï¼Œè¢«ç§°ä¸º {\em æ­»ä»£ç } (dead code)ã€‚
\index{dead code}  \index{æ­»ä»£ç }

%ğŸ% In a fruitful function, it is a good idea to ensure
%ğŸ% that every possible path through the program hits a
%ğŸ% {\tt return} statement.  For example:

åœ¨ä¸€ä¸ªæœ‰è¿”å›å€¼çš„å‡½æ•°ä¸­ï¼Œ æœ€å¥½ä¿è¯ç¨‹åºæ‰§è¡Œçš„æ¯ä¸€ä¸ªæµç¨‹æœ€ç»ˆéƒ½ä¼šç¢°åˆ°ä¸€ä¸ª \li{return} è¯­å¥ã€‚ä¾‹å¦‚ï¼š

\begin{lstlisting}
def absolute_value(x):
    if x < 0:
        return -x
    if x > 0:
        return x
\end{lstlisting}

%
%ğŸ% This function is incorrect because if {\tt x} happens to be 0,
%ğŸ% neither condition is true, and the function ends without hitting a
%ğŸ% {\tt return} statement.  If the flow of execution gets to the end
%ğŸ% of a function, the return value is {\tt None}, which is not
%ğŸ% the absolute value of 0.

è¿™ä¸ªå‡½æ•°æ˜¯æœ‰é—®é¢˜çš„ã€‚ åŸå› æ˜¯å¦‚æœ \li{x} æ°å¥½æ˜¯ 0ï¼Œ åˆ™æ²¡æœ‰æ¡ä»¶ä¸ºçœŸï¼Œ å‡½æ•°å°†ä¼šåœ¨æœªæ‰§è¡Œä»»ä½• \li{return} è¯­å¥çš„æƒ…å†µä¸‹ç»ˆæ­¢ã€‚ å¦‚æœå‡½æ•°æŒ‰ç…§è¿™ç§æ‰§è¡Œæµç¨‹æ‰§è¡Œå®Œæ¯•ï¼Œè¿”å›å€¼å°†æ˜¯ \li{None} ï¼Œè¿™å¯ä¸æ˜¯ 0 çš„ç»å¯¹å€¼ã€‚
\index{None special value}  \index{special value!None}

\begin{lstlisting}
>>> absolute_value(0)
None
\end{lstlisting}

%
%ğŸ% By the way, Python provides a built-in function called
%ğŸ% {\tt abs} that computes absolute values.

é¡ºä¾¿è¯´ä¸€ä¸‹ï¼ŒPythonæä¾›äº†ä¸€ä¸ªçš„å†…å»ºå‡½æ•° \li{abs} ç”¨æ¥è®¡ç®—ç»å¯¹å€¼ã€‚
\index{abs function}  \index{function!abs}

%ğŸ% As an exercise, write a {\tt compare} function
%ğŸ% takes two values, {\tt x} and {\tt y}, and returns {\tt 1} if {\tt x > y},
%ğŸ% {\tt 0} if {\tt x == y}, and {\tt -1} if {\tt x < y}.

æˆ‘ä»¬æ¥åšä¸ªç»ƒä¹ ï¼Œå†™ä¸€ä¸ªæ¯”è¾ƒå‡½æ•° \li{compare} ï¼Œæ¥å—ä¸¤ä¸ªå€¼ \li{x} å’Œ \li{y} ã€‚
å¦‚æœ \li{x > y}ï¼Œ åˆ™è¿”å› \li{1} ï¼›å¦‚æœ \li{x == y}ï¼Œ åˆ™è¿”å› \li{0} ï¼›å¦‚æœ \li{x < y}ï¼Œåˆ™è¿”å› \li{-1} ã€‚
\index{compare function}  \index{function!compare}


%ğŸ% \section{Incremental development  |  å¢é‡å¼å¼€å‘}
\section{å¢é‡å¼å¼€å‘}
\label{incremental.development}
\index{development plan!incremental}  \index{å¼€å‘è®¡åˆ’!å¢é‡å¼}

%ğŸ% As you write larger functions, you might find yourself
%ğŸ% spending more time debugging.

éšç€ä½ å†™çš„å‡½æ•°è¶Šæ¥è¶Šå¤§ï¼Œä½ åœ¨è°ƒè¯•ä¸ŠèŠ±çš„æ—¶å€™å¯èƒ½ä¼šè¶Šæ¥è¶Šå¤šã€‚

%ğŸ% To deal with increasingly complex programs,
%ğŸ% you might want to try a process called
%ğŸ% {\bf incremental development}.  The goal of incremental development
%ğŸ% is to avoid long debugging sessions by adding and testing only
%ğŸ% a small amount of code at a time.

ä¸ºäº†åº”å¯¹è¶Šæ¥è¶Šå¤æ‚çš„ç¨‹åºï¼Œä½ å¯ä»¥å¼€å§‹å°è¯•å«ä½œ {\em å¢é‡å¼å¼€å‘} (incremental development) çš„æ–¹æ³•ã€‚ å¢é‡å¼å¼€å‘çš„ç›®æ ‡ï¼Œæ˜¯é€šè¿‡æ¯æ¬¡åªå¢åŠ å’Œæµ‹è¯•å°‘é‡ä»£ç ï¼Œæ¥é¿å…é•¿æ—¶é—´çš„è°ƒè¯•ã€‚
\index{testing!incremental development}  \index{Pythagorean theorem}
\index{æµ‹è¯•!å¢é‡å¼€å‘}

%ğŸ% As an example, suppose you want to find the distance between two
%ğŸ% points, given by the coordinates $(x_1, y_1)$ and $(x_2, y_2)$.
%ğŸ% By the Pythagorean theorem, the distance is:

ä¸¾ä¸ªä¾‹å­ï¼Œå‡è®¾ä½ æƒ³è®¡ç®—ä¸¤ä¸ªç»™å®šåæ ‡ç‚¹ $(x_1, y_1)$ å’Œ $(x_2, y_2)$ ä¹‹é—´çš„è·ç¦»ã€‚æ ¹æ®æ¯•è¾¾å“¥æ‹‰æ–¯å®šç†\footnote{è¯‘æ³¨ï¼šthe Pythagorean theorem, å³å‹¾è‚¡å®šç†}ï¼ŒäºŒè€…çš„è·ç¦»æ˜¯ï¼š


\begin{displaymath}
\mathrm{distance} = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}
\end{displaymath}

%
%ğŸ% The first step is to consider what a {\tt distance} function should
%ğŸ% look like in Python.  In other words, what are the inputs (parameters)
%ğŸ% and what is the output (return value)?

ç¬¬ä¸€æ­¥è¦è€ƒè™‘çš„æ˜¯åœ¨ Python ä¸­ï¼Œè·ç¦»å‡½æ•°çœ‹èµ·æ¥ä¼šæ˜¯ä»€ä¹ˆæ ·ã€‚æ¢å¥è¯è¯´ï¼Œè¾“å…¥ï¼ˆå½¢å‚ï¼‰å’Œè¾“å‡ºï¼ˆè¿”å›å€¼ï¼‰æ˜¯ä»€ä¹ˆï¼Ÿ

%ğŸ% In this case, the inputs are two points, which you can represent
%ğŸ% using four numbers.  The return value is the distance represented by
%ğŸ% a floating-point value.

æœ¬ä¾‹ä¸­ï¼Œè¾“å…¥æ˜¯å¯ä»¥ç”¨ 4 ä¸ªæ•°è¡¨ç¤ºçš„ä¸¤ä¸ªç‚¹ã€‚ è¿”å›å€¼æ˜¯è·ç¦»ï¼Œ ç”¨æµ®ç‚¹æ•°è¡¨ç¤ºã€‚

%ğŸ% Immediately you can write an outline of the function:

ç°åœ¨ä½ å°±å¯ä»¥å†™å‡ºæ­¤å‡½æ•°çš„è½®å»“äº†ï¼š

\begin{lstlisting}
def distance(x1, y1, x2, y2):
    return 0.0
\end{lstlisting}

%
%ğŸ% Obviously, this version doesn't compute distances; it always returns
%ğŸ% zero.  But it is syntactically correct, and it runs, which means that
%ğŸ% you can test it before you make it more complicated.

æ˜¾ç„¶ï¼Œæ­¤ç‰ˆæœ¬ä¸èƒ½è®¡ç®—è·ç¦»ï¼›å®ƒæ€»æ˜¯è¿”å› 0 ã€‚ä½†æ˜¯åœ¨è¯­æ³•ä¸Šå®ƒæ˜¯æ­£ç¡®çš„ï¼Œå¹¶ä¸”èƒ½è¿è¡Œï¼Œè¿™æ„å‘³ç€ä½ å¯ä»¥åœ¨ä½¿å®ƒå˜å¾—æ›´å¤æ‚ä¹‹å‰æµ‹è¯•å®ƒã€‚

%ğŸ% To test the new function, call it with sample arguments:

ç”¨æ ·ä¾‹å®å‚è°ƒç”¨å®ƒæ¥è¿›è¡Œæµ‹è¯•ã€‚

\begin{lstlisting}
>>> distance(1, 2, 4, 6)
0.0
\end{lstlisting}

%
%ğŸ% I chose these values so that the horizontal distance is 3 and the
%ğŸ% vertical distance is 4; that way, the result is 5, the hypotenuse
%ğŸ% of a 3-4-5 triangle. When testing a function, it is
%ğŸ% useful to know the right answer.

æˆ‘é€‰æ‹©çš„è¿™äº›å€¼ï¼Œå¯ä»¥ä½¿æ°´å¹³è·ç¦»ä¸º 3 ï¼Œå‚ç›´è·ç¦»ä¸º 4 ï¼›
è¿™æ ·ç»“æœè‡ªç„¶æ˜¯ 5ï¼Œæ„æˆäº†ä¸€ä¸ªå‹¾ä¸‰è‚¡å››å¼¦äº”çš„ç›´è§’ä¸‰è§’å½¢ã€‚
æµ‹è¯•ä¸€ä¸ªå‡½æ•°æ—¶ï¼ŒçŸ¥é“æ­£ç¡®çš„ç­”æ¡ˆæ˜¯å¾ˆæœ‰ç”¨çš„ã€‚
\index{testing!knowing the answer}
\index{æµ‹è¯•!å·²çŸ¥ç»“æœ}

%ğŸ% At this point we have confirmed that the function is syntactically
%ğŸ% correct, and we can start adding code to the body.
%ğŸ% A reasonable next step is to find the differences
%ğŸ% $x_2 - x_1$ and $y_2 - y_1$.  The next version stores those values in
%ğŸ% temporary variables and prints them.

æ­¤æ—¶æˆ‘ä»¬å·²ç»ç¡®è®¤è¿™ä¸ªå‡½æ•°åœ¨è¯­æ³•ä¸Šæ˜¯æ­£ç¡®çš„ï¼Œæˆ‘ä»¬å¯ä»¥å¼€å§‹å¾€å‡½æ•°ä½“ä¸­å¢åŠ ä»£ç ã€‚
ä¸‹ä¸€æ­¥åˆç†çš„æ“ä½œï¼Œåº”è¯¥æ˜¯æ±‚ $x_2 - x_1$ å’Œ $y_2 - y_1$ è¿™ä¸¤ä¸ªå·®å€¼ã€‚
ä¸‹ä¸€ä¸ªç‰ˆæœ¬åœ¨ä¸´æ—¶å˜é‡ä¸­å­˜å‚¨è¿™äº›å€¼å¹¶æ‰“å°å‡ºæ¥ã€‚

\begin{lstlisting}
def distance(x1, y1, x2, y2):
    dx = x2 - x1
    dy = y2 - y1
    print('dx is', dx)
    print('dy is', dy)
    return 0.0
\end{lstlisting}

%
%ğŸ% If the function is working, it should display \verb"dx is 3" and
%ğŸ% \verb"dy is 4".  If so, we know that the function is getting the right
%ğŸ% arguments and performing the first computation correctly.  If not,
%ğŸ% there are only a few lines to check.

å¦‚æœè¿™ä¸ªå‡½æ•°æ­£å¸¸è¿è¡Œï¼Œå®ƒåº”è¯¥æ˜¾ç¤º \li{dx is 3}  ä»¥åŠ \li{dy is 4} ã€‚
è¿™æ ·çš„è¯æˆ‘ä»¬å°±çŸ¥é“å‡½æ•°è·å¾—äº†æ­£ç¡®çš„å®å‚å¹¶ä¸”æ­£ç¡®æ‰§è¡Œäº†ç¬¬ä¸€æ­¥è®¡ç®—ã€‚
å¦‚æœä¸æ˜¯ï¼Œä¹Ÿåªè¦æ£€æŸ¥å‡ è¡Œä»£ç ã€‚

%ğŸ% Next we compute the sum of squares of {\tt dx} and {\tt dy}:

ä¸‹ä¸€æ­¥æˆ‘ä»¬è®¡ç®— \li{dx} å’Œ \li{dy} çš„å¹³æ–¹å’Œã€‚

\begin{lstlisting}
def distance(x1, y1, x2, y2):
    dx = x2 - x1
    dy = y2 - y1
    dsquared = dx**2 + dy**2
    print('dsquared is: ', dsquared)
    return 0.0
\end{lstlisting}

%
%ğŸ% Again, you would run the program at this stage and check the output
%ğŸ% (which should be 25).
%ğŸ% Finally, you can use {\tt math.sqrt} to compute and return the result:

å†ä¸€æ¬¡è¿è¡Œç¨‹åºå¹¶æ£€æŸ¥ç»“æœ (åº”è¯¥æ˜¯ 25 )ã€‚
æœ€åï¼Œä½ å¯ä»¥ä½¿ç”¨ \li{math.sqrt} è®¡ç®—å¹¶è¿”å›ç»“æœã€‚
\index{sqrt}  \index{function!sqrt}

\begin{lstlisting}
def distance(x1, y1, x2, y2):
    dx = x2 - x1
    dy = y2 - y1
    dsquared = dx**2 + dy**2
    result = math.sqrt(dsquared)
    return result
\end{lstlisting}

%
%ğŸ% If that works correctly, you are done.  Otherwise, you might
%ğŸ% want to print the value of {\tt result} before the return
%ğŸ% statement.

å¦‚æœå…¶æ­£ç¡®è¿è¡Œçš„è¯ï¼Œä½ å°±æˆåŠŸäº†ã€‚å¦åˆ™ä½ å¯èƒ½æƒ³åœ¨ \li{return} è¯­å¥å‰æ‰“å°ç»“æœæ£€æŸ¥ä¸€ä¸‹ã€‚

%ğŸ% The final version of the function doesn't display anything when it
%ğŸ% runs; it only returns a value.  The {\tt print} statements we wrote
%ğŸ% are useful for debugging, but once you get the function working, you
%ğŸ% should remove them.  Code like that is called {\bf scaffolding}
%ğŸ% because it is helpful for building the program but is not part of the
%ğŸ% final product.

è¯¥å‡½æ•°çš„æœ€ç»ˆç‰ˆä¸ä¼šåœ¨è¿è¡Œæ—¶æ˜¾ç¤ºä»»ä½•ä¸œè¥¿ï¼Œä»…ä»…è¿”å›ä¸€ä¸ªå€¼ã€‚
æˆ‘ä»¬ä¹‹å‰å†™çš„ \li{print} è¯­å¥åœ¨è°ƒè¯•æ—¶æ˜¯å¾ˆæœ‰ç”¨çš„ï¼Œ ä¸è¿‡åœ¨å‡½æ•°èƒ½å¤Ÿæ­£ç¡®è¿è¡Œä¹‹åï¼Œ ä½ å°±è¯¥åˆ äº†å®ƒä»¬ã€‚
æˆ‘ä»¬ç§°è¿™æ ·çš„ä»£ç ä¸º {\em è„šæ‰‹æ¶ä»£ç } (scaffolding) ï¼Œ å› ä¸ºå®ƒå¯¹ç¨‹åºçš„æ„å»ºå¾ˆæœ‰ç”¨ï¼Œ ä½†ä¸æ˜¯æœ€ç»ˆäº§å“çš„ä¸€éƒ¨åˆ†ã€‚
\index{scaffolding}

%ğŸ% When you start out, you should add only a line or two of code at a
%ğŸ% time.  As you gain more experience, you might find yourself writing
%ğŸ% and debugging bigger chunks.  Either way, incremental development
%ğŸ% can save you a lot of debugging time.

å½“ä½ åˆšå¼€å§‹çš„æ—¶å€™ï¼Œ æœ€å¥½æ¯æ¬¡åªåŠ å…¥ä¸€ä¸¤è¡Œä»£ç ã€‚
éšç€ç»éªŒè§é•¿ï¼Œ ä½ ä¼šå‘ç°è‡ªå·±å¯ä»¥ç¼–å†™ã€è°ƒè¯•æ›´å¤§çš„ä»£ç å—äº†ã€‚
æ— è®ºå“ªç§æ–¹å¼ï¼Œ å¢é‡å¼å¼€å‘éƒ½èƒ½èŠ‚çœä½ å¤§é‡çš„è°ƒè¯•æ—¶é—´ã€‚

%ğŸ% The key aspects of the process are:

è¿™ç§å¼€å‘æ–¹å¼çš„å…³é”®æ˜¯ï¼š


%ğŸ% \begin{enumerate}
%ğŸ% \item Start with a working program and make small incremental changes.
%ğŸ% At any point, if there is an error, you should have a good idea
%ğŸ% where it is.
%ğŸ%
%ğŸ% \item Use variables to hold intermediate values so you can
%ğŸ% display and check them.
%ğŸ%
%ğŸ% \item Once the program is working, you might want to remove some of
%ğŸ% the scaffolding or consolidate multiple statements into compound
%ğŸ% expressions, but only if it does not make the program difficult to
%ğŸ% read.
%ğŸ% \end{enumerate}

\begin{enumerate}
\item ä»ä¸€ä¸ªèƒ½è¿è¡Œçš„ç¨‹åºå¼€å§‹ï¼Œå¹¶ä¸”æ¯æ¬¡åªå¢åŠ å°‘é‡æ”¹åŠ¨ã€‚æ— è®ºä½ ä½•æ—¶é‡åˆ°é”™è¯¯ï¼Œéƒ½èƒ½å¤Ÿæ¸…æ¥šå®šä½é”™è¯¯çš„æºå¤´ã€‚

\item ç”¨ä¸´æ—¶å˜é‡å­˜å‚¨ä¸­é—´å€¼ï¼Œè¿™æ ·ä½ å°±èƒ½æ˜¾ç¤ºå¹¶æ£€æŸ¥å®ƒä»¬ã€‚

\item ä¸€æ—¦ç¨‹åºæ­£ç¡®è¿è¡Œï¼Œä½ è¦åˆ é™¤ä¸€äº›è„šæ‰‹æ¶ä»£ç ï¼Œæˆ–è€…å°†å¤šæ¡è¯­å¥ç»„æˆå¤åˆè¡¨è¾¾å¼ï¼Œä½†æ˜¯å‰ææ˜¯ä¸ä¼šå½±å“ç¨‹åºçš„å¯è¯»æ€§ã€‚
\end{enumerate}

%ğŸ% As an exercise, use incremental development to write a function
%ğŸ% called {\tt hypotenuse} that returns the length of the hypotenuse of a
%ğŸ% right triangle given the lengths of the other two legs as arguments.
%ğŸ% Record each stage of the development process as you go.

æˆ‘ä»¬æ¥åšä¸ªç»ƒä¹ ï¼šè¿ç”¨å¢é‡å¼€å‘æ–¹å¼ï¼Œå†™ä¸€ä¸ªå«ä½œ \li{hypotenuse} çš„å‡½æ•°ï¼Œæ¥å—ç›´è§’ä¸‰è§’å½¢çš„ä¸¤ç›´è§’è¾¹é•¿ä½œä¸ºå®å‚ï¼Œè¿”å›è¯¥ä¸‰è§’å½¢æ–œè¾¹çš„é•¿åº¦ã€‚è®°å½•ä¸‹ä½ å¼€å‘è¿‡ç¨‹ä¸­çš„æ¯ä¸€æ­¥ã€‚
\index{hypotenuse}



%ğŸ% \section{Composition  |  ç»„åˆ}
\section{ç»„åˆ}
\index{composition}  \index{function composition}

%ğŸ% As you should expect by now, you can call one function from within
%ğŸ% another.  As an example, we'll write a function that takes two points,
%ğŸ% the center of the circle and a point on the perimeter, and computes
%ğŸ% the area of the circle.

ä½ ç°åœ¨åº”è¯¥å·²ç»çŒœåˆ°äº†ï¼Œä½ å¯ä»¥ä»ä¸€ä¸ªå‡½æ•°å†…éƒ¨è°ƒç”¨å¦ä¸€ä¸ªå‡½æ•°ã€‚
ä½œä¸ºç¤ºä¾‹ï¼Œæˆ‘ä»¬æ¥ä¸‹æ¥å†™ä¸€ä¸ªå‡½æ•°ï¼Œæ¥å—ä¸¤ä¸ªç‚¹ä¸ºå‚æ•°ï¼Œåˆ†åˆ«æ˜¯åœ†å¿ƒå’Œåœ†å‘¨ä¸Šä¸€ç‚¹ï¼Œç„¶åè®¡ç®—åœ†çš„é¢ç§¯ã€‚

%ğŸ% Assume that the center point is stored in the variables {\tt xc} and
%ğŸ% {\tt yc}, and the perimeter point is in {\tt xp} and {\tt yp}. The
%ğŸ% first step is to find the radius of the circle, which is the distance
%ğŸ% between the two points.  We just wrote a function, {\tt
%ğŸ% distance}, that does that:

å‡è®¾åœ†å¿ƒåæ ‡å­˜å‚¨åœ¨å˜é‡ \li{xc} å’Œ \li{yc} ä¸­ï¼Œåœ†å‘¨ä¸Šçš„ç‚¹çš„åæ ‡å­˜å‚¨åœ¨ \li{xp} å’Œ \li{yp} ä¸­ã€‚ç¬¬ä¸€æ­¥æ˜¯è®¡ç®—åœ†åŠå¾„ï¼Œä¹Ÿå°±æ˜¯è¿™ä¸¤ä¸ªç‚¹çš„è·ç¦»ã€‚
æˆ‘ä»¬åˆšå†™çš„ \li{distance} å‡½æ•°å°±å¯ä»¥è®¡ç®—è·ç¦»ï¼š

\begin{lstlisting}
radius = distance(xc, yc, xp, yp)
\end{lstlisting}

%
%ğŸ% The next step is to find the area of a circle with that radius;
%ğŸ% we just wrote that, too:

ä¸‹ä¸€æ­¥æ˜¯ç”¨å¾—åˆ°çš„åŠå¾„è®¡ç®—åœ†é¢ç§¯ï¼›æˆ‘ä»¬ä¹Ÿåˆšå†™äº†è¿™æ ·çš„å‡½æ•°ï¼š

\begin{lstlisting}
result = area(radius)
\end{lstlisting}

%
%ğŸ% Encapsulating these steps in a function, we get:

å°†è¿™äº›æ­¥éª¤å°è£…åœ¨ä¸€ä¸ªå‡½æ•°ä¸­ï¼Œå¯ä»¥å¾—åˆ°ä¸‹é¢çš„å‡½æ•°ï¼š
\index{encapsulation}  \index{å°è£…}

\begin{lstlisting}
def circle_area(xc, yc, xp, yp):
    radius = distance(xc, yc, xp, yp)
    result = area(radius)
    return result
\end{lstlisting}

%
%ğŸ% The temporary variables {\tt radius} and {\tt result} are useful for
%ğŸ% development and debugging, but once the program is working, we can
%ğŸ% make it more concise by composing the function calls:

ä¸´æ—¶å˜é‡ \li{radius} å’Œ \li{result} å¯¹äºå¼€å‘è°ƒè¯•å¾ˆæœ‰ç”¨çš„ï¼Œä½†æ˜¯
ä¸€æ—¦å‡½æ•°æ­£ç¡®è¿è¡Œäº†ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡åˆå¹¶å‡½æ•°è°ƒç”¨ï¼Œå°†ç¨‹åºå˜å¾—æ›´ç®€æ´ï¼š

\begin{lstlisting}
def circle_area(xc, yc, xp, yp):
    return area(distance(xc, yc, xp, yp))
\end{lstlisting}

%

%ğŸ% \section{Boolean functions  |  å¸ƒå°”å‡½æ•°}
\section{å¸ƒå°”å‡½æ•°}
\label{boolean}

%ğŸ% Functions can return booleans, which is often convenient for hiding
%ğŸ% complicated tests inside functions.  \index{boolean function}
%ğŸ% For example:

å‡½æ•°å¯ä»¥è¿”å› {\em å¸ƒå°”å€¼} (booleans) ï¼Œ é€šå¸¸å¯¹äºéšè—å‡½æ•°å†…éƒ¨çš„å¤æ‚æµ‹è¯•ä»£ç éå¸¸æ–¹ä¾¿ã€‚ ä¾‹å¦‚ï¼š

\begin{lstlisting}
def is_divisible(x, y):
    if x % y == 0:
        return True
    else:
        return False
\end{lstlisting}


%ğŸ% It is common to give boolean functions names that sound like yes/no
%ğŸ% questions; \verb"is_divisible" returns either {\tt True} or {\tt False}
%ğŸ% to indicate whether {\tt x} is divisible by {\tt y}.

é€šå¸¸å¸ƒå°”å‡½æ•°åå¬èµ·æ¥åƒæ˜¯ä¸€ä¸ªç–‘é—®å¥ï¼Œå›ç­”ä¸æ˜¯ Yes å°±æ˜¯ Noï¼Œ \li{is_divisible} é€šè¿‡è¿”å› \li{True} æˆ– \li{False} æ¥è¡¨ç¤º \li{x} æ˜¯å¦å¯ä»¥è¢« \li{y} æ•´é™¤ã€‚

%ğŸ% Here is an example:

è¯·çœ‹ä¸‹é¢çš„ç¤ºä¾‹ï¼š

\begin{lstlisting}
>>> is_divisible(6, 4)
False
>>> is_divisible(6, 3)
True
\end{lstlisting}

%ğŸ% The result of the {\tt ==} operator is a boolean, so we can write the
%ğŸ% function more concisely by returning it directly:

\li{==} è¿ç®—ç¬¦çš„ç»“æœæ˜¯å¸ƒå°”å€¼ï¼Œå› æ­¤æˆ‘ä»¬ç›´æ¥è¿”å›å®ƒï¼Œè®©ä»£ç å˜å¾—æ›´ç®€æ´ã€‚

\begin{lstlisting}
def is_divisible(x, y):
    return x % y == 0
\end{lstlisting}

%
%ğŸ% Boolean functions are often used in conditional statements:

å¸ƒå°”å‡½æ•°é€šå¸¸è¢«ç”¨äºæ¡ä»¶è¯­å¥ä¸­ï¼š
\index{conditional statement}  \index{statement!conditional}

\begin{lstlisting}
if is_divisible(x, y):
    print('x is divisible by y')
\end{lstlisting}

%
%ğŸ% It might be tempting to write something like:

å¾ˆå®¹æ˜“å†™å‡ºä¸‹é¢è¿™æ ·çš„ä»£ç ï¼š

\begin{lstlisting}
if is_divisible(x, y) == True:
    print('x is divisible by y'
\end{lstlisting}

%
%ğŸ% But the extra comparison is unnecessary.

ä½†è¿™é‡Œçš„æ¯”è¾ƒæ˜¯å¤šä½™çš„ã€‚

%ğŸ% As an exercise, write a function \verb"is_between(x, y, z)" that
%ğŸ% returns {\tt True} if $x \le y \le z$ or {\tt False} otherwise.

æˆ‘ä»¬æ¥åšä¸ªç»ƒä¹ ï¼šå†™ä¸€ä¸ªå‡½æ•°  \li{is_between(x, y, z)} ï¼Œå¦‚æœ $x \le y \le z$ è¿”å› \li{True} å¦åˆ™è¿”å› \li{False}ã€‚

%ğŸ% \section{More recursion  |  å†è°ˆé€’å½’}
\section{å†è°ˆé€’å½’}
\label{more.recursion}
\index{recursion}  \index{Turing complete language}
\index{language!Turing complete}  \index{Turing, Alan}  \index{Turing Thesis}

%ğŸ% We have only covered a small subset of Python, but you might
%ğŸ% be interested to know that this subset is a {\em complete}
%ğŸ% programming language, which means that anything that can be
%ğŸ% computed can be expressed in this language.  Any program ever written
%ğŸ% could be rewritten using only the language features you have learned
%ğŸ% so far (actually, you would need a few commands to control devices
%ğŸ% like the mouse, disks, etc., but that's all).

æˆ‘ä»¬ç›®å‰åªä»‹ç»äº† Python ä¸­ä¸€ä¸ªå¾ˆå°çš„å­é›†ï¼Œä½†æ˜¯å½“ä½ çŸ¥é“è¿™ä¸ªå­é›†å·²ç»æ˜¯ä¸€ä¸ª {\em å®Œå¤‡çš„} ç¼–ç¨‹è¯­è¨€ï¼Œ ä½ å¯èƒ½ä¼šè§‰å¾—å¾ˆæœ‰æ„æ€ã€‚
è¿™æ„å‘³ä»»ä½•èƒ½è¢«è®¡ç®—çš„ä¸œè¥¿éƒ½èƒ½ç”¨è¿™ä¸ªè¯­è¨€è¡¨è¾¾ã€‚
æœ‰å²ä»¥æ¥æ‰€æœ‰çš„ç¨‹åºï¼Œ ä½ éƒ½å¯ä»¥ä»…ç”¨ç›®å‰å­¦è¿‡çš„è¯­è¨€ç‰¹æ€§é‡å†™ (äº‹å®ä¸Šï¼Œä½ å¯èƒ½è¿˜éœ€è¦ä¸€äº›å‘½ä»¤æ¥æ§åˆ¶é¼ æ ‡ã€ç£ç›˜ç­‰è®¾å¤‡ï¼Œä½†ä»…æ­¤è€Œå·²)ã€‚

%ğŸ% Proving that claim is a nontrivial exercise first accomplished by Alan
%ğŸ% Turing, one of the first computer scientists (some would argue that he
%ğŸ% was a mathematician, but a lot of early computer scientists started as
%ğŸ% mathematicians).  Accordingly, it is known as the Turing Thesis.
%ğŸ% For a more complete (and accurate) discussion of the Turing Thesis,
%ğŸ% I recommend Michael Sipser's book {\em Introduction to the
%ğŸ% Theory of Computation}.

é˜¿å…°Â·å›¾çµ (Alan Turing) é¦–æ¬¡è¯æ˜äº†è¿™ç§è¯´æ³•çš„æ­£ç¡®æ€§ï¼Œè¿™æ˜¯ä¸€é¡¹éå‡¡çš„å·¥ä½œã€‚
ä»–æ˜¯é¦–æ‰¹è®¡ç®—æœºç§‘å­¦å®¶ä¹‹ä¸€\footnote{ä¸€äº›äººè®¤ä¸ºä»–æ˜¯æ•°å­¦å®¶ï¼Œ
ä½†å¾ˆå¤šæ—©æœŸçš„è®¡ç®—æœºç§‘å­¦å®¶å‡ºèº«äºæ•°å­¦å®¶ã€‚}
ç›¸åº”åœ°ï¼Œè¿™è¢«ç§°ä¸ºå›¾çµç†è®ºã€‚å…³äºå›¾çµç†è®ºæ›´å®Œæ•´ï¼ˆå’Œæ›´å‡†ç¡®ï¼‰çš„è®¨è®ºï¼Œ
æˆ‘æ¨è Michael Sipser çš„ä¹¦ ã€Š{\em Introduction to the Theory of Computation}ã€‹ã€‚

%ğŸ% To give you an idea of what you can do with the tools you have learned
%ğŸ% so far, we'll evaluate a few recursively defined mathematical
%ğŸ% functions.  A recursive definition is similar to a circular
%ğŸ% definition, in the sense that the definition contains a reference to
%ğŸ% the thing being defined.  A truly circular definition is not very
%ğŸ% useful:

ä¸ºäº†è®©ä½ æ˜ç™½èƒ½ç”¨ç›®å‰å­¦è¿‡çš„å·¥å…·åšä»€ä¹ˆï¼Œæˆ‘ä»¬å°†è®¡ç®—ä¸€äº›é€’å½’å®šä¹‰çš„æ•°å­¦å‡½æ•°ã€‚
é€’å½’å®šä¹‰ç±»ä¼¼å¾ªç¯å®šä¹‰ï¼Œå› ä¸ºå®šä¹‰ä¸­åŒ…å«ä¸€ä¸ªå¯¹å·²ç»è¢«å®šä¹‰çš„äº‹ç‰©çš„å¼•ç”¨ã€‚
ä¸€ä¸ªçº¯ç²¹çš„å¾ªç¯å®šä¹‰å¹¶æ²¡æœ‰ä»€ä¹ˆç”¨ï¼š

%ğŸ% \begin{description}
%ğŸ%
%ğŸ% \item[vorpal:] An adjective used to describe something that is vorpal.
%ğŸ% \index{vorpal}  \index{circular definition}  \index{definition!circular}
%ğŸ%
%ğŸ% \end{description}

\begin{description}

\item[æ¼©æ¶¡çŠ¶ï¼š] ä¸€ä¸ªç”¨ä»¥æè¿°æ¼©æ¶¡çŠ¶ç‰©ä½“çš„å½¢å®¹è¯ã€‚
\index{vorpal}  \index{circular definition}  \index{definition!circular}

\end{description}

%ğŸ% If you saw that definition in the dictionary, you might be annoyed. On
%ğŸ% the other hand, if you looked up the definition of the factorial
%ğŸ% function, denoted with the symbol $!$, you might get something like
%ğŸ% this:

å¦‚æœä½ çœ‹åˆ°å­—å…¸é‡Œæ˜¯è¿™æ ·å®šä¹‰çš„ï¼Œä½ å¤§æ¦‚ä¼šç”Ÿæ°”ã€‚
å¦ä¸€æ–¹é¢ï¼Œå¦‚æœä½ æŸ¥æ‰¾ç”¨ $!$ ç¬¦å·è¡¨ç¤ºçš„é˜¶ä¹˜å‡½æ•°çš„å®šä¹‰ï¼Œ ä½ å¯èƒ½çœ‹åˆ°ç±»ä¼¼ä¸‹é¢çš„å†…å®¹ï¼š


%
\begin{eqnarray*}
&&  0! = 1 \\
&&  n! = n (n-1)!
\end{eqnarray*}

%
%ğŸ% This definition says that the factorial of 0 is 1, and the factorial
%ğŸ% of any other value, $n$, is $n$ multiplied by the factorial of $n-1$.

è¯¥å®šä¹‰æŒ‡å‡º $0$ çš„é˜¶ä¹˜æ˜¯ $1$ ï¼Œä»»ä½•å…¶ä»–å€¼ $n$ çš„é˜¶ä¹˜æ˜¯ $n$ ä¹˜ä»¥ $n-1$ çš„é˜¶ä¹˜ã€‚

%ğŸ% So $3!$ is 3 times $2!$, which is 2 times $1!$, which is 1 times
%ğŸ% $0!$. Putting it all together, $3!$ equals 3 times 2 times 1 times 1,
%ğŸ% which is 6.

æ‰€ä»¥ $3!$ çš„é˜¶ä¹˜æ˜¯ $3$ ä¹˜ä»¥ $2!$ ï¼Œå®ƒåˆæ˜¯ $2$ ä¹˜ä»¥ $1!$ ï¼Œ åè€…åˆæ˜¯ $1$ ä¹˜ä»¥ $0!$ ã€‚ æ”¾åˆ°ä¸€èµ·ï¼Œ $3!$ ç­‰äº $3$ ä¹˜ä»¥ $2$ ä¹˜ä»¥ $1$ ä¹˜ä»¥ $1$ ï¼Œç»“æœæ˜¯ $6$ ã€‚
\index{factorial function}  \index{function!factorial}
\index{recursive definition}

%ğŸ% If you can write a recursive definition of something, you can
%ğŸ% write a Python program to evaluate it. The first step is to decide
%ğŸ% what the parameters should be.  In this case it should be clear
%ğŸ% that {\tt factorial} takes an integer:

å¦‚æœä½ å¯ä»¥é€’å½’å®šä¹‰æŸä¸ªä¸œè¥¿ï¼Œä½ å°±å¯ä»¥å†™ä¸€ä¸ª Python ç¨‹åºè®¡ç®—å®ƒã€‚
ç¬¬ä¸€æ­¥æ˜¯å†³å®šåº”è¯¥æœ‰å“ªäº›å½¢å‚ã€‚åœ¨æ­¤ä¾‹ä¸­ \li{factorial} å‡½æ•°å¾ˆæ˜æ˜¾æ¥å—ä¸€ä¸ªæ•´å‹æ•°ï¼š

\begin{lstlisting}
def factorial(n):
\end{lstlisting}

%
%ğŸ% If the argument happens to be 0, all we have to do is return 1:

å¦‚æœå®å‚åˆšå¥½æ˜¯ 0 ï¼Œæˆ‘ä»¬å°±è¿”å› 1 ï¼š


\begin{lstlisting}
def factorial(n):
    if n == 0:
        return 1
\end{lstlisting}

%
%ğŸ% Otherwise, and this is the interesting part, we have to make a
%ğŸ% recursive call to find the factorial of $n-1$ and then multiply it by
%ğŸ% $n$:

å¦åˆ™ï¼Œå°±åˆ°äº†æœ‰æ„æ€çš„éƒ¨åˆ†ï¼Œæˆ‘ä»¬è¦è¿›è¡Œé€’å½’è°ƒç”¨æ¥æ‰¾åˆ° $n-1$ çš„é˜¶ä¹˜ç„¶åä¹˜ä»¥ $n$:

\begin{lstlisting}
def factorial(n):
    if n == 0:
        return 1
    else:
        recurse = factorial(n-1)
        result = n * recurse
        return result
\end{lstlisting}

%
%ğŸ% The flow of execution for this program is similar to the flow of {\tt
%ğŸ% countdown} in Section~\ref{recursion}.  If we call {\tt factorial}
%ğŸ% with the value 3:

ç¨‹åºçš„æ‰§è¡Œæµç¨‹å’Œç¬¬~\ref{recursion}èŠ‚ä¸­çš„ \li{countdown} ç±»ä¼¼ã€‚
å¦‚æœæˆ‘ä»¬ä¼ å…¥å‚æ•°çš„å€¼æ˜¯ 3 ï¼š


% \begin{lstlisting}
% \end{lstlisting}


%ğŸ% Since 3 is not 0, we take the second branch and calculate the factorial
%ğŸ% of {\tt n-1}...

ç”±äº3ä¸ç­‰äº0ï¼Œæˆ‘ä»¬æ‰§è¡Œç¬¬äºŒä¸ªåˆ†æ”¯å¹¶è®¡ç®—n-1çš„é˜¶ä¹˜...

\begin{quote}
%ğŸ% Since 2 is not 0, we take the second branch and calculate the factorial of
%ğŸ% {\tt n-1}...

ç”±äº2ä¸ç­‰äº0ï¼Œæˆ‘ä»¬æ‰§è¡Œç¬¬äºŒä¸ªåˆ†æ”¯å¹¶è®¡ç®—n-1çš„é˜¶ä¹˜...

  \begin{quote}
  %ğŸ% Since 1 is not 0, we take the second branch and calculate the factorial
  %ğŸ% of {\tt n-1}...

  ç”±äº1ä¸ç­‰äº0ï¼Œæˆ‘ä»¬æ‰§è¡Œç¬¬äºŒä¸ªåˆ†æ”¯å¹¶è®¡ç®—n-1çš„é˜¶ä¹˜...

    \begin{quote}
    %ğŸ% Since 0 equals 0, we take the first branch and return 1
    %ğŸ% without making any more recursive calls.

    ç”±äº0ç­‰äº0ï¼Œæˆ‘ä»¬æ‰§è¡Œç¬¬ä¸€ä¸ªåˆ†æ”¯å¹¶è¿”å›1ï¼Œä¸å†è¿›è¡Œä»»ä½•é€’å½’è°ƒç”¨ã€‚

    \end{quote}


  %ğŸ% The return value, 1, is multiplied by $n$, which is 1, and the
  %ğŸ% result is returned.

  è¿”å›å€¼ 1 ä¸ $n$ ï¼ˆå…¶ä¸º1ï¼‰ç›¸ä¹˜ï¼Œå¹¶è¿”å›ç»“æœã€‚
  \end{quote}


%ğŸ% The return value, 1, is multiplied by $n$, which is 2, and the
%ğŸ% result is returned.

è¿”å›å€¼ 1 ä¸ $n$ ï¼ˆå…¶ä¸º2ï¼‰ç›¸ä¹˜ï¼Œå¹¶è¿”å›ç»“æœã€‚
\end{quote}


%ğŸ% The return value (2) is multiplied by $n$, which is 3, and the result, 6,
%ğŸ% becomes the return value of the function call that started the whole
%ğŸ% process.

è¿”å›å€¼ 2 ä¸ $n$ ï¼ˆå…¶ä¸º3ï¼‰ç›¸ä¹˜ï¼Œè€Œç»“æœ6ä¹Ÿå°±æˆä¸ºä¸€å¼€å§‹é‚£ä¸ªå‡½æ•°è°ƒç”¨çš„è¿”å›å€¼ã€‚
\index{stack diagram}

%ğŸ% Figure~\ref{fig.stack3} shows what the stack diagram looks like for
%ğŸ% this sequence of function calls.

å›¾~\ref{fig.stack3} æ˜¾ç¤ºäº†è¯¥å‡½æ•°è°ƒç”¨åºåˆ—çš„å †æ ˆå›¾çœ‹ä¸Šå»æ˜¯ä»€ä¹ˆæ ·å­ã€‚

\begin{figure}
\centerline
{\includegraphics[scale=0.8]{../source/figs/stack3.pdf}}
\caption{å †æ ˆå›¾ã€‚}
\label{fig.stack3}
\end{figure}

%ğŸ% The return values are shown being passed back up the stack.  In each
%ğŸ% frame, the return value is the value of {\tt result}, which is the
%ğŸ% product of {\tt n} and {\tt recurse}.

å›¾ä¸­çš„è¿”å›å€¼è¢«æç»˜ä¸ºä¸æ–­è¢«ä¼ å›åˆ°æ ˆé¡¶ã€‚ åœ¨æ¯ä¸ªæ ˆå¸§ä¸­ï¼Œè¿”å›å€¼å°±æ˜¯ç»“æœå€¼ï¼Œå³æ˜¯ \li{n} å’Œ \li{recurse} çš„ä¹˜ç§¯ã€‚
\index{function frame}  \index{frame}

%ğŸ% In the last frame, the local variables {\tt recurse} and {\tt result} do not exist, because the branch that creates them does not run.

æœ€åä¸€å¸§ä¸­ï¼Œå±€éƒ¨å˜é‡ \li{recurse} å’Œ \li{result} å¹¶ä¸å­˜åœ¨ï¼Œ å› ä¸ºç”Ÿæˆå®ƒä»¬çš„åˆ†æ”¯å¹¶æ²¡æœ‰æ‰§è¡Œã€‚


%ğŸ% \section{Leap of faith  |  ä¿¡ä»°ä¹‹è·ƒ}
\section{ä¿¡ä»°ä¹‹è·ƒ}
\index{recursion}  \index{leap of faith}

%ğŸ% Following the flow of execution is one way to read programs, but
%ğŸ% it can quickly become overwhelming.  An
%ğŸ% alternative is what I call the ``leap of faith''.  When you come to a
%ğŸ% function call, instead of following the flow of execution, you {\em
%ğŸ% assume} that the function works correctly and returns the right
%ğŸ% result.

è·Ÿéšç¨‹åºæ‰§è¡Œæµç¨‹æ˜¯é˜…è¯»ç¨‹åºä»£ç çš„ä¸€ç§æ–¹æ³•ï¼Œä½†å®ƒå¯èƒ½å¾ˆå¿«ä¼šå˜å¾—é”™ç»¼å¤æ‚ã€‚
æœ‰å¦å¤–ä¸€ç§æ›¿ä»£æ–¹æ³•ï¼Œæˆ‘ç§°ä¹‹ä¸º``ä¿¡ä»°ä¹‹è·ƒ''ã€‚
å½“ä½ é‡åˆ°ä¸€ä¸ªå‡½æ•°è°ƒç”¨æ—¶ï¼Œä¸å†å»è·Ÿè¸ªæ‰§è¡Œæµç¨‹ï¼Œè€Œæ˜¯ {\bf å‡è®¾} è¿™ä¸ªå‡½æ•°æ­£ç¡®è¿è¡Œå¹¶è¿”å›äº†æ­£ç¡®çš„ç»“æœã€‚

%ğŸ% In fact, you are already practicing this leap of faith when you use
%ğŸ% built-in functions.  When you call {\tt math.cos} or {\tt math.exp},
%ğŸ% you don't examine the bodies of those functions.  You just
%ğŸ% assume that they work because the people who wrote the built-in
%ğŸ% functions were good programmers.

äº‹å®ä¸Šï¼Œå½“ä½ ä½¿ç”¨å†…å»ºå‡½æ•°æ—¶ï¼Œä½ å·²ç»åœ¨å®è·µè¿™ç§æ–¹æ³•äº†ã€‚
å½“ä½ è°ƒç”¨ \li{math.cos} æˆ– \li{math.exp} æ—¶ï¼Œä½ å¹¶æ²¡æœ‰æ£€æŸ¥é‚£äº›å‡½æ•°çš„å‡½æ•°ä½“ã€‚
ä½ åªæ˜¯å‡è®¾äº†å®ƒä»¬èƒ½ç”¨ï¼Œå› ä¸ºç¼–å†™è¿™äº›å†…å»ºå‡½æ•°çš„äººéƒ½æ˜¯ä¼˜ç§€çš„ç¨‹åºå‘˜ã€‚

%ğŸ% The same is true when you call one of your own functions.  For
%ğŸ% example, in Section~\ref{boolean}, we wrote a function called
%ğŸ% \verb"is_divisible" that determines whether one number is divisible by
%ğŸ% another.  Once we have convinced ourselves that this function is
%ğŸ% correct---by examining the code and testing---we can use the function
%ğŸ% without looking at the body again.

å½“ä½ è°ƒç”¨ä¸€ä¸ªè‡ªå·±å†™çš„å‡½æ•°æ—¶ä¹Ÿæ˜¯ä¸€æ ·ã€‚
ä¾‹å¦‚ï¼Œåœ¨ \ref{boolean} èŠ‚ä¸­ï¼Œæˆ‘ä»¬å†™äº†ä¸€ä¸ª \li{is_divisible} å‡½æ•°æ¥åˆ¤æ–­ä¸€ä¸ªæ•°èƒ½å¦è¢«å¦ä¸€ä¸ªæ•°æ•´é™¤ã€‚
é€šè¿‡å¯¹ä»£ç çš„æ£€æŸ¥ï¼Œä¸€æ—¦æˆ‘ä»¬ç¡®ä¿¡è¿™ä¸ªå‡½æ•°èƒ½å¤Ÿæ­£ç¡®è¿è¡Œ --- æˆ‘ä»¬å°±èƒ½ä¸ç”¨å†æŸ¥çœ‹å‡½æ•°ä½“è€Œç›´æ¥ä½¿ç”¨äº†ã€‚
\index{testing!leap of faith}

%ğŸ% The same is true of recursive programs.  When you get to the recursive
%ğŸ% call, instead of following the flow of execution, you should assume
%ğŸ% that the recursive call works (returns the correct result) and then ask
%ğŸ% yourself, ``Assuming that I can find the factorial of $n-1$, can I
%ğŸ% compute the factorial of $n$?''  It is clear that you
%ğŸ% can, by multiplying by $n$.

é€’å½’ç¨‹åºä¹Ÿæ˜¯è¿™æ ·ã€‚
å½“ä½ é‡åˆ°é€’å½’è°ƒç”¨æ—¶ï¼Œ ä¸ç”¨é¡ºç€æ‰§è¡Œæµç¨‹ï¼Œä½ åº”è¯¥å‡è®¾æ¯æ¬¡é€’å½’è°ƒç”¨èƒ½å¤Ÿæ­£ç¡®å·¥ä½œ (è¿”å›æ­£ç¡®çš„ç»“æœ)ï¼Œ ç„¶åé—®ä½ è‡ªå·±ï¼Œ``å‡è®¾æˆ‘å¯ä»¥æ‰¾åˆ° $n-1$ çš„é˜¶ä¹˜ï¼Œæˆ‘å¯ä»¥æ‰¾åˆ° $n$ çš„é˜¶ä¹˜å—ï¼Ÿ''
å¾ˆæ˜æ˜¾ä½ èƒ½ï¼Œåªè¦å†ä¹˜ä»¥ $n$ å³å¯ã€‚

%ğŸ% Of course, it's a bit strange to assume that the function works
%ğŸ% correctly when you haven't finished writing it, but that's why
%ğŸ% it's called a leap of faith!

å½“ç„¶ï¼Œåœ¨ä½ æ²¡å†™å®Œå‡½æ•°çš„æ—¶å°±å‡è®¾å‡½æ•°æ­£ç¡®å·¥ä½œæœ‰ä¸€ç‚¹å„¿å¥‡æ€ªï¼Œ ä½†è¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆè¿™è¢«ç§°ä½œä¿¡ä»°ä¹‹è·ƒäº†ï¼


%ğŸ% \section{One more example  |  å†ä¸¾ä¸€ä¾‹}
\section{å†ä¸¾ä¸€ä¾‹}
\label{one.more.example}

\index{fibonacci function}  \index{function!fibonacci}

%ğŸ% After {\tt factorial}, the most common example of a recursively
%ğŸ% defined mathematical function is {\tt fibonacci}, which has the
%ğŸ% following definition (see
  %ğŸ% \url{http://en.wikipedia.org/wiki/Fibonacci_number}):

é™¤äº†é˜¶ä¹˜ä»¥å¤–ï¼Œä½¿ç”¨é€’å½’å®šä¹‰çš„æœ€å¸¸è§æ•°å­¦å‡½æ•°æ˜¯ \li{fibonacci} (æ–æ³¢é‚£å¥‘æ•°åˆ—)ï¼Œè§å…¶ \href{http://en.wikipedia.org/wiki/Fibonacci_number}{å®šä¹‰} ï¼š

\index{ç»´åŸºç™¾ç§‘}

%
\begin{eqnarray*}
&& \mathrm{fibonacci}(0) = 0 \\
&& \mathrm{fibonacci}(1) = 1 \\
&& \mathrm{fibonacci}(n) = \mathrm{fibonacci}(n-1) + \mathrm{fibonacci}(n-2)
\end{eqnarray*}

%
%ğŸ% Translated into Python, it looks like this:

ç¿»è¯‘æˆ Python ï¼Œçœ‹èµ·æ¥å°±åƒè¿™æ ·ï¼š

\begin{lstlisting}
def fibonacci (n):
    if n == 0:
        return 0
    elif  n == 1:
        return 1
    else:
        return fibonacci(n-1) + fibonacci(n-2)
\end{lstlisting}

%
%ğŸ% If you try to follow the flow of execution here, even for fairly
%ğŸ% small values of $n$, your head explodes.  But according to the
%ğŸ% leap of faith, if you assume that the two recursive calls
%ğŸ% work correctly, then it is clear that you get
%ğŸ% the right result by adding them together.

è¿™é‡Œï¼Œå¦‚æœä½ è¯•å›¾è·Ÿè¸ªæ‰§è¡Œæµç¨‹ï¼Œå³ä½¿æ˜¯ç›¸å½“å°çš„ $n$ ï¼Œä¹Ÿè¶³å¤Ÿä½ å¤´ç–¼çš„ã€‚ä½†éµå¾ªä¿¡ä»°ä¹‹è·ƒè¿™ç§æ–¹æ³•ï¼Œå¦‚æœä½ å‡è®¾è¿™ä¸¤ä¸ªé€’å½’è°ƒç”¨éƒ½èƒ½æ­£ç¡®è¿è¡Œï¼Œå¾ˆæ˜æ˜¾å°†ä»–ä»¬ä¸¤ä¸ªç›¸åŠ å°±æ˜¯æ­£ç¡®ç»“æœã€‚

\index{flow of execution}


%ğŸ% \section{Checking types  |  æ£€æŸ¥ç±»å‹}
\section{æ£€æŸ¥ç±»å‹}
\label{guardian}

%ğŸ% What happens if we call {\tt factorial} and give it 1.5 as an argument?

å¦‚æœæˆ‘ä»¬å°† 1.5 ä½œä¸ºå‚æ•°è°ƒç”¨é˜¶ä¹˜å‡½æ•° ( \li{factorial} )ä¼šæ€æ ·ï¼Ÿ

\index{type checking}  \index{error checking}
\index{factorial function}  \index{RuntimeError}

\begin{lstlisting}
>>> factorial(1.5)
RuntimeError: Maximum recursion depth exceeded
\end{lstlisting}

%
%ğŸ% It looks like an infinite recursion.  How can that be?  The function
%ğŸ% has a base case---when {\tt n == 0}.  But if {\tt n} is not an integer,
%ğŸ% we can {\em miss} the base case and recurse forever.

çœ‹ä¸Šå»åƒæ˜¯ä¸€ä¸ªæ— é™å¾ªç¯ã€‚ä½†é‚£æ˜¯å¦‚ä½•å‘ç”Ÿçš„ï¼Ÿ å‡½æ•°çš„åŸºç¡€æƒ…å½¢æ˜¯ \li{n == 0} ã€‚
ä½†æ˜¯å¦‚æœ \li{n} ä¸æ˜¯ä¸€ä¸ªæ•´å‹æ•°å‘¢ï¼Œæˆ‘ä»¬ä¼š {\em é”™è¿‡} åŸºç¡€æƒ…å½¢ï¼Œæ°¸è¿œé€’å½’ä¸‹å»ã€‚
\index{infinite recursion}  \index{recursion!infinite}

%ğŸ% In the first recursive call, the value of {\tt n} is 0.5.
%ğŸ% In the next, it is -0.5.  From there, it gets smaller
%ğŸ% (more negative), but it will never be 0.

åœ¨ç¬¬ä¸€æ¬¡é€’å½’è°ƒç”¨ä¸­ï¼Œ\li{n} çš„å€¼æ˜¯ $0.5$ ã€‚ä¸‹ä¸€æ¬¡ï¼Œæ˜¯ $-0.5$ ã€‚è‡ªæ­¤å®ƒä¼šè¶Šæ¥è¶Šå°ï¼Œä½†æ°¸è¿œä¸ä¼šæ˜¯ $0$ ã€‚

%ğŸ%  We have two choices.  We can try to generalize the {\tt factorial}
%ğŸ%  function to work with floating-point numbers, or we can make {\tt
  %ğŸ%  factorial} check the type of its argument.  The first option is
%ğŸ%  called the gamma function and it's a
%ğŸ%  little beyond the scope of this book.  So we'll go for the second.

æˆ‘ä»¬æœ‰ä¸¤ä¸ªé€‰æ‹©ã€‚æˆ‘ä»¬å¯ä»¥è¯•ç€æ³›åŒ– \li{factorial} å‡½æ•°ï¼Œä½¿å…¶èƒ½å¤„ç†æµ®ç‚¹æ•°ï¼Œæˆ–è€…æˆ‘ä»¬å¯ä»¥è®© \li{factorial} æ£€æŸ¥å®å‚çš„ç±»å‹ã€‚ç¬¬ä¸€ä¸ªé€‰æ‹©è¢«ç§°ä½œ \li{gamma} å‡½æ•°ï¼Œå®ƒæœ‰ç‚¹å„¿è¶…è¿‡æœ¬ä¹¦çš„èŒƒå›´äº†ã€‚ æ‰€ä»¥æˆ‘ä»¬å°†é‡‡ç”¨ç¬¬äºŒç§æ–¹æ³•ã€‚
\index{gamma function}
\index{gamma å‡½æ•°}

%ğŸ% We can use the built-in function {\tt isinstance} to verify the type
%ğŸ% of the argument.  While we're at it, we can also make sure the
%ğŸ% argument is positive:

æˆ‘ä»¬å¯ä»¥ä½¿ç”¨å†…å»ºå‡½æ•° \li{isinstance} æ¥éªŒè¯å®å‚çš„ç±»å‹ã€‚ åŒæ—¶ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥ç¡®ä¿è¯¥å®å‚æ˜¯æ­£æ•°ï¼š
\index{isinstance function}  \index{function!isinstance}

\begin{lstlisting}
def factorial (n):
    if not isinstance(n, int):
        print('Factorial is only defined for integers.')
        return None
    elif n < 0:
        print('Factorial is not defined for negative integers.')
        return None
    elif n == 0:
        return 1
    else:
        return n * factorial(n-1)
\end{lstlisting}

%
%ğŸ% The first base case handles nonintegers; the
%ğŸ% second handles negative integers.  In both cases, the program prints
%ğŸ% an error message and returns {\tt None} to indicate that something
%ğŸ% went wrong:

ç¬¬ä¸€ä¸ªåŸºç¡€æƒ…å½¢å¤„ç†éæ•´å‹æ•°ï¼›ç¬¬äºŒä¸ªå¤„ç†è´Ÿæ•´å‹æ•°ã€‚
åœ¨è¿™ä¸¤ä¸ªæƒ…å½¢ä¸­ï¼Œç¨‹åºæ‰“å°ä¸€æ¡é”™è¯¯ä¿¡æ¯ï¼Œå¹¶è¿”å› \li{None} ä»¥æŒ‡æ˜å‡ºç°äº†é”™è¯¯ï¼š


\begin{lstlisting}
>>> factorial('fred')
Factorial is only defined for integers.
None
>>> factorial(-2)
Factorial is not defined for negative integers.
None
\end{lstlisting}

%
%ğŸ% If we get past both checks, we know that $n$ is positive or
%ğŸ% zero, so we can prove that the recursion terminates.

å¦‚æœæˆ‘ä»¬é€šè¿‡äº†è¿™ä¸¤ä¸ªæ£€æŸ¥ï¼Œé‚£ä¹ˆæˆ‘ä»¬çŸ¥é“ $n$ æ˜¯ä¸€ä¸ªæ­£æ•°æˆ– $0$ ï¼Œ å› æ­¤æˆ‘ä»¬å¯ä»¥è¯æ˜é€’å½’ä¼šç»ˆæ­¢ã€‚
\index{guardian pattern}  \index{pattern!guardian}

%ğŸ% This program demonstrates a pattern sometimes called a {\bf guardian}.
%ğŸ% The first two conditionals act as guardians, protecting the code that
%ğŸ% follows from values that might cause an error.  The guardians make it
%ğŸ% possible to prove the correctness of the code.

æ­¤ç¨‹åºæ¼”ç¤ºäº†ä¸€ä¸ªæœ‰æ—¶è¢«ç§°ä½œ {\em ç›‘æŠ¤äºº} (guardian) çš„æ¨¡å¼ã€‚
å‰ä¸¤ä¸ªæ¡ä»¶æ‰®æ¼”ç›‘æŠ¤äººçš„è§’è‰²ï¼Œé¿å…æ¥ä¸‹æ¥çš„ä»£ç ä½¿ç”¨å¼•å‘é”™è¯¯çš„å€¼ã€‚
ç›‘æŠ¤äººä½¿å¾—éªŒè¯ä»£ç çš„æ­£ç¡®æ€§æˆä¸ºå¯èƒ½ã€‚


%ğŸ% In Section~\ref{raise} we will see a more flexible alternative to printing
%ğŸ% an error message: raising an exception.

åœ¨\hyperref[raise]{åå‘æŸ¥æ‰¾} (Reverse Lookup) ä¸€èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†çœ‹åˆ°æ›´çµæ´»åœ°æ‰“å°é”™è¯¯ä¿¡æ¯çš„æ–¹å¼ï¼šæŠ›å‡ºå¼‚å¸¸ã€‚

%ğŸ% \section{Debugging  |  è°ƒè¯•}
\section{è°ƒè¯•}
\label{factdebug}

%ğŸ% Breaking a large program into smaller functions creates natural
%ğŸ% checkpoints for debugging.  If a function is not
%ğŸ% working, there are three possibilities to consider:

å°†ä¸€ä¸ªå¤§ç¨‹åºåˆ†è§£ä¸ºè¾ƒå°çš„å‡½æ•°ä¸ºè°ƒè¯•ç”Ÿæˆäº†è‡ªç„¶çš„æ£€æŸ¥ç‚¹ã€‚
å¦‚æœä¸€ä¸ªå‡½æ•°ä¸å¦‚é¢„æœŸçš„è¿è¡Œï¼Œæœ‰ä¸‰ä¸ªå¯èƒ½æ€§éœ€è¦è€ƒè™‘ï¼š

\index{debugging}

\begin{itemize}

%ğŸ% \item There is something wrong with the arguments the function
%ğŸ% is getting; a precondition is violated.

\item è¯¥å‡½æ•°è·å¾—çš„å®å‚æœ‰äº›é—®é¢˜ï¼Œè¿åå…ˆå†³æ¡ä»¶ã€‚

%ğŸ% \item There is something wrong with the function; a postcondition
%ğŸ% is violated.

\item è¯¥å‡½æ•°æœ‰äº›é—®é¢˜ï¼Œè¿ååç½®æ¡ä»¶ã€‚

%ğŸ% \item There is something wrong with the return value or the
%ğŸ% way it is being used.

\item è¿”å›å€¼æˆ–è€…å®ƒçš„ä½¿ç”¨æ–¹æ³•æœ‰é—®é¢˜ã€‚

\end{itemize}

%ğŸ% To rule out the first possibility, you can add a {\tt print} statement
%ğŸ% at the beginning of the function and display the values of the
%ğŸ% parameters (and maybe their types).  Or you can write code
%ğŸ% that checks the preconditions explicitly.

ä¸ºäº†æ’é™¤ç¬¬ä¸€ç§å¯èƒ½ï¼Œä½ å¯ä»¥åœ¨å‡½æ•°çš„å¼€å§‹å¢åŠ ä¸€æ¡ \li{print} è¯­å¥æ¥æ‰“å°å½¢å‚çš„å€¼ï¼ˆä¹Ÿå¯ä»¥æ˜¯å®ƒä»¬çš„ç±»å‹ï¼‰ã€‚
æˆ–è€…ä½ å¯ä»¥å†™ä»£ç æ¥æ˜¾ç¤ºåœ°æ£€æŸ¥å…ˆå†³æ¡ä»¶ã€‚
\index{precondition}  \index{postcondition}

%ğŸ% If the parameters look good, add a {\tt print} statement before each
%ğŸ% {\tt return} statement and display the return value.  If
%ğŸ% possible, check the result by hand.  Consider calling the
%ğŸ% function with values that make it easy to check the result
%ğŸ% (as in Section~\ref{incremental.development}).

å¦‚æœå½¢å‚çœ‹èµ·æ¥æ²¡é—®é¢˜ï¼Œå°±åœ¨æ¯ä¸ª \li{return} è¯­å¥ä¹‹å‰å¢åŠ ä¸€æ¡ \li{print} è¯­å¥ï¼Œæ¥æ‰“å°è¿”å›å€¼ã€‚
å¦‚æœå¯èƒ½ï¼Œæ‰‹å·¥æ£€æŸ¥ç»“æœã€‚
è€ƒè™‘ç”¨ä¸€äº›å®¹æ˜“æ£€æŸ¥çš„å€¼æ¥è°ƒç”¨è¯¥å‡½æ•°ï¼ˆç±»ä¼¼åœ¨ \hyperref[incremental.development]{å°èŠ‚} ä¸­é‚£æ ·ï¼‰ã€‚


%ğŸ% If the function seems to be working, look at the function call
%ğŸ% to make sure the return value is being used correctly (or used
%ğŸ% at all!).

å¦‚æœè¯¥å‡½æ•°çœ‹èµ·æ¥æ­£å¸¸å·¥ä½œï¼Œåˆ™æ£€æŸ¥å‡½æ•°è°ƒç”¨ï¼Œç¡®ä¿è¿”å›å€¼è¢«æ­£ç¡®çš„ä½¿ç”¨ï¼ˆæˆ–è€…çš„ç¡®è¢«ä½¿ç”¨äº†ï¼ï¼‰ã€‚
\index{flow of execution}

%ğŸ% Adding print statements at the beginning and end of a function
%ğŸ% can help make the flow of execution more visible.
%ğŸ% For example, here is a version of {\tt factorial} with
%ğŸ% print statements:

åœ¨ä¸€ä¸ªå‡½æ•°çš„å¼€å§‹å’Œç»“å°¾å¤„å¢åŠ æ‰“å°è¯­å¥ï¼Œå¯ä»¥ä½¿æ‰§è¡Œæµç¨‹æ›´æ˜æ˜¾ã€‚
ä¾‹å¦‚ï¼Œä¸‹é¢æ˜¯ä¸€ä¸ªå¸¦æ‰“å°è¯­å¥çš„é˜¶ä¹˜å‡½æ•°ï¼š

\begin{lstlisting}
def factorial(n):
    space = ' ' * (4 * n)
    print(space, 'factorial', n)
    if n == 0:
        print(space, 'returning 1')
        return 1
    else:
        recurse = factorial(n-1)
        result = n * recurse
        print(space, 'returning', result)
        return result
\end{lstlisting}

%
%ğŸ% {\tt space} is a string of space characters that controls the
%ğŸ% indentation of the output.  Here is the result of {\tt factorial(4)} :

\li{space} æ˜¯ä¸€ä¸ªç©ºæ ¼å­—ç¬¦çš„å­—ç¬¦ä¸²ï¼Œç”¨æ¥æ§åˆ¶è¾“å‡ºçš„ç¼©è¿›ã€‚ ä¸‹é¢æ˜¯ \li{factorial(4)} çš„è¾“å‡ºç»“æœï¼š


\begin{lstlisting}
                 factorial 4
             factorial 3
         factorial 2
     factorial 1
 factorial 0
 returning 1
     returning 1
         returning 2
             returning 6
                 returning 24
\end{lstlisting}

%
%ğŸ% If you are confused about the flow of execution, this kind of
%ğŸ% output can be helpful.  It takes some time to develop effective
%ğŸ% scaffolding, but a little bit of scaffolding can save a lot of debugging.

å¦‚æœä½ å¯¹æ‰§è¡Œæµç¨‹æ„Ÿåˆ°å›°æƒ‘ï¼Œè¿™ç§è¾“å‡ºå¯èƒ½æœ‰åŠ©äºç†è§£ã€‚
å¼€å‘æœ‰æ•ˆçš„è„šæ‰‹æ¶ä»£ç ä¼šèŠ±äº›æ—¶é—´ï¼Œä½†æ˜¯ä¸€ç‚¹ç‚¹çš„è„šæ‰‹æ¶ä»£ç èƒ½å¤ŸèŠ‚çœå¾ˆå¤šçš„è°ƒè¯•æ—¶é—´ã€‚

%ğŸ% \section{Glossary  |  æœ¯è¯­è¡¨}
\section{æœ¯è¯­è¡¨}

\begin{description}

%ğŸ% \item[temporary variable:]  A variable used to store an intermediate value in
%ğŸ% a complex calculation.
\index{temporary variable}  \index{variable!temporary}
\index{ä¸´æ—¶å˜é‡}  \index{å˜é‡!ä¸´æ—¶}

\item[ä¸´æ—¶å˜é‡ (temporary variable)ï¼š] ä¸€ä¸ªåœ¨å¤æ‚è®¡ç®—ä¸­ç”¨äºå­˜å‚¨è¿‡åº¦å€¼çš„å˜é‡ã€‚

%ğŸ% \item[dead code:]  Part of a program that can never run, often because
%ğŸ% it appears after a {\tt return} statement.
\index{dead code}
\index{æ­»ä»£ç }

\item[æ­»ä»£ç  (dead code)ï¼š] ç¨‹åºä¸­æ°¸è¿œæ— æ³•æ‰§è¡Œçš„é‚£éƒ¨åˆ†ä»£ç ï¼Œé€šå¸¸æ˜¯å› ä¸ºå…¶å‡ºç°åœ¨ä¸€ä¸ªè¿”å›è¯­å¥ä¹‹åã€‚

%ğŸ% \item[incremental development:]  A program development plan intended to
%ğŸ% avoid debugging by adding and testing only
%ğŸ% a small amount of code at a time.
\index{incremental development}
\index{å¢é‡å¼å¼€å‘}

\item[å¢é‡å¼å¼€å‘ (incremental development)ï¼š] ä¸€ç§ç¨‹åºå¼€å‘è®¡åˆ’ï¼Œç›®çš„æ˜¯é€šè¿‡ä¸€æ¬¡å¢åŠ åŠæµ‹è¯•å°‘é‡ä»£ç çš„æ–¹å¼ï¼Œæ¥é¿å…é•¿æ—¶é—´çš„è°ƒè¯•ã€‚

%ğŸ% \item[scaffolding:]  Code that is used during program development but is
%ğŸ% not part of the final version.
\index{scaffolding}
\index{è„šæ‰‹æ¶ä»£ç }

\item[è„šæ‰‹æ¶ä»£ç  (scaffolding)ï¼š] ç¨‹åºå¼€å‘ä¸­ä½¿ç”¨çš„ä»£ç ï¼Œä½†å¹¶ä¸æ˜¯æœ€ç»ˆç‰ˆæœ¬çš„ä¸€éƒ¨åˆ†ã€‚

%ğŸ% \item[guardian:]  A programming pattern that uses a conditional
%ğŸ% statement to check for and handle circumstances that
%ğŸ% might cause an error.
\index{guardian pattern}  \index{pattern!guardian}
\index{ç›‘æŠ¤äººæ¨¡å¼}  \index{æ¨¡å¼!ç›‘æŠ¤äºº}

\item[ç›‘æŠ¤äºº (guardian)ï¼š] ä¸€ç§ç¼–ç¨‹æ¨¡å¼ï¼Œä½¿ç”¨æ¡ä»¶è¯­å¥æ¥æ£€æŸ¥å¹¶å¤„ç†å¯èƒ½å¼•å‘é”™è¯¯çš„æƒ…å½¢ã€‚

\end{description}


%ğŸ% \section{Exercises  |  ç»ƒä¹ }
\section{ç»ƒä¹ }

\begin{exercise}

%ğŸ% Draw a stack diagram for the following program.  What does the program print?

ç”»å‡ºä¸‹é¢ç¨‹åºçš„å †æ ˆå›¾ã€‚
è¿™ä¸ªç¨‹åºçš„æœ€ç»ˆè¾“å‡ºæ˜¯ä»€ä¹ˆï¼Ÿ
\index{stack diagram}  \index{å †æ ˆå›¾}

\begin{em}
\begin{lstlisting}
def b(z):
    prod = a(z, z)
    print(z, prod)
    return prod

def a(x, y):
    x = x + 1
    return x * y

def c(x, y, z):
    total = x + y + z
    square = b(total)**2
    return square

x = 1
y = x + 1
print(c(x, y+3, x+y))
\end{lstlisting}
\end{em}

\end{exercise}


\begin{exercise}
\label{ackermann}

%ğŸ% The Ackermann function, $A(m, n)$, is defined:

{\em Ackermann} å‡½æ•° $A(m, n)$ çš„å®šä¹‰å¦‚ä¸‹ï¼š

\begin{eqnarray*}
A(m, n) = \begin{cases}
              n+1 & \mbox{if } m = 0 \\
        A(m-1, 1) & \mbox{if } m > 0 \mbox{ and } n = 0 \\
A(m-1, A(m, n-1)) & \mbox{if } m > 0 \mbox{ and } n > 0.
\end{cases}
\end{eqnarray*}

%
%ğŸ% See \url{http://en.wikipedia.org/wiki/Ackermann_function}.
%ğŸ% Write a function named {\tt ack} that evaluates the Ackermann function.
%ğŸ% Use your function to evaluate {\tt ack(3, 4)}, which should be 125.
%ğŸ% What happens for larger values of {\tt m} and {\tt n}?
%ğŸ% Solution: \url{http://thinkpython2.com/code/ackermann.py}.

æŸ¥çœ‹ \href{http://en.wikipedia.org/wiki/Ackermann_function}{ç»´åŸºç™¾ç§‘çš„å®šä¹‰}ï¼Œ
ç¼–å†™ä¸€ä¸ªå«ä½œ {\em \li{ack}} çš„å‡½æ•°æ¥è®¡ç®— {\em Ackermann} å‡½æ•°ã€‚
ä½¿ç”¨ä½ çš„å‡½æ•°è®¡ç®— {\em \li{ack(3ï¼Œ4)}}ï¼Œå…¶ç»“æœåº”è¯¥ä¸º $125$ ã€‚
å¦‚æœ {\em \li{m}} å’Œ {\em \li{n}} çš„å€¼è¾ƒå¤§æ—¶ï¼Œä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ
\href{http://thinkpython2.com/code/ackermann.py}{å‚è€ƒç­”æ¡ˆ}

\index{Ackermann function}  \index{function!ack}
\index{é˜¿å…‹æ›¼å‡½æ•°}  \index{å‡½æ•°!é˜¿å…‹æ›¼}
\index{ç»´åŸºç™¾ç§‘}
\end{exercise}


\begin{exercise}
\label{palindrome}

%ğŸ% A palindrome is a word that is spelled the same backward and
%ğŸ% forward, like ``noon'' and ``redivider''.  Recursively, a word
%ğŸ% is a palindrome if the first and last letters are the same
%ğŸ% and the middle is a palindrome.

å›æ–‡è¯ {\em (palindrome)} æŒ‡çš„æ˜¯æ­£ç€æ‹¼åç€æ‹¼éƒ½ä¸€æ ·çš„å•è¯ï¼Œå¦‚ {\em ``noon''} å’Œ {\em ``redivider''}ã€‚
æŒ‰ç…§é€’å½’å®šä¹‰çš„è¯ï¼Œ å¦‚æœæŸä¸ªè¯çš„é¦–å­—æ¯å’Œå°¾å­—æ¯ç›¸åŒï¼Œ è€Œä¸”ä¸­é—´éƒ¨åˆ†ä¹Ÿæ˜¯ä¸€ä¸ªå›æ–‡è¯ï¼Œ é‚£å®ƒå°±æ˜¯ä¸€ä¸ªå›æ–‡è¯ã€‚
\index{palindrome}

%ğŸ% The following are functions that take a string argument and
%ğŸ% return the first, last, and middle letters:

ä¸‹é¢çš„å‡½æ•°æ¥å—ä¸€ä¸ªå­—ç¬¦ä¸²å®å‚ï¼Œå¹¶è¿”å›ç¬¬ä¸€ä¸ªã€æœ€åä¸€ä¸ªå’Œä¸­é—´çš„å­—æ¯ï¼š

\begin{em}
\begin{lstlisting}
def first(word):
    return word[0]

def last(word):
    return word[-1]

def middle(word):
    return word[1:-1]
\end{lstlisting}
\end{em}

%
%ğŸ% We'll see how they work in Chapter~\ref{strings}.

åœ¨ \hyperref[strings]{ç¬¬å…«ç« } ä¸­æˆ‘ä»¬å°†ä»‹ç»å®ƒä»¬æ˜¯å¦‚ä½•å·¥ä½œçš„ã€‚

%ğŸ% \begin{enumerate}
%ğŸ%
%ğŸ% \item Type these functions into a file named {\tt palindrome.py}
%ğŸ% and test them out.  What happens if you call {\tt middle} with
%ğŸ% a string with two letters?  One letter?  What about the empty
%ğŸ% string, which is written \verb"''" and contains no letters?
%ğŸ%
%ğŸ% \item Write a function called \verb"is_palindrome" that takes
%ğŸ% a string argument and returns {\tt True} if it is a palindrome
%ğŸ% and {\tt False} otherwise.  Remember that you can use the
%ğŸ% built-in function {\tt len} to check the length of a string.
%ğŸ%
%ğŸ% \end{enumerate}

\begin{enumerate}

\item å°†å®ƒä»¬å½•å…¥åˆ°æ–‡ä»¶ {\em \li{palindrome.py}} ä¸­å¹¶æµ‹è¯•ã€‚å½“ä½ ç”¨ä¸€ä¸ªä¸¤ä¸ªå­—æ¯çš„å­—ç¬¦ä¸²è°ƒç”¨ {\em \li{middle}} æ—¶ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿä¸€ä¸ªå­—æ¯çš„å‘¢ï¼Ÿç©ºå­—ç¬¦ä¸²å‘¢ï¼Ÿç©ºå­—ç¬¦ä¸²è¿™æ · {\em \li{"''"}} è¡¨ç¤ºï¼Œä¸­é—´ä¸å«ä»»ä½•å­—æ¯ã€‚

\item ç¼–å†™ä¸€ä¸ªå« {\em \li{is_palindrome}} çš„å‡½æ•°ï¼Œ æ¥å—ä¸€ä¸ªå­—ç¬¦ä¸²ä½œä¸ºå®å‚ã€‚ å¦‚æœæ˜¯å›æ–‡è¯ï¼Œ å°±è¿”å› {\em \li{True}} ï¼Œåä¹‹åˆ™è¿”å› {\em \li{False}} ã€‚è®°ä½ï¼Œ ä½ å¯ä»¥ä½¿ç”¨å†…å»ºå‡½æ•° {\em \li{len}} æ¥æ£€æŸ¥å­—ç¬¦ä¸²çš„é•¿åº¦ã€‚

\end{enumerate}

%ğŸ% Solution: \url{http://thinkpython2.com/code/palindrome_soln.py}.

\href{http://thinkpython2.com/code/palindrome_soln.py}{å‚è€ƒç­”æ¡ˆ}

\end{exercise}

\begin{exercise}

%ğŸ% A number, $a$, is a power of $b$ if it is divisible by $b$
%ğŸ% and $a/b$ is a power of $b$.  Write a function called
%ğŸ% \verb"is_power" that takes parameters {\tt a} and {\tt b}
%ğŸ% and returns {\tt True} if {\tt a} is a power of {\tt b}.
%ğŸ% Note: you will have to think about the base case.

å½“æ•°å­— $a$ èƒ½è¢«  $b$ æ•´é™¤ï¼Œå¹¶ä¸” $a/b$ æ˜¯ $b$ çš„å¹‚æ—¶ï¼Œ å®ƒå°±æ˜¯ $b$ çš„å¹‚ã€‚
ç¼–å†™ä¸€ä¸ªå« {\em \li{is_power}} çš„å‡½æ•°ï¼Œæ¥å—ä¸¤ä¸ªå‚æ•° {\em \li{a}} å’Œ {\em \li{b}}ï¼Œ å¹¶ä¸”å½“ {\em \li{a}} æ˜¯ {\em \li{b}} çš„å¹‚æ—¶è¿”å› {\em \li{True}}ã€‚
æ³¨æ„ï¼šä½ å¿…é¡»è¦æƒ³å¥½åŸºç¡€æƒ…å½¢ã€‚

\end{exercise}

\begin{exercise}
\index{greatest common divisor (GCD)}  \index{GCD (greatest common divisor)}

%ğŸ% The greatest common divisor (GCD) of $a$ and $b$ is the largest number
%ğŸ% that divides both of them with no remainder.

$a$ å’Œ $b$ çš„æœ€å¤§å…¬çº¦æ•° {\em (reatest common divisor, GCD)}æ˜¯èƒ½è¢«äºŒè€…æ•´é™¤çš„æœ€å¤§æ•°ã€‚

%ğŸ% One way to find the GCD of two numbers is based on the observation
%ğŸ% that if $r$ is the remainder when $a$ is divided by $b$, then $gcd(a,
%ğŸ% b) = gcd(b, r)$.  As a base case, we can use $gcd(a, 0) = a$.

æ±‚ä¸¤ä¸ªæ•°çš„æœ€å¤§å…¬çº¦æ•°çš„ä¸€ç§æ–¹æ³•ï¼Œæ˜¯åŸºäºè¿™æ ·ä¸€ä¸ªåŸç†ï¼šå¦‚æœ $r$ æ˜¯ $a$ è¢« $b$ é™¤åçš„ä½™æ•°ï¼Œé‚£ä¹ˆ  $gcd(a,b) = gcd(b, r)$ ã€‚æˆ‘ä»¬å¯ä»¥æŠŠ $gcd(a, 0) = a$ å½“åšåŸºç¡€æƒ…å½¢ã€‚

%ğŸ% Write a function called
%ğŸ% \verb"gcd" that takes parameters {\tt a} and {\tt b}
%ğŸ% and returns their greatest common divisor.

ç¼–å†™ä¸€ä¸ªå« {\em \li{gcd}} çš„å‡½æ•°ï¼Œæ¥å—ä¸¤ä¸ªå‚æ•° {\em \li{a}} å’Œ {\em \li{b}}ï¼Œå¹¶è¿”å›äºŒè€…çš„æœ€å¤§å…¬çº¦æ•°ã€‚

%ğŸ% Credit: This exercise is based on an example from Abelson and
%ğŸ% Sussman's {\em Structure and Interpretation of Computer Programs}.

è‡´è°¢ï¼šè¿™é“ä¹ é¢˜åŸºäº {\em Abelson} å’Œ {\em Sussman} ç¼–å†™çš„ ã€ŠStructure and Interpretation of Computer Programsã€‹ ä¸­çš„ä¾‹å­ã€‚

\end{exercise}
