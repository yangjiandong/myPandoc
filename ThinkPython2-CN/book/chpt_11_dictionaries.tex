

%ğŸ% \chapter{Dictionaries  |  å­—å…¸}
\chapter{å­—å…¸}

%ğŸ% This chapter presents another built-in type called a dictionary.
%ğŸ% Dictionaries are one of Python's best features; they are the
%ğŸ% building blocks of many efficient and elegant algorithms.

æœ¬ç« ä»‹ç»å¦ä¸€ä¸ªå†…å»ºæ•°æ®ç±»å‹ï¼š {\em å­—å…¸} (dictionary)ã€‚
å­—å…¸æ˜¯ Python ä¸­æœ€ä¼˜ç§€çš„ç‰¹æ€§ä¹‹ä¸€ï¼› è®¸å¤šé«˜æ•ˆã€ä¼˜é›…çš„ç®—æ³•ä»¥æ­¤ä¸ºåŸºç¡€ã€‚

%ğŸ% \section{A dictionary is a mapping  |  å­—å…¸å³æ˜ å°„}
\section{å­—å…¸å³æ˜ å°„}

\index{dictionary}  \index{dictionary}
\index{type!dict}  \index{key}
\index{key-value pair}  \index{index}

%ğŸ% A {\bf dictionary} is like a list, but more general.  In a list,
%ğŸ% the indices have to be integers; in a dictionary they can
%ğŸ% be (almost) any type.

{\em å­—å…¸} ä¸åˆ—è¡¨ç±»ä¼¼ï¼Œ ä½†æ˜¯æ›´åŠ é€šç”¨ã€‚
åœ¨åˆ—è¡¨ä¸­ï¼Œ ç´¢å¼•å¿…é¡»æ˜¯æ•´æ•°ï¼›ä½†åœ¨å­—å…¸ä¸­ï¼Œ å®ƒä»¬å¯ä»¥æ˜¯(å‡ ä¹)ä»»ä½•ç±»å‹ã€‚

%ğŸ% A dictionary contains a collection of indices, which are called {\bf
%ğŸ%   keys}, and a collection of values.  Each key is associated with a
%ğŸ% single value.  The association of a key and a value is called a {\bf
%ğŸ%   key-value pair} or sometimes an {\bf item}.  \index{item}

å­—å…¸åŒ…å«äº†ä¸€ä¸ªç´¢å¼•çš„é›†åˆï¼Œ è¢«ç§°ä¸º {\em é”®} (keys) ï¼Œ å’Œä¸€ä¸ª {\em å€¼} (values)çš„é›†åˆã€‚   ä¸€ä¸ªé”®å¯¹åº”ä¸€ä¸ªå€¼ã€‚   è¿™ç§ä¸€ä¸€å¯¹åº”çš„å…³è”è¢«ç§°ä¸º {\em é”®å€¼å¯¹} (key-value pair) ï¼Œ  æœ‰æ—¶ä¹Ÿè¢«ç§°ä¸º {\em é¡¹} (item) ã€‚

%ğŸ% In mathematical language, a dictionary represents a {\bf mapping}
%ğŸ% from keys to values, so you can also say that each key
%ğŸ% ``maps to'' a value.
%ğŸ% As an example, we'll build a dictionary that maps from English
%ğŸ% to Spanish words, so the keys and the values are all strings.

åœ¨æ•°å­¦è¯­è¨€ä¸­ï¼Œ å­—å…¸è¡¨ç¤ºçš„æ˜¯ä»é”®åˆ°å€¼çš„ {\em æ˜ å°„}ï¼Œ æ‰€ä»¥ä½ ä¹Ÿå¯ä»¥è¯´æ¯ä¸€ä¸ªé”® ``æ˜ å°„åˆ°'' ä¸€ä¸ªå€¼ã€‚    ä¸¾ä¸ªä¾‹å­ï¼Œ æˆ‘ä»¬æ¥ä¸‹æ¥åˆ›å»ºä¸€ä¸ªå­—å…¸ï¼Œ å°†è‹±è¯­å•è¯æ˜ å°„è‡³è¥¿ç­ç‰™è¯­å•è¯ï¼Œ å› æ­¤é”®å’Œå€¼éƒ½æ˜¯å­—ç¬¦ä¸²ã€‚

%ğŸ% The function {\tt dict} creates a new dictionary with no items.
%ğŸ% Because {\tt dict} is the name of a built-in function, you
%ğŸ% should avoid using it as a variable name.

\li{dict} å‡½æ•°ç”Ÿæˆä¸€ä¸ªä¸å«ä»»ä½•é¡¹çš„æ–°å­—å…¸ã€‚   ç”±äº \li{dict} æ˜¯å†…å»ºå‡½æ•°åï¼Œ ä½ åº”è¯¥é¿å…ä½¿ç”¨å®ƒæ¥å‘½åå˜é‡ã€‚

\index{dict function}  \index{function!dict}

\begin{lstlisting}
>>> eng2sp = dict()
>>> eng2sp
{}
\end{lstlisting}

%ğŸ% The squiggly-brackets, \verb"{}", represent an empty dictionary.
%ğŸ% To add items to the dictionary, you can use square brackets:

èŠ±æ‹¬å· \verb"{}" è¡¨ç¤ºä¸€ä¸ªç©ºå­—å…¸ã€‚  ä½ å¯ä»¥ä½¿ç”¨æ–¹æ‹¬å·å‘å­—å…¸ä¸­å¢åŠ é¡¹ï¼š

\index{squiggly bracket}  \index{bracket!squiggly}

\begin{lstlisting}
>>> eng2sp['one'] = 'uno'
\end{lstlisting}

%
%ğŸ% This line creates an item that maps from the key
%ğŸ% \verb"'one'" to the value \verb"'uno'".  If we print the
%ğŸ% dictionary again, we see a key-value pair with a colon
%ğŸ% between the key and value:

è¿™è¡Œä»£ç åˆ›å»ºä¸€ä¸ªæ–°é¡¹ï¼Œ å°†é”® \li{'one'} æ˜ å°„è‡³å€¼ \li{'uno'}ã€‚
å¦‚æœæˆ‘ä»¬å†æ¬¡æ‰“å°è¯¥å­—å…¸ï¼Œ ä¼šçœ‹åˆ°ä¸€ä¸ªä»¥å†’å·åˆ†éš”çš„é”®å€¼å¯¹ï¼š

\begin{lstlisting}
>>> eng2sp
{'one': 'uno'}
\end{lstlisting}

%
%ğŸ% This output format is also an input format.  For example,
%ğŸ% you can create a new dictionary with three items:

è¾“å‡ºçš„æ ¼å¼åŒæ ·ä¹Ÿæ˜¯è¾“å…¥çš„æ ¼å¼ã€‚   ä¾‹å¦‚ï¼Œ ä½ å¯ä»¥åƒè¿™æ ·åˆ›å»ºä¸€ä¸ªåŒ…å«ä¸‰ä¸ªé¡¹çš„å­—å…¸ï¼š

\begin{lstlisting}
>>> eng2sp = {'one': 'uno', 'two': 'dos', 'three': 'tres'}
\end{lstlisting}

%
%ğŸ% But if you print {\tt eng2sp}, you might be surprised:

ä½†æ˜¯ï¼Œ å¦‚æœä½ æ‰“å° \li{eng2sp} ï¼Œ ç»“æœå¯èƒ½ä¼šè®©ä½ æ„Ÿåˆ°æ„å¤–ï¼š

\begin{lstlisting}
>>> eng2sp
{'one': 'uno', 'three': 'tres', 'two': 'dos'}
\end{lstlisting}

%
%ğŸ% The order of the key-value pairs might not be the same.  If
%ğŸ% you type the same example on your computer, you might get a
%ğŸ% different result.  In general, the order of items in
%ğŸ% a dictionary is unpredictable.

é”®-å€¼å¯¹çš„é¡ºåºå’ŒåŸæ¥ä¸åŒã€‚
åŒæ ·çš„ä¾‹å­åœ¨ä½ çš„ç”µè„‘ä¸Šå¯èƒ½æœ‰ä¸åŒçš„ç»“æœã€‚  é€šå¸¸æ¥è¯´ï¼Œ å­—å…¸ä¸­é¡¹çš„é¡ºåºæ˜¯ä¸å¯é¢„çŸ¥çš„ã€‚

%ğŸ% But that's not a problem because
%ğŸ% the elements of a dictionary are never indexed with integer indices.
%ğŸ% Instead, you use the keys to look up the corresponding values:

ä½†è¿™æ²¡æœ‰å…³ç³»ï¼Œ å› ä¸ºå­—å…¸çš„å…ƒç´ ä¸ä½¿ç”¨æ•´æ•°ç´¢å¼•æ¥ç´¢å¼•ï¼Œ è€Œæ˜¯ç”¨é”®æ¥æŸ¥æ‰¾å¯¹åº”çš„å€¼ï¼š

\begin{lstlisting}
>>> eng2sp['two']
'dos'
\end{lstlisting}

%
%ğŸ% The key \verb"'two'" always maps to the value \verb"'dos'" so the order
%ğŸ% of the items doesn't matter.

é”® \li{'two'} æ€»æ˜¯æ˜ å°„åˆ°å€¼ \li{'dos'} ï¼Œ å› æ­¤é¡¹çš„é¡ºåºæ²¡æœ‰å…³ç³»ã€‚

%ğŸ% If the key isn't in the dictionary, you get an exception:

å¦‚æœé”®ä¸å­˜åœ¨å­—å…¸ä¸­ï¼Œ ä¼šæŠ›å‡ºä¸€ä¸ªå¼‚å¸¸ï¼š

\index{exception!KeyError}  \index{KeyError}

\begin{lstlisting}
>>> eng2sp['four']
KeyError: 'four'
\end{lstlisting}

%
%ğŸ% The {\tt len} function works on dictionaries; it returns the
%ğŸ% number of key-value pairs:

\li{len} å‡½æ•°ä¹Ÿé€‚ç”¨äºå­—å…¸ï¼›å®ƒè¿”å›é”®å€¼å¯¹çš„ä¸ªæ•°ï¼š

\index{len function}  \index{function!len}

\begin{lstlisting}
>>> len(eng2sp)
3
\end{lstlisting}

%
%ğŸ% The {\tt in} operator works on dictionaries, too; it tells you whether
%ğŸ% something appears as a {\em key} in the dictionary (appearing
%ğŸ% as a value is not good enough).

\li{in} æ“ä½œç¬¦ä¹Ÿé€‚ç”¨äºå­—å…¸ï¼›å®ƒå¯ä»¥ç”¨æ¥æ£€éªŒå­—å…¸ä¸­æ˜¯å¦å­˜åœ¨æŸä¸ª {\em é”®} (ä»…ä»…æœ‰è¿™ä¸ªå€¼è¿˜ä¸å¤Ÿ)ã€‚

\index{membership!dictionary}  \index{in operator}
\index{operator!in}

\begin{lstlisting}
>>> 'one' in eng2sp
True
>>> 'uno' in eng2sp
False
\end{lstlisting}

%
%ğŸ% To see whether something appears as a value in a dictionary, you
%ğŸ% can use the method {\tt values}, which returns a collection of
%ğŸ% values, and then use the {\tt in} operator:

æƒ³è¦çŸ¥é“å­—å…¸ä¸­æ˜¯å¦å­˜åœ¨æŸä¸ªå€¼ï¼Œ ä½ å¯ä»¥ä½¿ç”¨ \li{values} æ–¹æ³•ï¼Œ å®ƒè¿”å›å€¼çš„é›†åˆï¼Œ ç„¶åä½ å¯ä»¥ä½¿ç”¨ \li{in} æ“ä½œç¬¦æ¥éªŒè¯ï¼š

\index{values method}  \index{method!values}

\begin{lstlisting}
>>> vals = eng2sp.values()
>>> 'uno' in vals
True
\end{lstlisting}

%
%ğŸ% The {\tt in} operator uses different algorithms for lists and
%ğŸ% dictionaries.  For lists, it searches the elements of the list in
%ğŸ% order, as in Section~\ref{find}.  As the list gets longer, the search
%ğŸ% time gets longer in direct proportion.

\li{in} æ“ä½œç¬¦å¯¹åˆ—è¡¨å’Œå­—å…¸é‡‡ç”¨ä¸åŒçš„ç®—æ³•ã€‚
å¯¹äºåˆ—è¡¨ï¼Œ å®ƒæŒ‰é¡ºåºä¾æ¬¡æŸ¥æ‰¾ç›®æ ‡ï¼Œ å¦‚ \ref{find}~èŠ‚ æ‰€ç¤ºã€‚
éšç€åˆ—è¡¨çš„å¢é•¿ï¼Œ æœç´¢æ—¶é—´æˆæ­£æ¯”å¢é•¿ã€‚

%ğŸ% For dictionaries, Python uses an
%ğŸ% algorithm called a {\bf hashtable} that has a remarkable property: the
%ğŸ% {\tt in} operator takes about the same amount of time no matter how
%ğŸ% many items are in the dictionary.  I explain how that's possible
%ğŸ% in Section~\ref{hashtable}, but the explanation might not make
%ğŸ% sense until you've read a few more chapters.

å¯¹äºå­—å…¸ï¼Œ Python ä½¿ç”¨ä¸€ç§å«åš {\em å“ˆå¸Œè¡¨} (hashtable) çš„ç®—æ³•ï¼Œ
è¿™ç§ç®—æ³•å…·å¤‡ä¸€ç§äº†ä¸èµ·çš„ç‰¹æ€§ï¼š æ— è®ºå­—å…¸ä¸­æœ‰å¤šå°‘é¡¹ï¼Œ  \li{in} è¿ç®—ç¬¦æœç´¢æ‰€éœ€çš„æ—¶é—´éƒ½æ˜¯ä¸€æ ·çš„ã€‚   æˆ‘å°†åœ¨ç¬¬äºŒåä¸€ç« çš„å“ˆå¸Œè¡¨ä¸€èŠ‚ä¸­å…·ä½“è§£é‡ŠèƒŒåçš„åŸç†ï¼Œ
ä½†æ˜¯å¦‚æœä½ ä¸å†å¤šå­¦ä¹ å‡ ç« å†…å®¹ï¼Œ ç°åœ¨å»çœ‹è§£é‡Šçš„è¯å¯èƒ½å¾ˆéš¾ç†è§£ã€‚

%ğŸ% \section{Dictionary as a collection of counters  |  å­—å…¸ä½œä¸ºè®¡æ•°å™¨é›†åˆ}
\section{å­—å…¸ä½œä¸ºè®¡æ•°å™¨é›†åˆ}
\label{histogram}
\index{counter}

%ğŸ% Suppose you are given a string and you want to count how many
%ğŸ% times each letter appears.  There are several ways you could do it:

å‡è®¾ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œ ä½ æƒ³è®¡ç®—æ¯ä¸ªå­—æ¯å‡ºç°çš„æ¬¡æ•°ã€‚
æœ‰å¤šç§æ–¹æ³•å¯ä»¥ä½¿ç”¨ï¼š

%ğŸ% \begin{enumerate}
%ğŸ%
%ğŸ% \item You could create 26 variables, one for each letter of the
%ğŸ% alphabet.  Then you could traverse the string and, for each
%ğŸ% character, increment the corresponding counter, probably using
%ğŸ% a chained conditional.
%ğŸ%
%ğŸ% \item You could create a list with 26 elements.  Then you could
%ğŸ% convert each character to a number (using the built-in function
%ğŸ% {\tt ord}), use the number as an index into the list, and increment
%ğŸ% the appropriate counter.
%ğŸ%
%ğŸ% \item You could create a dictionary with characters as keys
%ğŸ% and counters as the corresponding values.  The first time you
%ğŸ% see a character, you would add an item to the dictionary.  After
%ğŸ% that you would increment the value of an existing item.
%ğŸ%
%ğŸ% \end{enumerate}

\begin{enumerate}

\item ä½ å¯ä»¥ç”Ÿæˆ26ä¸ªå˜é‡ï¼Œ æ¯ä¸ªå¯¹åº”ä¸€ä¸ªå­—æ¯è¡¨ä¸­çš„å­—æ¯ã€‚  ç„¶åä½ å¯ä»¥éå†å­—ç¬¦ä¸²ï¼Œ å¯¹äº æ¯ä¸ªå­—ç¬¦ï¼Œ é€’å¢ç›¸åº”çš„è®¡æ•°å™¨ï¼Œ ä½ å¯èƒ½ä¼šç”¨åˆ°é“¾å¼æ¡ä»¶ã€‚

\item ä½ å¯ä»¥ç”Ÿæˆå…·æœ‰26ä¸ªå…ƒç´ çš„åˆ—è¡¨ã€‚   ç„¶åä½ å¯ä»¥å°†æ¯ä¸ªå­—ç¬¦è½¬åŒ–ä¸ºä¸€ä¸ªæ•°å­—(ä½¿ç”¨å†…å»ºå‡½æ•° \li{ord} )ï¼Œ ä½¿ç”¨è¿™äº›æ•°å­—ä½œä¸ºåˆ—è¡¨çš„ç´¢å¼•ï¼Œ å¹¶é€’å¢é€‚å½“çš„è®¡æ•°å™¨ã€‚

\item ä½ å¯ä»¥ç”Ÿæˆä¸€ä¸ªå­—å…¸ï¼Œ å°†å­—ç¬¦ä½œä¸ºé”®ï¼Œ è®¡æ•°å™¨ä½œä¸ºç›¸åº”çš„å€¼ã€‚  å­—æ¯ç¬¬ä¸€æ¬¡å‡ºç°æ—¶ï¼Œ ä½ åº”è¯¥å‘å­—å…¸ä¸­å¢åŠ ä¸€é¡¹ã€‚   è¿™ä¹‹åï¼Œ ä½ åº”è¯¥é€’å¢ä¸€ä¸ªå·²æœ‰é¡¹çš„å€¼ã€‚

\end{enumerate}

%ğŸ% Each of these options performs the same computation, but each
%ğŸ% of them implements that computation in a different way.

æ¯ä¸ªæ–¹æ³•éƒ½æ˜¯ä¸ºäº†åšåŒä¸€ä»¶äº‹ï¼Œ ä½†æ˜¯å„è‡ªçš„å®ç°æ–¹æ³•ä¸åŒã€‚

\index{implementation}

%ğŸ% An {\bf implementation} is a way of performing a computation;
%ğŸ% some implementations are better than others.  For example,
%ğŸ% an advantage of the dictionary implementation is that we don't
%ğŸ% have to know ahead of time which letters appear in the string
%ğŸ% and we only have to make room for the letters that do appear.

{\em å®ç°} æ˜¯æŒ‡æ‰§è¡ŒæŸç§è®¡ç®—çš„æ–¹æ³•ï¼›æœ‰çš„å®ç°æ›´å¥½ã€‚
ä¾‹å¦‚ï¼Œ ä½¿ç”¨å­—å…¸çš„å®ç°æœ‰ä¸€ä¸ªä¼˜åŠ¿ï¼Œ å³æˆ‘ä»¬ä¸éœ€è¦äº‹å…ˆçŸ¥é“å­—ç¬¦ä¸²ä¸­æœ‰å‡ ç§å­—æ¯ï¼Œ
åªè¦åœ¨å‡ºç°æ–°å­—æ¯æ—¶åˆ†é…ç©ºé—´å°±

%ğŸ% Here is what the code might look like:

ä»£ç å¯èƒ½æ˜¯è¿™æ ·çš„ï¼š

\begin{lstlisting}
def histogram(s):
    d = dict()
    for c in s:
        if c not in d:
            d[c] = 1
        else:
            d[c] += 1
    return d
\end{lstlisting}

%
%ğŸ% The name of the function is {\tt histogram}, which is a statistical
%ğŸ% term for a collection of counters (or frequencies).

å‡½æ•°åå« \li{histogram} (ç›´æ–¹å›¾) ï¼Œ æ˜¯è®¡æ•°å™¨(æˆ–æ˜¯é¢‘ç‡)é›†åˆçš„ç»Ÿè®¡æœ¯è¯­ã€‚

\index{histogram}  \index{frequency}
\index{traversal}

%ğŸ% The first line of the
%ğŸ% function creates an empty dictionary.  The {\tt for} loop traverses
%ğŸ% the string.  Each time through the loop, if the character {\tt c} is
%ğŸ% not in the dictionary, we create a new item with key {\tt c} and the
%ğŸ% initial value 1 (since we have seen this letter once).  If {\tt c} is
%ğŸ% already in the dictionary we increment {\tt d[c]}.

å‡½æ•°çš„ç¬¬ä¸€è¡Œç”Ÿæˆä¸€ä¸ªç©ºå­—å…¸ã€‚   \li{for} å¾ªç¯éå†è¯¥å­—ç¬¦ä¸²ã€‚
æ¯æ¬¡å¾ªç¯ï¼Œ å¦‚æœå­—ç¬¦ \li{c} ä¸åœ¨å­—å…¸ä¸­ï¼Œ  æˆ‘ä»¬ç”¨é”® \li{c} å’Œåˆå§‹å€¼ \li{1} ç”Ÿæˆä¸€ä¸ªæ–°é¡¹ (å› ä¸ºè¯¥å­—æ¯å‡ºç°äº†ä¸€æ¬¡)ã€‚   å¦‚æœ \li{c} å·²ç»åœ¨å­—å…¸ä¸­äº†ï¼Œ é‚£ä¹ˆæˆ‘ä»¬é€’å¢ \li{d[c]} ã€‚

\index{histogram}

%ğŸ% Here's how it works:

ä¸‹é¢æ˜¯è¿è¡Œç»“æœï¼š

\begin{lstlisting}
>>> h = histogram('brontosaurus')
>>> h
{'a': 1, 'b': 1, 'o': 2, 'n': 1, 's': 2, 'r': 2, 'u': 2, 't': 1}
\end{lstlisting}

%
%ğŸ% The histogram indicates that the letters \verb"'a'" and \verb"'b'"
%ğŸ% appear once; \verb"'o'" appears twice, and so on.

\li{histogram} å‡½æ•°è¡¨æ˜å­—æ¯ \li{'a'} å’Œ \li{'b'} å‡ºç°äº†ä¸€æ¬¡ï¼Œ   \li{'o'} å‡ºç°äº†ä¸¤æ¬¡ï¼Œ ç­‰ç­‰ã€‚

\index{get method}  \index{method!get}

%ğŸ% Dictionaries have a method called {\tt get} that takes a key
%ğŸ% and a default value.  If the key appears in the dictionary,
%ğŸ% {\tt get} returns the corresponding value; otherwise it returns
%ğŸ% the default value.  For example:

å­—å…¸ç±»æœ‰ä¸€ä¸ª \li{get} æ–¹æ³•ï¼Œ æ¥å—ä¸€ä¸ªé”®å’Œä¸€ä¸ªé»˜è®¤å€¼ä½œä¸ºå‚æ•°ã€‚
å¦‚æœå­—å…¸ä¸­å­˜åœ¨è¯¥é”®ï¼Œ åˆ™è¿”å›å¯¹åº”å€¼ï¼›å¦åˆ™è¿”å›ä¼ å…¥çš„é»˜è®¤å€¼ã€‚   ä¾‹å¦‚ï¼š

\begin{lstlisting}
>>> h = histogram('a')
>>> h
{'a': 1}
>>> h.get('a', 0)
1
>>> h.get('b', 0)
0
\end{lstlisting}

%
%ğŸ% As an exercise, use {\tt get} to write {\tt histogram} more concisely.  You
%ğŸ% should be able to eliminate the {\tt if} statement.

æˆ‘ä»¬åšä¸ªç»ƒä¹ ï¼Œ è¯•ç€ç”¨ \li{get} ç®€åŒ– \li{histogram} å‡½æ•°ã€‚  ä½ åº”è¯¥èƒ½å¤Ÿä¸å†ä½¿ç”¨ \li{if} è¯­å¥ã€‚


%ğŸ% \section{Looping and dictionaries  |  å¾ªç¯å’Œå­—å…¸}
\section{å¾ªç¯å’Œå­—å…¸}

\index{dictionary!looping with}  \index{looping!with dictionaries}
\index{traversal}

%ğŸ% If you use a dictionary in a {\tt for} statement, it traverses
%ğŸ% the keys of the dictionary.  For example, \verb"print_hist"
%ğŸ% prints each key and the corresponding value:

åœ¨ \li{for} å¾ªç¯ä¸­ä½¿ç”¨å­—å…¸ä¼šéå†å…¶æ‰€æœ‰çš„é”®ã€‚
ä¾‹å¦‚ï¼Œ ä¸‹é¢çš„ \li{print_hist} ä¼šæ‰“å°æ‰€æœ‰é”®ä¸å¯¹åº”çš„å€¼ï¼š

\begin{lstlisting}
def print_hist(h):
    for c in h:
        print(c, h[c])
\end{lstlisting}

%
%ğŸ% Here's what the output looks like:

è¾“å‡ºç±»ä¼¼ï¼š

\begin{lstlisting}
>>> h = histogram('parrot')
>>> print_hist(h)
a 1
p 1
r 2
t 1
o 1
\end{lstlisting}

%
%ğŸ% Again, the keys are in no particular order.  To traverse the keys
%ğŸ% in sorted order, you can use the built-in function {\tt sorted}:

é‡ç”³ä¸€éï¼Œ å­—å…¸ä¸­çš„é”®æ˜¯æ— åºçš„ã€‚
å¦‚æœè¦ä»¥ç¡®å®šçš„é¡ºåºéå†å­—å…¸ï¼Œ ä½ å¯ä»¥ä½¿ç”¨å†…å»ºæ–¹æ³• \li{sorted}ï¼š

\index{keys method}  \index{method!keys}

\begin{lstlisting}
>>> for key in sorted(h):
...     print(key, h[key])
a 1
o 1
p 1
r 2
t 1
\end{lstlisting}

%TODO: get this on Atlas


%ğŸ% \section{Reverse lookup  |  é€†å‘æŸ¥æ‰¾}
\section{é€†å‘æŸ¥æ‰¾}
\label{raise}

\index{dictionary!lookup}  \index{dictionary!reverse lookup}
\index{lookup, dictionary}  \index{reverse lookup, dictionary}

%ğŸ% Given a dictionary {\tt d} and a key {\tt k}, it is easy to
%ğŸ% find the corresponding value {\tt v = d[k]}.  This operation
%ğŸ% is called a {\bf lookup}.

ç»™å®šä¸€ä¸ªå­—å…¸ \li{d} ä»¥åŠä¸€ä¸ªé”® \li{t} ï¼Œ å¾ˆå®¹æ˜“æ‰¾åˆ°ç›¸åº”çš„å€¼ \li{v = d[k]} ã€‚
è¯¥è¿ç®—è¢«ç§°ä½œ {\em æŸ¥æ‰¾} (lookup) ã€‚

%ğŸ% But what if you have {\tt v} and you want to find {\tt k}?
%ğŸ% You have two problems: first, there might be more than one
%ğŸ% key that maps to the value {\tt v}.  Depending on the application,
%ğŸ% you might be able to pick one, or you might have to make
%ğŸ% a list that contains all of them.  Second, there is no
%ğŸ% simple syntax to do a {\bf reverse lookup}; you have to search.

ä½†æ˜¯å¦‚æœä½ æƒ³é€šè¿‡ \li{v} æ‰¾åˆ° \li{k} å‘¢ï¼Ÿ
æœ‰ä¸¤ä¸ªé—®é¢˜ï¼šç¬¬ä¸€ï¼Œ å¯èƒ½æœ‰ä¸æ­¢ä¸€ä¸ªçš„é”®å…¶æ˜ å°„åˆ°å€¼vã€‚
ä½ å¯èƒ½å¯ä»¥æ‰¾åˆ°å”¯ä¸€ä¸€ä¸ªï¼Œ ä¸ç„¶å°±å¾—ç”¨ \li{list} æŠŠæ‰€æœ‰çš„é”®åŒ…èµ·æ¥ã€‚
ç¬¬äºŒï¼Œ æ²¡æœ‰ç®€å•çš„è¯­æ³•å¯ä»¥å®Œæˆ {\em é€†å‘æŸ¥æ‰¾} (reverse lookup) ï¼› ä½ å¿…é¡»æœç´¢ã€‚

%ğŸ% Here is a function that takes a value and returns the first
%ğŸ% key that maps to that value:

ä¸‹é¢è¿™ä¸ªå‡½æ•°æ¥å—ä¸€ä¸ªå€¼å¹¶è¿”å›æ˜ å°„åˆ°è¯¥å€¼çš„ç¬¬ä¸€ä¸ªé”®ï¼š

\begin{lstlisting}
def reverse_lookup(d, v):
    for k in d:
        if d[k] == v:
            return k
    raise LookupError()
\end{lstlisting}

%
%ğŸ% This function is yet another example of the search pattern, but it
%ğŸ% uses a feature we haven't seen before, {\tt raise}.  The
%ğŸ% {\bf raise statement} causes an exception; in this case it causes a
%ğŸ% {\tt LookupError}, which is a built-in exception used to indicate
%ğŸ% that a lookup operation failed.

è¯¥å‡½æ•°æ˜¯æœç´¢æ¨¡å¼çš„å¦ä¸€ä¸ªä¾‹å­ï¼Œ ä½†æ˜¯å®ƒä½¿ç”¨äº†ä¸€ä¸ªæˆ‘ä»¬ä¹‹å‰æ²¡æœ‰è§è¿‡çš„ç‰¹æ€§ï¼Œ \li{raise}ã€‚   \li{raise} è¯­å¥ èƒ½è§¦å‘å¼‚å¸¸ï¼Œ è¿™é‡Œå®ƒè§¦å‘äº† \li{ValueError}ï¼Œ è¿™æ˜¯ä¸€ä¸ªè¡¨ç¤ºæŸ¥æ‰¾æ“ä½œå¤±è´¥çš„å†…å»ºå¼‚å¸¸ã€‚

\index{search}  \index{pattern!search}
\index{raise statement} \index{statement!raise}
\index{exception!LookupError} \index{LookupError}

%ğŸ% If we get to the end of the loop, that means {\tt v}
%ğŸ% doesn't appear in the dictionary as a value, so we raise an
%ğŸ% exception.

å¦‚æœæˆ‘ä»¬åˆ°è¾¾å¾ªç¯ç»“å°¾ï¼Œ è¿™æ„å‘³ç€å­—å…¸ä¸­ä¸å­˜åœ¨ \li{v} è¿™ä¸ªå€¼ï¼Œ æ‰€ä»¥æˆ‘ä»¬è§¦å‘ä¸€ä¸ªå¼‚å¸¸ã€‚

%ğŸ% Here is an example of a successful reverse lookup:

ä¸‹é¢æ˜¯ä¸€ä¸ªæˆåŠŸé€†å‘æŸ¥æ‰¾çš„ä¾‹å­ï¼š

\begin{lstlisting}
>>> h = histogram('parrot')
>>> key = reverse_lookup(h, 2)
>>> key
'r'
\end{lstlisting}

%
%ğŸ% And an unsuccessful one:

ä»¥åŠä¸€ä¸ªå¤±è´¥çš„ä¾‹å­ï¼š

\begin{lstlisting}
>>> key = reverse_lookup(h, 3)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 5, in reverse_lookup
LookupError
\end{lstlisting}

%
%ğŸ% The effect when you raise an exception is the same as when
%ğŸ% Python raises one: it prints a traceback and an error message.

ä½ è§¦å‘çš„å¼‚å¸¸å’Œ Python è§¦å‘çš„äº§ç”Ÿæ•ˆæœä¸€æ ·ï¼šéƒ½æ‰“å°ä¸€æ¡å›æº¯å’Œé”™è¯¯ä¿¡æ¯ã€‚

\index{traceback}  \index{optional argument}
\index{argument!optional}

%ğŸ% The {\tt raise} statement can take a detailed error message as an
%ğŸ% optional argument.  For example:

\li{raise} è¯­å¥æ¥å—ä¸€ä¸ªè¯¦ç»†çš„é”™è¯¯ä¿¡æ¯ä½œä¸ºå¯é€‰çš„å®å‚ã€‚    ä¾‹å¦‚ï¼š

\begin{lstlisting}
>>> raise LookupError('value does not appear in the dictionary')
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
LookupError: value does not appear in the dictionary
\end{lstlisting}

%
%ğŸ% A reverse lookup is much slower than a forward lookup; if you
%ğŸ% have to do it often, or if the dictionary gets big, the performance
%ğŸ% of your program will suffer.

é€†å‘æŸ¥æ‰¾æ¯”æ­£å‘æŸ¥æ‰¾æ…¢å¾—å¤šï¼› å¦‚æœä½ é¢‘ç¹æ‰§è¡Œè¿™ä¸ªæ“ä½œæˆ–æ˜¯å­—å…¸å¾ˆå¤§ï¼Œ ç¨‹åºæ€§èƒ½ä¼šå˜å·®ã€‚

%ğŸ% \section{Dictionaries and lists  |  å­—å…¸å’Œåˆ—è¡¨}
\section{å­—å…¸å’Œåˆ—è¡¨}
\label{invert}

%ğŸ% Lists can appear as values in a dictionary.  For example, if you
%ğŸ% are given a dictionary that maps from letters to frequencies, you
%ğŸ% might want to invert it; that is, create a dictionary that maps
%ğŸ% from frequencies to letters.  Since there might be several letters
%ğŸ% with the same frequency, each value in the inverted dictionary
%ğŸ% should be a list of letters.

åœ¨å­—å…¸ä¸­ï¼Œ åˆ—è¡¨å¯ä»¥ä½œä¸ºå€¼å‡ºç°ã€‚
ä¾‹å¦‚ï¼Œ å¦‚æœä½ æœ‰ä¸€ä¸ªä»å­—æ¯æ˜ å°„åˆ°é¢‘ç‡çš„å­—å…¸ï¼Œ  è€Œä½ æƒ³å€’è½¬å®ƒï¼›
ä¹Ÿå°±æ˜¯ç”Ÿæˆä¸€ä¸ªä»é¢‘ç‡æ˜ å°„åˆ°å­—æ¯çš„å­—å…¸ã€‚
å› ä¸ºå¯èƒ½æœ‰äº›å­—æ¯å…·æœ‰ç›¸åŒçš„é¢‘ç‡ï¼Œ æ‰€ä»¥åœ¨å€’è½¬å­—å…¸ä¸­çš„æ¯ä¸ªå€¼åº”è¯¥æ˜¯ä¸€ä¸ªå­—æ¯ç»„æˆçš„åˆ—è¡¨ã€‚

\index{invert dictionary}  \index{dictionary!invert}

%ğŸ% Here is a function that inverts a dictionary:

ä¸‹é¢æ˜¯ä¸€ä¸ªå€’è½¬å­—å…¸çš„å‡½æ•°ï¼š

\begin{lstlisting}
def invert_dict(d):
    inverse = dict()
    for key in d:
        val = d[key]
        if val not in inverse:
            inverse[val] = [key]
        else:
            inverse[val].append(key)
    return inverse
\end{lstlisting}

%
%ğŸ% Each time through the loop, {\tt key} gets a key from {\tt d} and
%ğŸ% {\tt val} gets the corresponding value.  If {\tt val} is not in {\tt
%ğŸ%   inverse}, that means we haven't seen it before, so we create a new
%ğŸ% item and initialize it with a {\bf singleton} (a list that contains a
%ğŸ% single element).  Otherwise we have seen this value before, so we
%ğŸ% append the corresponding key to the list.  \index{singleton}

æ¯æ¬¡å¾ªç¯ï¼Œ  \li{key} ä» \li{d} è·å¾—ä¸€ä¸ªé”®å’Œç›¸åº”çš„å€¼ \li{val} ã€‚
å¦‚æœ \li{val} ä¸åœ¨ \li{inverse} ä¸­ï¼Œ æ„å‘³ç€æˆ‘ä»¬ä¹‹å‰æ²¡æœ‰è§è¿‡å®ƒï¼Œ
å› æ­¤æˆ‘ä»¬ç”Ÿæˆä¸€ä¸ªæ–°é¡¹å¹¶ç”¨ä¸€ä¸ª {\em å•å…ƒç´ é›†åˆ} (singleton) (åªåŒ…å«ä¸€ä¸ªå…ƒç´ çš„åˆ—è¡¨)åˆå§‹åŒ–å®ƒã€‚   å¦åˆ™å°±æ„å‘³ç€ä¹‹å‰å·²ç»è§è¿‡è¯¥å€¼ï¼Œ å› æ­¤å°†å…¶å¯¹åº”çš„é”®æ·»åŠ è‡³åˆ—è¡¨ã€‚

%ğŸ% Here is an example:

ä¸¾ä¸ªä¾‹å­ï¼š

\begin{lstlisting}
>>> hist = histogram('parrot')
>>> hist
{'a': 1, 'p': 1, 'r': 2, 't': 1, 'o': 1}
>>> inverse = invert_dict(hist)
>>> inverse
{1: ['a', 'p', 't', 'o'], 2: ['r']}
\end{lstlisting}

\begin{figure}
\centerline
{\includegraphics[scale=0.8]{../source/figs/dict1.pdf}}
\caption{State diagram.}
\label{fig.dict1}
\end{figure}

%ğŸ% Figure~\ref{fig.dict1} is a state diagram showing {\tt hist} and {\tt inverse}.
%ğŸ% A dictionary is represented as a box with the type {\tt dict} above it
%ğŸ% and the key-value pairs inside.  If the values are integers, floats or
%ğŸ% strings, I draw them inside the box, but I usually draw lists
%ğŸ% outside the box, just to keep the diagram simple.

å›¾~\ref{fig.dict1} æ˜¯å…³äº \li{hist} ä¸ \li{inverse} çš„çŠ¶æ€å›¾ã€‚  å­—å…¸ç”¨æ ‡æœ‰ç±»å‹ \li{dict} çš„æ–¹æ¡†è¡¨ç¤ºï¼Œ æ–¹æ¡†ä¸­æ˜¯é”®å€¼å¯¹ã€‚  å¦‚æœå€¼æ˜¯æ•´æ•°ã€æµ®ç‚¹æ•°æˆ–å­—ç¬¦ä¸²ï¼Œ
æˆ‘å°±æŠŠå®ƒä»¬ç”»åœ¨æ–¹æ¡†å†…éƒ¨ï¼Œ ä½†æˆ‘é€šå¸¸æŠŠåˆ—è¡¨ç”»åœ¨æ–¹æ¡†å¤–é¢ï¼Œ ç›®çš„åªæ˜¯ä¸ºäº†ä¸è®©å›¾è¡¨å˜å¤æ‚ã€‚

\index{state diagram}  \index{diagram!state}

%ğŸ% Lists can be values in a dictionary, as this example shows, but they
%ğŸ% cannot be keys.  Here's what happens if you try:

å¦‚æœ¬ä¾‹æ‰€ç¤ºï¼Œ åˆ—è¡¨å¯ä»¥ä½œä¸ºå­—å…¸ä¸­çš„å€¼ï¼Œ ä½†æ˜¯ä¸èƒ½æ˜¯é”®ã€‚
ä¸‹é¢æ¼”ç¤ºäº†è¿™æ ·åšçš„ç»“æœï¼š

\index{TypeError}  \index{exception!TypeError}

\begin{lstlisting}
>>> t = [1, 2, 3]
>>> d = dict()
>>> d[t] = 'oops'
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
TypeError: list objects are unhashable
\end{lstlisting}

%
%ğŸ% I mentioned earlier that a dictionary is implemented using
%ğŸ% a hashtable and that means that the keys have to be {\bf hashable}.

æˆ‘ä¹‹å‰æè¿‡ï¼Œ å­—å…¸ä½¿ç”¨å“ˆå¸Œè¡¨å®ç°ï¼Œ è¿™æ„å‘³ç€é”®å¿…é¡»æ˜¯ {\bf å¯å“ˆå¸Œçš„} (hashable) ã€‚

\index{hash function}  \index{hashable}

%ğŸ% A {\bf hash} is a function that takes a value (of any kind)
%ğŸ% and returns an integer.  Dictionaries use these integers,
%ğŸ% called hash values, to store and look up key-value pairs.


{\em å“ˆå¸Œ} (hash) å‡½æ•°æ¥å—ä¸€ä¸ªå€¼ (ä»»ä½•ç±»å‹) å¹¶è¿”å›ä¸€ä¸ªæ•´æ•°ã€‚
å­—å…¸ä½¿ç”¨è¢«ç§°ä½œå“ˆå¸Œå€¼çš„è¿™äº›æ•´æ•°ï¼Œ æ¥å­˜å‚¨å’ŒæŸ¥æ‰¾é”®å€¼å¯¹ã€‚
\index{immutability}

%ğŸ% This system works fine if the keys are immutable.  But if the
%ğŸ% keys are mutable, like lists, bad things happen.  For example,
%ğŸ% when you create a key-value pair, Python hashes the key and
%ğŸ% stores it in the corresponding location.  If you modify the
%ğŸ% key and then hash it again, it would go to a different location.
%ğŸ% In that case you might have two entries for the same key,
%ğŸ% or you might not be able to find a key.  Either way, the
%ğŸ% dictionary wouldn't work correctly.

å¦‚æœé”®æ˜¯ä¸å¯å˜çš„ï¼Œ é‚£ä¹ˆè¿™ç§å®ç°å¯ä»¥å¾ˆå¥½åœ°å·¥ä½œã€‚
ä½†æ˜¯å¦‚æœé”®æ˜¯å¯å˜çš„ï¼Œ å¦‚åˆ—è¡¨ï¼Œ é‚£ä¹ˆå°±ä¼šå‘ç”Ÿç³Ÿç³•çš„äº‹æƒ…ã€‚
ä¾‹å¦‚ï¼Œ å½“ä½ ç”Ÿæˆä¸€ä¸ªé”®å€¼å¯¹æ—¶ï¼Œ Pythonå“ˆå¸Œè¯¥é”®å¹¶å°†å…¶å­˜å‚¨åœ¨ç›¸åº”çš„ä½ç½®ã€‚
å¦‚æœä½ æ”¹å˜é”®ç„¶åå†æ¬¡å“ˆå¸Œå®ƒï¼Œ å®ƒå°†è¢«å­˜å‚¨åˆ°å¦ä¸€ä¸ªä½ç½®ã€‚
åœ¨é‚£ç§æƒ…å†µä¸‹ï¼Œ å¯¹äºç›¸åŒçš„é”®ï¼Œ ä½ å¯èƒ½æœ‰ä¸¤ä¸ªå€¼ï¼Œ  æˆ–è€…ä½ å¯èƒ½æ— æ³•æ‰¾åˆ°ä¸€ä¸ªé”®ã€‚
æ— è®ºå¦‚ä½•ï¼Œ å­—å…¸éƒ½ä¸ä¼šæ­£ç¡®çš„å·¥ä½œã€‚

%ğŸ% That's why keys have to be hashable, and why mutable types like
%ğŸ% lists aren't.  The simplest way to get around this limitation is to
%ğŸ% use tuples, which we will see in the next chapter.

è¿™å°±æ˜¯ä¸ºä»€ä¹ˆé”®å¿…é¡»æ˜¯å¯å“ˆå¸Œçš„ï¼Œ ä»¥åŠä¸ºä»€ä¹ˆå¦‚åˆ—è¡¨è¿™ç§å¯å˜ç±»å‹ä¸èƒ½ä½œä¸ºé”®ã€‚
ç»•è¿‡è¿™ç§é™åˆ¶æœ€ç®€å•çš„æ–¹æ³•æ˜¯ä½¿ç”¨å…ƒç»„ï¼Œ  æˆ‘ä»¬å°†åœ¨ä¸‹ä¸€ç« ä¸­ä»‹ç»ã€‚

%ğŸ% Since dictionaries are mutable, they can't be used as keys,
%ğŸ% but they {\em can} be used as values.

å› ä¸ºå­—å…¸æ˜¯å¯å˜çš„ï¼Œ å› æ­¤å®ƒä»¬ä¸èƒ½ä½œä¸ºé”®ï¼Œ ä½†æ˜¯ {\em å¯ä»¥} ç”¨ä½œå€¼ã€‚


%ğŸ% \section{Memos  |  å¤‡å¿˜}
\section{å¤‡å¿˜}
\label{memoize}

%ğŸ% If you played with the {\tt fibonacci} function from
%ğŸ% Section~\ref{one.more.example}, you might have noticed that the bigger
%ğŸ% the argument you provide, the longer the function takes to run.
%ğŸ% Furthermore, the run time increases quickly.

å¦‚æœä½ åœ¨ \ref{one.more.example}èŠ‚ä¸­æ¥è§¦è¿‡ \li{fibonacci} å‡½æ•°ï¼Œ  ä½ å¯èƒ½æ³¨æ„åˆ°è¾“å…¥çš„å®å‚è¶Šå¤§ï¼Œ å‡½æ•°è¿è¡Œå°±éœ€è¦è¶Šå¤šæ—¶é—´ã€‚
è€Œä¸”è¿è¡Œæ—¶é—´å¢é•¿å¾—éå¸¸å¿«ã€‚

\index{fibonacci function}  \index{function!fibonacci}

%ğŸ% To understand why, consider Figure~\ref{fig.fibonacci}, which shows
%ğŸ% the {\bf call graph} for {\tt fibonacci} with {\tt n=4}:

è¦ç†è§£å…¶åŸå› ï¼Œ æ€è€ƒÂ å›¾~\ref{fig.fibonacci} ï¼Œ å®ƒå±•ç¤ºäº†å½“ \li{n=4} æ—¶ \li{fibonacci} çš„ {\em è°ƒç”¨å›¾} (call graph) ï¼š

\begin{figure}
\centerline
{\includegraphics[scale=0.7]{../source/figs/fibonacci.pdf}}
\caption{Call graph.}
\label{fig.fibonacci}
\end{figure}

%ğŸ% A call graph shows a set of function frames, with lines connecting each
%ğŸ% frame to the frames of the functions it calls.  At the top of the
%ğŸ% graph, {\tt fibonacci} with {\tt n=4} calls {\tt fibonacci} with {\tt
%ğŸ% n=3} and {\tt n=2}.  In turn, {\tt fibonacci} with {\tt n=3} calls
%ğŸ% {\tt fibonacci} with {\tt n=2} and {\tt n=1}.  And so on.

è°ƒç”¨å›¾ä¸­åˆ—å‡ºäº†ä¸€ç³»åˆ—å‡½æ•°æ ˆå¸§ï¼Œ æ¯ä¸ªæ ˆå¸§ä¹‹é—´é€šè¿‡çº¿æ¡ä¸è°ƒç”¨å®ƒçš„å‡½æ•°æ ˆå¸§ç›¸è¿ã€‚
åœ¨å›¾çš„é¡¶ç«¯ï¼Œ \li{n = 4} çš„ \li{fibonacci} è°ƒç”¨ \li{n = 3} å’Œ \li{n = 2} çš„ \li{fibonacci} ã€‚   æ¥ç€ï¼Œ  \li{n = 3} çš„ \li{fibonacci} è°ƒç”¨ \li{n = 2} å’Œ \li{n = 1} çš„ \li{fibonacci}ã€‚   ä»¥æ­¤ç±»æ¨ã€‚

\index{function frame}  \index{frame}
\index{call graph}

%ğŸ% Count how many times {\tt fibonacci(0)} and {\tt fibonacci(1)} are
%ğŸ% called.  This is an inefficient solution to the problem, and it gets
%ğŸ% worse as the argument gets bigger.

æ•°æ•° \li{fibonacci(0)} å’Œ \li{fibonacci(1)} æ€»å…±è¢«è°ƒç”¨äº†å‡ æ¬¡ã€‚
å¯¹è¯¥é—®é¢˜ï¼Œ è¿™ä¸æ˜¯ä¸€ä¸ªé«˜æ•ˆçš„è§£ï¼Œ å¹¶ä¸”éšç€å®å‚çš„å˜å¤§ä¼šå˜å¾—æ›´ç³Ÿã€‚

\index{memo}

%ğŸ% One solution is to keep track of values that have already been
%ğŸ% computed by storing them in a dictionary.  A previously computed value
%ğŸ% that is stored for later use is called a {\bf memo}.  Here is a
%ğŸ% ``memoized'' version of {\tt fibonacci}:

ä¸€ä¸ªè§£å†³åŠæ³•æ˜¯ä¿å­˜å·²ç»è®¡ç®—è¿‡çš„å€¼ï¼Œ å°†å®ƒä»¬å­˜åœ¨ä¸€ä¸ªå­—å…¸ä¸­ã€‚
å­˜å‚¨ä¹‹å‰è®¡ç®—è¿‡çš„å€¼ä»¥ä¾¿ä»Šåä½¿ç”¨ï¼Œ å®ƒè¢«ç§°ä½œ {\em å¤‡å¿˜å½•} (memo) ã€‚
ä¸‹é¢æ˜¯ä½¿ç”¨å¤‡å¿˜å½• (memoized) çš„ \li{fibonacci} çš„å®ç°ï¼š

\begin{lstlisting}
known = {0:0, 1:1}

def fibonacci(n):
    if n in known:
        return known[n]

    res = fibonacci(n-1) + fibonacci(n-2)
    known[n] = res
    return res
\end{lstlisting}

%
%ğŸ% {\tt known} is a dictionary that keeps track of the Fibonacci
%ğŸ% numbers we already know.  It starts with
%ğŸ% two items: 0 maps to 0 and 1 maps to 1.

\li{known} æ˜¯ä¸€ä¸ªå­—å…¸ï¼Œ è®°å½•äº†æˆ‘ä»¬å·²ç»è®¡ç®—è¿‡çš„æ–æ³¢çº³å¥‘æ•°å­—ã€‚
å®ƒä¸€å¼€å§‹åŒ…å«ä¸¤ä¸ªé¡¹ï¼š0æ˜ å°„åˆ°0ï¼Œ 1æ˜ å°„åˆ°1ã€‚

%ğŸ% Whenever {\tt fibonacci} is called, it checks {\tt known}.
%ğŸ% If the result is already there, it can return
%ğŸ% immediately.  Otherwise it has to
%ğŸ% compute the new value, add it to the dictionary, and return it.

å½“ \li{fibonacci} è¢«è°ƒç”¨æ—¶ï¼Œ å®ƒå…ˆæ£€æŸ¥ \li{known} ã€‚   å¦‚æœç»“æœå­˜åœ¨ï¼Œ åˆ™ç«‹å³è¿”å›ã€‚   å¦åˆ™ï¼Œ å®ƒå¿…é¡»è®¡ç®—æ–°çš„å€¼ï¼Œ å°†å…¶åŠ å…¥å­—å…¸ï¼Œ å¹¶è¿”å›å®ƒã€‚

%ğŸ% If you run this version of {\tt fibonacci} and compare it with
%ğŸ% the original, you will find that it is much faster.

å°†ä¸¤ä¸ªç‰ˆæœ¬çš„ \li{fibonacci} å‡½æ•°æ¯”æ¯”çœ‹ï¼Œ ä½ å°±çŸ¥é“åè€…å¿«äº†å¾ˆå¤šã€‚


%ğŸ% \section{Global variables  |  å…¨å±€å˜é‡}
\section{å…¨å±€å˜é‡}

\index{global variable}  \index{variable!global}

%ğŸ% In the previous example, {\tt known} is created outside the function,
%ğŸ% so it belongs to the special frame called \verb"__main__".
%ğŸ% Variables in \verb"__main__" are sometimes called {\bf global}
%ğŸ% because they can be accessed from any function.  Unlike local
%ğŸ% variables, which disappear when their function ends, global variables
%ğŸ% persist from one function call to the next.

åœ¨å‰é¢çš„ä¾‹å­ä¸­ï¼Œ \li{known} æ˜¯åœ¨å‡½æ•°çš„å¤–éƒ¨åˆ›å»ºçš„ï¼Œ
å› æ­¤å®ƒå±äºè¢«ç§°ä½œ \li{__main__} çš„ç‰¹æ®Šå¸§ã€‚
å› ä¸º \li{__main__} ä¸­çš„å˜é‡å¯ä»¥è¢«ä»»ä½•å‡½æ•°è®¿é—®ï¼Œ å®ƒä»¬ä¹Ÿè¢«ç§°ä½œ {\em å…¨å±€å˜é‡} (global) ã€‚   ä¸å‡½æ•°ç»“æŸæ—¶å°±ä¼šæ¶ˆå¤±çš„å±€éƒ¨å˜é‡ä¸åŒï¼Œ ä¸åŒå‡½æ•°è°ƒç”¨æ—¶å…¨å±€å˜é‡ä¸€ç›´éƒ½å­˜åœ¨ã€‚

\index{flag}

%ğŸ% It is common to use global variables for {\bf flags}; that is,
%ğŸ% boolean variables that indicate (``flag'') whether a condition
%ğŸ% is true.  For example, some programs use
%ğŸ% a flag named {\tt verbose} to control the level of detail in the
%ğŸ% output:

å…¨å±€å˜é‡æ™®éç”¨ä½œ {\em æ ‡è®°} (flag)ï¼› å°±æ˜¯è¯´æ˜(æ ‡è®°)ä¸€ä¸ªæ¡ä»¶æ˜¯å¦ä¸ºçœŸçš„å¸ƒå°”å˜é‡ã€‚
ä¾‹å¦‚ï¼Œ ä¸€äº›ç¨‹åºä½¿ç”¨ä¸€ä¸ªè¢«ç§°ä½œ \li{verbose} çš„æ ‡è®°æ¥æ§åˆ¶è¾“å‡ºçš„ä¸°å¯Œç¨‹åº¦ï¼š

\begin{lstlisting}
verbose = True

def example1():
    if verbose:
        print('Running example1')
\end{lstlisting}

%
%ğŸ% If you try to reassign a global variable, you might be surprised.
%ğŸ% The following example is supposed to keep track of whether the
%ğŸ% function has been called:

å¦‚æœä½ è¯•å›¾å¯¹ä¸€ä¸ªå…¨å±€å˜é‡é‡æ–°èµ‹å€¼ï¼Œ ç»“æœå¯èƒ½å‡ºä¹æ„æ–™ã€‚
ä¸‹é¢çš„ä¾‹å­æœ¬åº”è¯¥è®°å½•å‡½æ•°æ˜¯å¦å·²ç»è¢«è°ƒç”¨è¿‡äº†

\index{reassignment}

\begin{lstlisting}
been_called = False

def example2():
    been_called = True         # WRONG
\end{lstlisting}

%
%ğŸ% But if you run it you will see that the value of \verb"been_called"
%ğŸ% doesn't change.  The problem is that {\tt example2} creates a new local
%ğŸ% variable named \verb"been_called".  The local variable goes away when
%ğŸ% the function ends, and has no effect on the global variable.

ä½†æ˜¯å¦‚æœä½ è¿è¡Œå®ƒï¼Œ ä½ ä¼šå‘ç° \li{been_called} çš„å€¼å¹¶æœªå‘ç”Ÿæ”¹å˜ã€‚
é—®é¢˜åœ¨äº \li{example2} ç”Ÿæˆäº†ä¸€ä¸ªæ–°çš„è¢«ç§°ä½œ \li{been_called} çš„å±€éƒ¨å˜é‡ã€‚
å½“å‡½æ•°ç»“æŸçš„æ—¶å€™ï¼Œ è¯¥å±€éƒ¨å˜é‡ä¹Ÿæ¶ˆå¤±äº†ï¼Œ å¹¶ä¸”å¯¹å…¨å±€å˜é‡æ²¡æœ‰å½±å“ã€‚

\index{global statement}  \index{statement!global}
\index{declaration}

%ğŸ% To reassign a global variable inside a function you have to
%ğŸ% {\bf declare} the global variable before you use it:

è¦åœ¨å‡½æ•°å†…å¯¹å…¨å±€å˜é‡é‡æ–°èµ‹å€¼ï¼Œ ä½ å¿…é¡»åœ¨ä½¿ç”¨ä¹‹å‰ {\em å£°æ˜} (declare) è¯¥å…¨å±€å˜é‡ï¼š

\begin{lstlisting}
been_called = False

def example2():
    global been_called
    been_called = True
\end{lstlisting}

%
%ğŸ% The {\bf global statement} tells the interpreter
%ğŸ% something like, ``In this function, when I say \verb"been_called", I
%ğŸ% mean the global variable; don't create a local one.''

\li{global} è¯­å¥ å‘Šè¯‰ç¼–è¯‘å™¨ï¼Œ ``åœ¨è¿™ä¸ªå‡½æ•°é‡Œï¼Œ å½“æˆ‘è¯´ \li{been_called} æ—¶ï¼Œ æˆ‘æŒ‡çš„æ˜¯é‚£ä¸ªå…¨å±€å˜é‡ï¼Œ åˆ«ç”Ÿæˆå±€éƒ¨å˜é‡''ã€‚

\index{update!global variable}  \index{global variable!update}

%ğŸ% Here's an example that tries to update a global variable:

ä¸‹é¢æ˜¯ä¸€ä¸ªè¯•å›¾æ›´æ–°å…¨å±€å˜é‡çš„ä¾‹å­ï¼š

\begin{lstlisting}
count = 0

def example3():
    count = count + 1          # WRONG
\end{lstlisting}

%
%ğŸ% If you run it you get:

ä¸€æ—¦è¿è¡Œï¼Œ ä½ ä¼šå‘ç°ï¼š

\index{UnboundLocalError}  \index{exception!UnboundLocalError}

\begin{lstlisting}
UnboundLocalError: local variable 'count' referenced before assignment
\end{lstlisting}

%
%ğŸ% Python assumes that {\tt count} is local, and under that assumption
%ğŸ% you are reading it before writing it.  The solution, again,
%ğŸ% is to declare {\tt count} global.

Pythoné»˜è®¤ \li{count} æ˜¯å±€éƒ¨å˜é‡ï¼Œ åœ¨è¿™ä¸ªå‡è®¾ä¸‹ï¼Œ ä½ è¿™æ˜¯åœ¨æœªå†™å…¥ä»»ä½•ä¸œè¥¿å‰å°±è¯•å›¾è¯»å–ã€‚
è§£å†³æ–¹æ³•è¿˜æ˜¯å£°æ˜ \li{count} æ˜¯å…¨å±€å˜é‡ã€‚

\index{counter}

\begin{lstlisting}
def example3():
    global count
    count += 1
\end{lstlisting}

%
%ğŸ% If a global variable refers to a mutable value, you can modify
%ğŸ% the value without declaring the variable:

å¦‚æœå…¨å±€å˜é‡æ˜¯å¯å˜çš„ï¼Œ ä½ å¯ä»¥ä¸åŠ å£°æ˜åœ°ä¿®æ”¹å®ƒï¼š

\index{mutability}

\begin{lstlisting}
known = {0:0, 1:1}

def example4():
    known[2] = 1
\end{lstlisting}

%
%ğŸ% So you can add, remove and replace elements of a global list or
%ğŸ% dictionary, but if you want to reassign the variable, you
%ğŸ% have to declare it:

å› æ­¤ä½ å¯ä»¥å¢åŠ ã€åˆ é™¤å’Œæ›¿ä»£å…¨å±€åˆ—è¡¨æˆ–è€…å­—å…¸çš„å…ƒç´ ï¼Œ
ä½†æ˜¯å¦‚æœä½ æƒ³å¯¹å˜é‡é‡æ–°èµ‹å€¼ï¼Œ ä½ å¿…é¡»å£°æ˜å®ƒï¼š

\begin{lstlisting}
def example5():
    global known
    known = dict()
\end{lstlisting}

%
%ğŸ% Global variables can be useful, but if you have a lot of them,
%ğŸ% and you modify them frequently, they can make programs
%ğŸ% hard to debug.

å…¨å±€å˜é‡æœ‰æ—¶æ˜¯å¾ˆæœ‰ç”¨çš„ï¼Œ ä½†å¦‚æœä½ çš„ç¨‹åºä¸­æœ‰å¾ˆå¤šå…¨å±€å˜é‡ï¼Œ è€Œä¸”ä¿®æ”¹é¢‘ç¹ï¼Œ
è¿™æ ·ä¼šå¢åŠ ç¨‹åºè°ƒè¯•çš„éš¾åº¦ã€‚

%ğŸ% \section{Debugging  |  è°ƒè¯•}
\section{è°ƒè¯•}
\index{debugging}

%ğŸ% As you work with bigger datasets it can become unwieldy to
%ğŸ% debug by printing and checking the output by hand.  Here are some
%ğŸ% suggestions for debugging large datasets:

å½“ä½ æ“ä½œè¾ƒå¤§çš„æ•°æ®é›†æ—¶ï¼Œ é€šè¿‡æ‰“å°å¹¶æ‰‹å·¥æ£€æŸ¥æ•°æ®æ¥è°ƒè¯•å¾ˆä¸æ–¹ä¾¿ã€‚
ä¸‹é¢æ˜¯é’ˆå¯¹è°ƒè¯•å¤§æ•°æ®é›†çš„ä¸€äº›å»ºè®®ï¼š

%ğŸ% \begin{description}
%ğŸ%
%ğŸ% \item[Scale down the input:] If possible, reduce the size of the
%ğŸ% dataset.  For example if the program reads a text file, start with
%ğŸ% just the first 10 lines, or with the smallest example you can find.
%ğŸ% You can either edit the files themselves, or (better) modify the
%ğŸ% program so it reads only the first {\tt n} lines.
%ğŸ%
%ğŸ% If there is an error, you can reduce {\tt n} to the smallest
%ğŸ% value that manifests the error, and then increase it gradually
%ğŸ% as you find and correct errors.
%ğŸ%
%ğŸ% \item[Check summaries and types:] Instead of printing and checking the
%ğŸ% entire dataset, consider printing summaries of the data: for example,
%ğŸ% the number of items in a dictionary or the total of a list of numbers.
%ğŸ%
%ğŸ% A common cause of runtime errors is a value that is not the right
%ğŸ% type.  For debugging this kind of error, it is often enough to print
%ğŸ% the type of a value.
%ğŸ%
%ğŸ% \item[Write self-checks:]  Sometimes you can write code to check
%ğŸ% for errors automatically.  For example, if you are computing the
%ğŸ% average of a list of numbers, you could check that the result is
%ğŸ% not greater than the largest element in the list or less than
%ğŸ% the smallest.  This is called a ``sanity check'' because it detects
%ğŸ% results that are ``insane''.
%ğŸ%
%ğŸ% \index{sanity check}  \index{consistency check}
%ğŸ%
%ğŸ% Another kind of check compares the results of two different
%ğŸ% computations to see if they are consistent.  This is called a
%ğŸ% ``consistency check''.
%ğŸ%
%ğŸ% \item[Format the output:] Formatting debugging output
%ğŸ% can make it easier to spot an error.  We saw an example in
%ğŸ% Section~\ref{factdebug}.  The {\tt pprint} module provides
%ğŸ% a {\tt pprint} function that displays built-in types in
%ğŸ% a more human-readable format ({\tt pprint} stands for
%ğŸ% ``pretty print'').
%ğŸ%
%ğŸ% \index{pretty print}  \index{pprint module}
%ğŸ% \index{module!pprint}
%ğŸ%
%ğŸ% \end{description}

\begin{description}

\item[ç¼©å°è¾“å…¥(Scale down the input)ï¼š] å¦‚æœå¯èƒ½ï¼Œ å‡å°æ•°æ®é›†åˆçš„å¤§å°ã€‚
    ä¾‹å¦‚ï¼Œ å¦‚æœç¨‹åºè¯»å…¥ä¸€ä¸ªæ–‡æœ¬æ–‡ä»¶ï¼Œ ä»å‰10è¡Œå¼€å§‹åˆ†æï¼Œ æˆ–æ˜¯æ‰¾åˆ°æ›´å°çš„æ ·ä¾‹ã€‚
    ä½ å¯ä»¥é€‰æ‹©ç¼–è¾‘è¯»å…¥çš„æ–‡ä»¶ï¼Œ æˆ–æ˜¯(æœ€å¥½)ä¿®æ”¹ç¨‹åºä½¿å®ƒåªè¯»å…¥å‰ \li{n} è¡Œã€‚

    å¦‚æœå‡ºé”™äº†ï¼Œ ä½ å¯ä»¥å°† \li{n} ç¼©å°ä¸ºä¼šå¯¼è‡´è¯¥é”™è¯¯çš„æœ€å°å€¼ï¼Œ ç„¶ååœ¨æŸ¥æ‰¾å’Œè§£å†³é”™è¯¯çš„åŒæ—¶ï¼Œ é€æ­¥å¢åŠ  n çš„å€¼ã€‚

\item[æ£€æŸ¥æ‘˜è¦å’Œç±»å‹(Check summaries and types)ï¼š] Insteaè€ƒè™‘æ‰“å°æ•°æ®çš„æ‘˜è¦ï¼Œ è€Œä¸æ˜¯æ‰“å°å¹¶æ£€æŸ¥å…¨éƒ¨æ•°æ®é›†åˆï¼š
    ä¾‹å¦‚ï¼Œ å­—å…¸ä¸­é¡¹çš„æ•°ç›®æˆ–è€…æ•°å­—åˆ—è¡¨çš„æ€»å’Œã€‚

    è¿è¡Œæ—¶é”™è¯¯çš„ä¸€ä¸ªå¸¸è§åŸå› ï¼Œ æ˜¯å€¼çš„ç±»å‹ä¸æ­£ç¡®ã€‚   ä¸ºäº†è°ƒè¯•æ­¤ç±»é”™è¯¯ï¼Œ æ‰“å°å€¼çš„ç±»å‹é€šå¸¸å°±è¶³å¤Ÿäº†ã€‚

\item[ç¼–å†™è‡ªæ£€ä»£ç (Write self-checks)ï¼š]  æœ‰æ—¶ä½ å¯ä»¥å†™ä»£ç æ¥è‡ªåŠ¨æ£€æŸ¥é”™è¯¯ã€‚   ä¾‹å¦‚ï¼Œ å¦‚æœä½ æ­£åœ¨è®¡ç®—æ•°å­—åˆ—è¡¨çš„å¹³å‡æ•°ï¼Œ ä½ å¯ä»¥æ£€æŸ¥å…¶ç»“æœæ˜¯ä¸æ˜¯å¤§äºåˆ—è¡¨ä¸­æœ€å¤§çš„å…ƒç´ ï¼Œ æˆ–è€…å°äºæœ€å°çš„å…ƒç´ ã€‚   è¿™è¢«ç§° ä½œ``åˆç†æ€§æ£€æŸ¥''ï¼Œ å› ä¸ºå®ƒèƒ½æ£€æµ‹å‡º``ä¸åˆç†çš„''ç»“æœã€‚

\index{sanity check}  \index{consistency check}

å¦ä¸€ç±»æ£€æŸ¥æ˜¯æ¯”è¾ƒä¸¤ä¸ªä¸åŒè®¡ç®—çš„ç»“æœï¼Œ æ¥çœ‹ä¸€ä¸‹å®ƒä»¬æ˜¯å¦ä¸€è‡´ã€‚  è¿™è¢«ç§°ä½œ ``ä¸€è‡´æ€§æ£€æŸ¥''ã€‚

\item[æ ¼å¼åŒ–è¾“å‡º(Format the output)ï¼š] æ ¼å¼åŒ–è°ƒè¯•è¾“å‡ºèƒ½å¤Ÿæ›´å®¹æ˜“å®šä½ä¸€ä¸ªé”™è¯¯ã€‚   æˆ‘ä»¬åœ¨ \ref{factdebug} ä¸€èŠ‚ä¸­çœ‹è¿‡ä¸€ä¸ªç¤ºä¾‹ã€‚   \li{pprint} æ¨¡å—æä¾›äº†ä¸€ä¸ª \li{pprint} å‡½æ•°ï¼Œ å®ƒå¯ä»¥æ›´å¯è¯»çš„æ ¼å¼æ˜¾ç¤ºå†…å»ºç±»å‹( \li{pprint} ä»£è¡¨ ``pretty print'')ã€‚

\index{pretty print}  \index{pprint module}
\index{module!pprint}

\end{description}

%ğŸ% Again, time you spend building scaffolding can reduce
%ğŸ% the time you spend debugging.

é‡ç”³ä¸€æ¬¡ï¼Œ ä½ èŠ±åœ¨æ­å»ºè„šæ‰‹æ¶ä¸Šçš„æ—¶é—´èƒ½å‡å°‘ä½ èŠ±åœ¨è°ƒè¯•ä¸Šçš„æ—¶é—´ã€‚

\index{scaffolding}


%ğŸ% \section{Glossary  |  æœ¯è¯­è¡¨}
\section{æœ¯è¯­è¡¨}

\begin{description}

%ğŸ% \item[mapping:] A relationship in which each element of one set
%ğŸ% corresponds to an element of another set.
%ğŸ%
%ğŸ% \index{mapping}

\item[æ˜ å°„ (mapping)ï¼š] ä¸€ä¸ªé›†åˆä¸­çš„æ¯ä¸ªå…ƒç´ å¯¹åº”å¦ä¸€ä¸ªé›†åˆä¸­çš„ä¸€ä¸ªå…ƒç´ çš„å…³ç³»ã€‚

\index{mapping}

%ğŸ% \item[dictionary:] A mapping from keys to their
%ğŸ% corresponding values.
%ğŸ%
%ğŸ% \index{dictionary}

\item[å­—å…¸ (dictionary)ï¼š] å°†é”®æ˜ å°„åˆ°å¯¹åº”å€¼çš„æ˜ å°„ã€‚

\index{dictionary}

%ğŸ% \item[key-value pair:] The representation of the mapping from
%ğŸ% a key to a value.
%ğŸ%
%ğŸ% \index{key-value pair}

\item[é”®å€¼å¯¹ (key-value pair)ï¼š] é”®å€¼ä¹‹é—´æ˜ å°„å…³ç³»çš„å‘ˆç°å½¢å¼ã€‚

\index{key-value pair}

%ğŸ% \item[item:] In a dictionary, another name for a key-value
%ğŸ%   pair.
%ğŸ%
%ğŸ% \index{item!dictionary}

\item[é¡¹ (item)ï¼š] åœ¨å­—å…¸ä¸­ï¼Œ è¿™æ˜¯é”®å€¼å¯¹çš„å¦ä¸€ä¸ªåç§°ã€‚

\index{item!dictionary}

%ğŸ% \item[key:] An object that appears in a dictionary as the
%ğŸ% first part of a key-value pair.
%ğŸ%
%ğŸ% \index{key}

\item[é”® (key)ï¼š] å­—å…¸ä¸­ä½œä¸ºé”®å€¼å¯¹ç¬¬ä¸€éƒ¨åˆ†çš„å¯¹è±¡ã€‚

%ğŸ% \index{key}
%ğŸ%
%ğŸ% \item[value:] An object that appears in a dictionary as the
%ğŸ% second part of a key-value pair.  This is more specific than
%ğŸ% our previous use of the word ``value''.
%ğŸ%
%ğŸ% \index{value}

\item[å€¼ (value)ï¼š] å­—å…¸ä¸­ä½œä¸ºé”®å€¼å¯¹ç¬¬äºŒéƒ¨åˆ†çš„å¯¹è±¡ã€‚  å®ƒæ¯”æˆ‘ä»¬ä¹‹å‰æ‰€ç”¨çš„``å€¼''ä¸€è¯æ›´å…·ä½“ã€‚

\index{value}

%ğŸ% \item[implementation:] A way of performing a computation.
%ğŸ%
%ğŸ% \index{implementation}

\item[å®ç° (implementation)ï¼š] æ‰§è¡Œè®¡ç®—çš„ä¸€ç§å½¢å¼ã€‚

\index{implementation}

%ğŸ% \item[hashtable:] The algorithm used to implement Python
%ğŸ% dictionaries.
%ğŸ%
%ğŸ% \index{hashtable}

\item[å“ˆå¸Œè¡¨ (hashtable)ï¼š] ç”¨æ¥å®ç°Pythonå­—å…¸çš„ç®—æ³•ã€‚

\index{hashtable}

%ğŸ% \item[hash function:] A function used by a hashtable to compute the
%ğŸ% location for a key.
%ğŸ%
%ğŸ% \index{hash function}

\item[å“ˆå¸Œå‡½æ•° (hash function)ï¼š] å“ˆå¸Œè¡¨ç”¨æ¥è®¡ç®—é”®çš„ä½ç½®çš„å‡½æ•°ã€‚

\index{hash function}

%ğŸ% \item[hashable:] A type that has a hash function.  Immutable
%ğŸ% types like integers,
%ğŸ% floats and strings are hashable; mutable types like lists and
%ğŸ% dictionaries are not.
%ğŸ%
%ğŸ% \index{hashable}

\item[å¯å“ˆå¸Œçš„ (hashable)ï¼š] å…·å¤‡å“ˆå¸Œå‡½æ•°çš„ç±»å‹ã€‚  è¯¸å¦‚æ•´æ•°ã€æµ®ç‚¹æ•°å’Œå­—ç¬¦ä¸²è¿™æ ·çš„ä¸å¯å˜ç±»å‹æ˜¯å¯å“ˆå¸Œçš„ï¼›è¯¸å¦‚åˆ—è¡¨å’Œå­—å…¸è¿™æ ·çš„å¯å˜å¯¹è±¡æ˜¯ä¸å¯å“ˆå¸Œçš„ã€‚

\index{hashable}

%ğŸ% \item[lookup:] A dictionary operation that takes a key and finds
%ğŸ% the corresponding value.
%ğŸ%
%ğŸ% \index{lookup}

\item[æŸ¥æ‰¾ (lookup)ï¼š] æ¥å—ä¸€ä¸ªé”®å¹¶è¿”å›ç›¸åº”å€¼çš„å­—å…¸æ“ä½œã€‚

\index{lookup}

%ğŸ% \item[reverse lookup:] A dictionary operation that takes a value and finds
%ğŸ% one or more keys that map to it.
%ğŸ%
%ğŸ% \index{reverse lookup}

\item[é€†å‘æŸ¥æ‰¾ (reverse lookup)ï¼š] æ¥å—ä¸€ä¸ªå€¼å¹¶è¿”å›ä¸€ä¸ªæˆ–å¤šä¸ªæ˜ å°„è‡³è¯¥å€¼çš„é”®çš„å­—å…¸æ“ä½œã€‚

\index{reverse lookup}

%ğŸ% \item[raise statement:]  A statement that (deliberately) raises an exception.
%ğŸ%
%ğŸ% \index{raise statement}  \index{statement!raise}

\item[raiseè¯­å¥ï¼š]  ä¸“é—¨å°å‘å¼‚å¸¸çš„ä¸€ä¸ªè¯­å¥ã€‚

\index{raise statement}  \index{statement!raise}

%ğŸ% \item[singleton:] A list (or other sequence) with a single element.
%ğŸ% \index{singleton}

\item[å•å…ƒç´ é›†åˆ (singleton)ï¼š] åªæœ‰ä¸€ä¸ªå…ƒç´ çš„åˆ—è¡¨(æˆ–å…¶ä»–åºåˆ—)ã€‚
\index{singleton}

%ğŸ% \item[call graph:] A diagram that shows every frame created during
%ğŸ% the execution of a program, with an arrow from each caller to
%ğŸ% each callee.
%ğŸ%
%ğŸ% \index{call graph}  \index{diagram!call graph}

\item[è°ƒç”¨å›¾ (call graph)ï¼š] ç»˜å‡ºç¨‹åºæ‰§è¡Œè¿‡ç¨‹ä¸­åˆ›å»ºçš„æ¯ä¸ªæ ˆå¸§çš„è°ƒç”¨å›¾ï¼Œ å…¶ä¸­çš„ç®­å¤´ä»è°ƒç”¨è€…æŒ‡å‘è¢«è°ƒç”¨è€…ã€‚

\index{call graph}  \index{diagram!call graph}

%ğŸ% \item[memo:] A computed value stored to avoid unnecessary future
%ğŸ% computation.
%ğŸ%
%ğŸ% \index{memo}

\item[å¤‡å¿˜å½• (memo)ï¼š] ä¸€ä¸ªå­˜å‚¨çš„è®¡ç®—å€¼ï¼Œ é¿å…ä¹‹åè¿›è¡Œä¸å¿…è¦çš„è®¡ç®—ã€‚

\index{memo}

%ğŸ% \item[global variable:]  A variable defined outside a function.  Global
%ğŸ% variables can be accessed from any function.
%ğŸ%
%ğŸ% \index{global variable}

\item[å…¨å±€å˜é‡ (global variable)ï¼š]  åœ¨å‡½æ•°å¤–éƒ¨å®šä¹‰çš„å˜é‡ã€‚  ä»»ä½•å‡½æ•°éƒ½å¯ä»¥è®¿é—®å…¨å±€å˜é‡ã€‚

\index{global variable}

%ğŸ% \item[global statement:]  A statement that declares a variable name
%ğŸ% global.
%ğŸ%
%ğŸ% \index{global statement}  \index{statement!global}

\item[globalè¯­å¥ï¼š]  å°†å˜é‡åå£°æ˜ä¸ºå…¨å±€å˜é‡çš„è¯­å¥ã€‚

\index{global statement}  \index{statement!global}

%ğŸ% \item[flag:] A boolean variable used to indicate whether a condition
%ğŸ% is true.
%ğŸ%
%ğŸ% \index{flag}

\item[æ ‡è®° (flag)ï¼š] ç”¨äºè¯´æ˜ä¸€ä¸ªæ¡ä»¶æ˜¯å¦ä¸ºçœŸçš„å¸ƒå°”å˜é‡ã€‚

\index{flag}

%ğŸ% \item[declaration:] A statement like {\tt global} that tells the
%ğŸ% interpreter something about a variable.
%ğŸ%
%ğŸ% \index{declaration}

\item[å£°æ˜ (declaration)ï¼š] ç±»ä¼¼ \li{global} è¿™ç§å‘ŠçŸ¥è§£é‡Šå™¨å¦‚ä½•å¤„ç†å˜é‡çš„è¯­å¥ã€‚

\index{declaration}

\end{description}



%ğŸ% \section{Exercises  |  ç»ƒä¹ }
\section{ç»ƒä¹ }

\begin{exercise}
\label{wordlist2}

\index{set membership}  \index{membership!set}

%ğŸ% Write a function that reads the words in {\tt words.txt} and
%ğŸ% stores them as keys in a dictionary.  It doesn't matter what the
%ğŸ% values are.  Then you can use the {\tt in} operator
%ğŸ% as a fast way to check whether a string is in
%ğŸ% the dictionary.
%ğŸ%
%ğŸ% If you did Exercise~\ref{wordlist1}, you can compare the speed
%ğŸ% of this implementation with the list {\tt in} operator and the
%ğŸ% bisection search.

ç¼–å†™ä¸€å‡½æ•°ï¼Œ è¯»å– {\em \li{words.txt}} ä¸­çš„å•è¯å¹¶å­˜å‚¨ä¸ºå­—å…¸ä¸­çš„é”®ã€‚  å€¼æ˜¯ä»€ä¹ˆæ— æ‰€è°“ã€‚
ç„¶åï¼Œ ä½ å¯ä»¥ä½¿ç”¨ {\em \li{in}} æ“ä½œç¬¦æ£€æŸ¥ä¸€ä¸ªå­—ç¬¦ä¸²æ˜¯å¦åœ¨å­—å…¸ä¸­ã€‚

å¦‚æœä½ åšè¿‡ ç»ƒä¹ ~\ref{wordlist1} ï¼Œ å¯ä»¥æ¯”è¾ƒä¸€ä¸‹ {\em \li{in}} æ“ä½œç¬¦å’ŒäºŒåˆ†æŸ¥æ‰¾çš„é€Ÿåº¦ã€‚

\end{exercise}


\begin{exercise}
\label{setdefault}

%ğŸ% Read the documentation of the dictionary method {\tt setdefault}
%ğŸ% and use it to write a more concise version of \verb"invert_dict".
%ğŸ% Solution: \url{http://thinkpython2.com/code/invert_dict.py}.

æŸ¥çœ‹å­—å…¸æ–¹æ³• {\em \li{setdefault}} çš„æ–‡æ¡£ï¼Œ å¹¶ä½¿ç”¨è¯¥æ–¹æ³•å†™ä¸€ä¸ªæ›´ç®€æ´çš„ {\em \li{invert_dict}}ã€‚

\index{setdefault method}  \index{method!setdefault}

\end{exercise}


\begin{exercise}
%ğŸ% Memoize the Ackermann function from Exercise~\ref{ackermann} and see if
%ğŸ% memoization makes it possible to evaluate the function with bigger
%ğŸ% arguments.  Hint: no.
%ğŸ% Solution: \url{http://thinkpython2.com/code/ackermann_memo.py}.

å°† ç»ƒä¹ ~{\em \ref{ackermann}} ä¸­çš„ {\em Ackermann} å‡½æ•°å¤‡å¿˜å½•åŒ–\footnote{memoization}ï¼Œ çœ‹çœ‹å¤‡å¿˜å½•åŒ–æ˜¯å¦å¯ä»¥æ”¯æŒè§£å†³æ›´å¤§çš„å‚æ•°ã€‚   æ²¡æœ‰æç¤ºï¼

\href{http://thinkpython2.com/code/ackermann_memo.py}{å‚è€ƒç­”æ¡ˆ}
\index{Ackermann function}  \index{function!ack}

\end{exercise}

\begin{exercise}

\index{duplicate}

%ğŸ% If you did Exercise~\ref{duplicate}, you already have
%ğŸ% a function named \verb"has_duplicates" that takes a list
%ğŸ% as a parameter and returns {\tt True} if there is any object
%ğŸ% that appears more than once in the list.
%ğŸ%
%ğŸ% Use a dictionary to write a faster, simpler version of
%ğŸ% \verb"has_duplicates".
%ğŸ% Solution: \url{http://thinkpython2.com/code/has_duplicates.py}.

å¦‚æœä½ åšäº† ç»ƒä¹ ~{\em \ref{duplicate}} ï¼Œ ä½ å°±å·²ç»æœ‰äº†ä¸€ä¸ªå« {\em \li{has_duplicates}} çš„å‡½æ•°ï¼Œ å®ƒæ¥å—ä¸€ä¸ªåˆ—è¡¨ä½œä¸ºå‚æ•°ï¼Œ å¦‚æœå…¶ä¸­æœ‰æŸä¸ªå¯¹è±¡åœ¨åˆ—è¡¨ä¸­å‡ºç°ä¸æ­¢ä¸€æ¬¡å°±è¿”å› {\em \li{True}}ã€‚

ç”¨å­—å…¸å†™ä¸ªæ›´å¿«ã€æ›´ç®€å•çš„ç‰ˆæœ¬ã€‚

\href{http://thinkpython2.com/code/has_duplicates.py}{å‚è€ƒç­”æ¡ˆ}


\end{exercise}


\begin{exercise}
\label{exrotatepairs}

\index{letter rotation}  \index{rotation!letters}

%ğŸ% Two words are ``rotate pairs'' if you can rotate one of them
%ğŸ% and get the other (see \verb"rotate_word" in Exercise~\ref{exrotate}).
%ğŸ%
%ğŸ% Write a program that reads a wordlist and finds all the rotate
%ğŸ% pairs.  Solution: \url{http://thinkpython2.com/code/rotate_pairs.py}.

ä¸¤ä¸ªå•è¯å¦‚æœåè½¬å…¶ä¸­ä¸€ä¸ªå°±ä¼šå¾—åˆ°å¦ä¸€ä¸ªï¼Œ åˆ™è¢«ç§°ä½œ ``åè½¬å¯¹''(å‚è§ ç»ƒä¹ ~{\em \ref{exrotate}} ä¸­çš„ {\em \li{rotate_word}} ã€‚

ç¼–å†™ä¸€ç¨‹åºï¼Œ è¯»å…¥å•è¯è¡¨å¹¶æ‰¾åˆ°æ‰€æœ‰åè½¬å¯¹ã€‚

\href{http://thinkpython2.com/code/rotate_pairs.py}{å‚è€ƒç­”æ¡ˆ}

\end{exercise}


\begin{exercise}

\index{Car Talk}  \index{Puzzler}

%ğŸ% Here's another Puzzler from {\em Car Talk}
%ğŸ% (\url{http://www.cartalk.com/content/puzzlers}):

ä¸‹é¢æ˜¯å–è‡ª {\em Car Talk} çš„å¦ä¸€ä¸ªå­—\href{http://www.cartalk.com/content/puzzlers}{è°œé¢˜}ï¼š

%ğŸ% \begin{quote}
%ğŸ% This was sent in by a fellow named Dan O'Leary. He came upon a common
%ğŸ% one-syllable, five-letter word recently that has the following unique
%ğŸ% property. When you remove the first letter, the remaining letters form
%ğŸ% a homophone of the original word, that is a word that sounds exactly
%ğŸ% the same. Replace the first letter, that is, put it back and remove
%ğŸ% the second letter and the result is yet another homophone of the
%ğŸ% original word. And the question is, what's the word?
%ğŸ%
%ğŸ% Now I'm going to give you an example that doesn't work. Let's look at
%ğŸ% the five-letter word, `wrack.' W-R-A-C-K, you know like to `wrack with
%ğŸ% pain.' If I remove the first letter, I am left with a four-letter
%ğŸ% word, 'R-A-C-K.' As in, `Holy cow, did you see the rack on that buck!
%ğŸ% It must have been a nine-pointer!' It's a perfect homophone. If you
%ğŸ% put the `w' back, and remove the `r,' instead, you're left with the
%ğŸ% word, `wack,' which is a real word, it's just not a homophone of the
%ğŸ% other two words.
%ğŸ%
%ğŸ% But there is, however, at least one word that Dan and we know of,
%ğŸ% which will yield two homophones if you remove either of the first two
%ğŸ% letters to make two, new four-letter words. The question is, what's
%ğŸ% the word?
%ğŸ% \end{quote}

\begin{quote}

è¿™æ˜¯æ¥è‡ªä¸€ä½åå« {\em Dan O'Leary} çš„æœ‹å‹çš„åˆ†äº«ã€‚  ä»–æœ‰ä¸€æ¬¡ç¢°åˆ°äº†ä¸€ä¸ªå¸¸è§çš„å•éŸ³èŠ‚ã€æœ‰äº”ä¸ªå­—æ¯çš„å•è¯ï¼Œ å®ƒå…·å¤‡ä»¥ä¸‹ç‹¬ç‰¹çš„ç‰¹æ€§ã€‚  å½“ä½ ç§»é™¤ç¬¬ä¸€ä¸ªå­—æ¯æ—¶ï¼Œ å‰©ä¸‹çš„å­—æ¯ç»„æˆäº†åŸå•è¯çš„åŒéŸ³è¯ï¼Œ å³å‘éŸ³å®Œå…¨ç›¸åŒçš„å•è¯ã€‚  å°†ç¬¬ä¸€ä¸ªå­—æ¯æ”¾å›ï¼Œ ç„¶åå–å‡ºç¬¬äºŒä¸ªå­—æ¯ï¼Œ ç»“æœåˆæ˜¯åŸå•è¯çš„å¦ä¸€ä¸ªåŒéŸ³è¯ã€‚  é‚£ä¹ˆé—®é¢˜æ¥äº†ï¼Œ è¿™ä¸ªå•è¯æ˜¯ä»€ä¹ˆï¼Ÿ

æ¥ä¸‹æ¥æˆ‘ç»™å¤§å®¶ä¸¾ä¸€ä¸ªä¸æ»¡è¶³è¦æ±‚çš„ä¾‹å­ã€‚  æˆ‘ä»¬æ¥çœ‹ä¸€ä¸ªäº”ä¸ªå­—æ¯çš„å•è¯ {\em ``wrack''}ã€‚  W-R-A-C-Kï¼Œ å¸¸ç”¨çŸ­å¥ä¸º  {\em ``wrack with pain''}ã€‚   å¦‚æœæˆ‘ç§»é™¤ç¬¬ä¸€ä¸ªå­—æ¯ï¼Œ å°±å‰©ä¸‹äº†ä¸€ä¸ªå››ä¸ªå­—æ¯çš„å•è¯  {\em ``R-A-C-K''}ã€‚  å¯ä»¥è¿™ä¹ˆç”¨ï¼Œ  {\em ``Holy cow, did you see the rack on that buck! It must have been a nine-pointer!''} å®ƒæ˜¯ä¸€ä¸ªå®Œç¾çš„åŒéŸ³è¯ã€‚  å¦‚æœä½ æŠŠ  {\em ``w''} æ”¾å›å»ï¼Œ ç§»é™¤  {\em ``r''}ï¼Œ  ä½ å¾—åˆ°çš„å•è¯æ˜¯  {\em ``wack''} ã€‚   è¿™æ˜¯ä¸€ä¸ªçœŸå®çš„å•è¯ï¼Œ ä½†å¹¶ä¸æ˜¯å‰ä¸¤ä¸ªå•è¯çš„åŒéŸ³è¯ã€‚

ä¸è¿‡ï¼Œ æˆ‘ä»¬å’Œ {\em Dan} çŸ¥é“è‡³å°‘æœ‰ä¸€ä¸ªå•è¯æ˜¯æ»¡è¶³è¿™ä¸ªæ¡ä»¶çš„ï¼Œ å³ç§»é™¤å‰ä¸¤ä¸ªå­—æ¯ä¸­çš„ä»»æ„ä¸€ä¸ªï¼Œ å°†ä¼šå¾—åˆ°ä¸¤ä¸ªæ–°çš„ç”±å››ä¸ªå­—æ¯ç»„æˆçš„å•è¯ï¼Œ è€Œä¸”å‘éŸ³å®Œå…¨ä¸€è‡´ã€‚  é‚£ä¹ˆè¿™ä¸ªå•è¯æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿ

\end{quote}

\index{homophone}  \index{reducible word}
\index{word, reducible}

%ğŸ% You can use the dictionary from Exercise~\ref{wordlist2} to check
%ğŸ% whether a string is in the word list.

ä½ å¯ä»¥ä½¿ç”¨ ç»ƒä¹ ~{\em \ref{wordlist2}} ä¸­çš„å­—å…¸æ£€æŸ¥æŸå­—ç¬¦ä¸²æ˜¯å¦å‡ºç°åœ¨å•è¯è¡¨ä¸­ã€‚

%ğŸ% To check whether two words are homophones, you can use the CMU
%ğŸ% Pronouncing Dictionary.  You can download it from
%ğŸ% \url{http://www.speech.cs.cmu.edu/cgi-bin/cmudict} or from
%ğŸ% \url{http://thinkpython2.com/code/c06d} and you can also download
%ğŸ% \url{http://thinkpython2.com/code/pronounce.py}, which provides a function
%ğŸ% named \verb"read_dictionary" that reads the pronouncing dictionary and
%ğŸ% returns a Python dictionary that maps from each word to a string that
%ğŸ% describes its primary pronunciation.

ä½ å¯ä»¥ä½¿ç”¨CMUå‘éŸ³å­—å…¸æ£€æŸ¥ä¸¤ä¸ªå•è¯æ˜¯å¦ä¸ºåŒéŸ³è¯ã€‚  ä» \href{http://www.speech.cs.cmu.edu/cgi-bin/cmudict}{è¿™é‡Œ} æˆ– \href{http://thinkpython2.com/code/c06d}{è¿™é‡Œ} ä¸‹è½½ã€‚   ä½ è¿˜å¯ä»¥ä¸‹è½½\href{http://thinkpython2.com/code/pronounce.py}{ è¿™ä¸ªè„šæœ¬}ï¼Œ å…¶ä¸­æä¾›äº†ä¸€ä¸ªåå« \li{read_dictionary} çš„å‡½æ•°ï¼Œ å¯ä»¥è¯»å–å‘éŸ³å­—å…¸ï¼Œ å¹¶è¿”å›ä¸€ä¸ªå°†æ¯ä¸ªå•è¯æ˜ å°„è‡³æè¿°å…¶ä¸»è¦æ¢µéŸ³çš„å­—ç¬¦ä¸²çš„Pythonå­—å…¸ã€‚

%ğŸ% Write a program that lists all the words that solve the Puzzler.
%ğŸ% Solution: \url{http://thinkpython2.com/code/homophone.py}.

ç¼–å†™ä¸€ä¸ªç¨‹åºï¼Œ æ‰¾åˆ°æ»¡è¶³å­—è°œé¢˜æ¡ä»¶çš„æ‰€æœ‰å•è¯ã€‚

\href{http://thinkpython2.com/code/homophone.py}{å‚è€ƒç­”æ¡ˆ}

\end{exercise}
