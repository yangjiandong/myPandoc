

%ğŸ% \chapter{Case study: interface design  |  æ¡ˆä¾‹ç ”ç©¶ï¼šæ¥å£è®¾è®¡}
\chapter{æ¡ˆä¾‹ç ”ç©¶ï¼šæ¥å£è®¾è®¡}
\label{turtlechap}

%ğŸ% This chapter presents a case study that demonstrates a process for
%ğŸ% designing functions that work together.
%ğŸ% 
%ğŸ% It introduces the {\tt turtle} module, which allows you to
%ğŸ% create images using turtle graphics.  The {\tt turtle} module is
%ğŸ% included in most Python installations, but if you are running Python
%ğŸ% using PythonAnywhere, you won't be able to run the turtle examples (at
%ğŸ% least you couldn't when I wrote this).
%ğŸ% 
%ğŸ% If you have already installed Python on your computer, you should
%ğŸ% be able to run the examples.  Otherwise, now is a good time
%ğŸ% to install.  I have posted instructions at
%ğŸ% \url{http://tinyurl.com/thinkpython2e}.
%ğŸ% 
%ğŸ% Code examples from this chapter are available from
%ğŸ% \url{http://thinkpython2.com/code/polygon.py}.

æœ¬ç« å°†é€šè¿‡ä¸€ä¸ªæ¡ˆä¾‹ç ”ç©¶ï¼Œ ä»‹ç»å¦‚ä½•è®¾è®¡å‡ºç›¸äº’é…åˆçš„å‡½æ•°ã€‚

æœ¬ç« ä¼šä»‹ç» \li{turtle} æ¨¡å—ï¼Œå®ƒå¯ä»¥è®©ä½ ä½¿ç”¨æµ·é¾Ÿå›¾å½¢ (turtle graphics) ç»˜åˆ¶å›¾åƒã€‚å¤§éƒ¨åˆ†çš„Pythonå®‰è£…ç¯å¢ƒä¸‹éƒ½åŒ…å«äº†è¿™ä¸ªæ¨¡å—ï¼Œä½†æ˜¯å¦‚æœä½ æ˜¯åœ¨ PythonAnywhere ä¸Šè¿è¡Œ Python çš„ï¼Œä½ å°†æ— æ³•è¿è¡Œæœ¬ç« ä¸­çš„ä»£ç ç¤ºä¾‹ï¼ˆè‡³å°‘åœ¨æˆ‘å†™è¿™ç« æ—¶æ˜¯åšä¸åˆ°çš„ï¼‰ã€‚

å¦‚æœä½ å·²ç»åœ¨è‡ªå·±çš„ç”µè„‘ä¸Šå®‰è£…äº† Pythonï¼Œé‚£ä¹ˆä¸ä¼šæœ‰é—®é¢˜ã€‚å¦‚æœæ²¡æœ‰ï¼Œç°åœ¨å°±æ˜¯å®‰è£… Python çš„å¥½æ—¶æœºã€‚æˆ‘åœ¨ \href{http://tinyurl.com/thinkpython2e}{è¿™ä¸ªé¡µé¢} ä¸Šå‘å¸ƒäº†ç›¸å…³æŒ‡å—ã€‚

æœ¬ç« çš„ç¤ºä¾‹ä»£ç å¯ä»¥ \href{http://thinkpython2.com/code/polygon.py}{ä»è¿™è·å¾—}ã€‚

%ğŸ% \section{The turtle module  |  turtle æ¨¡å—}
\section{turtle æ¨¡å—}
\label{turtle}

%ğŸ% To check whether you have the {\tt turtle} module, open the Python
%ğŸ% interpreter and type

æ‰“å¼€Pythonè§£é‡Šå™¨ï¼Œè¾“å…¥ä»¥ä¸‹ä»£ç ï¼Œæ£€æŸ¥ä½ æ˜¯å¦å®‰è£…äº† \li{turltle} æ¨¡å—ï¼š

\begin{lstlisting}
>>> import turtle
>>> bob = turtle.Turtle()
\end{lstlisting}

%ğŸ% When you run this code, it should create a new window
%ğŸ% with small arrow that represents the turtle.  Close the window.

ä¸Šè¿°ä»£ç è¿è¡Œåï¼Œåº”è¯¥ä¼šæ–°å»ºä¸€ä¸ªçª—å£ï¼Œçª—å£ä¸­é—´æœ‰ä¸€ä¸ªå°ç®­å¤´ï¼Œä»£è¡¨çš„å°±æ˜¯æµ·é¾Ÿã€‚ç°åœ¨å…³é—­çª—å£ã€‚

%ğŸ% Create a file named {\tt mypolygon.py} and type in the following
%ğŸ% code:

æ–°å»ºä¸€ä¸ªåå«  \li{mypolygon.py} çš„æ–‡ä»¶ï¼Œè¾“å…¥ä»¥ä¸‹ä»£ç ï¼š

\begin{lstlisting}
import turtle
bob = turtle.Turtle()
print(bob)
turtle.mainloop()
\end{lstlisting}

%ğŸ% %
%ğŸ% The {\tt turtle} module (with a lowercase 't') provides a function
%ğŸ% called {\tt Turtle} (with an uppercase 'T') that creates a Turtle
%ğŸ% object, which we assign to a variable named {\tt bob}.
%ğŸ% Printing {\tt bob} displays something like:

\li{turtle} æ¨¡å—ï¼ˆå°å†™çš„ \li{'t'} ï¼‰æä¾›äº†ä¸€ä¸ªå«ä½œ \li{Turtle} çš„å‡½æ•°ï¼ˆå¤§å†™çš„ \li{'T'}ï¼‰ï¼Œè¿™ä¸ªå‡½æ•°ä¼šåˆ›å»ºä¸€ä¸ª \li{Turtle} å¯¹è±¡ï¼Œæˆ‘ä»¬å°†å…¶èµ‹å€¼ç»™åä¸º \li{bob} çš„å˜é‡ã€‚æ‰“å° \li{bob} çš„è¯ï¼Œä¼šè¾“å‡ºä¸‹é¢è¿™æ ·çš„ç»“æœï¼š

\begin{lstlisting}
<turtle.Turtle object at 0xb7bfbf4c>
\end{lstlisting}

%ğŸ% %
%ğŸ% This means that {\tt bob} refers to an object with type
%ğŸ% {\tt Turtle}
%ğŸ% as defined in module {\tt turtle}.

è¿™æ„å‘³ç€ï¼Œ\li{bob} æŒ‡å‘ä¸€ä¸ªç±»å‹ä¸ºTurtleçš„å¯¹è±¡ï¼Œè¿™ä¸ªç±»å‹æ˜¯ç”± \li{turtle} æ¨¡å—å®šä¹‰çš„ã€‚

%ğŸ% \verb"mainloop" tells the window to wait for the user
%ğŸ% to do something, although in this case there's not much for
%ğŸ% the user to do except close the window.

\li{mainloop} å‘Šè¯‰çª—å£ç­‰å¾…ç”¨æˆ·æ“ä½œï¼Œå°½ç®¡åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œç”¨æˆ·é™¤äº†å…³é—­çª—å£ä¹‹å¤–ï¼Œå¹¶æ²¡æœ‰å…¶ä»–å¯åšçš„äº‹æƒ…ã€‚

%ğŸ% Once you create a Turtle, you can call a {\bf method} to move it
%ğŸ% around the window.  A method is similar to a function, but it
%ğŸ% uses slightly different syntax.  For example, to move the turtle
%ğŸ% forward:

åˆ›å»ºäº†ä¸€ä¸ª \li{Turtle} å¯¹è±¡ä¹‹åï¼Œä½ å¯ä»¥è°ƒç”¨ \emph{æ–¹æ³•} (method) æ¥åœ¨çª—å£ä¸­ç§»åŠ¨è¯¥å¯¹è±¡ã€‚æ–¹æ³•ä¸å‡½æ•°ç±»ä¼¼ï¼Œä½†æ˜¯å…¶è¯­æ³•ç•¥æœ‰ä¸åŒã€‚ä¾‹å¦‚ï¼Œè¦è®©æµ·é¾Ÿå‘å‰èµ°ï¼š

\begin{lstlisting}
bob.fd(100)
\end{lstlisting}

%ğŸ% %
%ğŸ% The method, {\tt fd}, is associated with the turtle
%ğŸ% object we're calling {\tt bob}.
%ğŸ% Calling a method is like making a request: you are asking {\tt bob}
%ğŸ% to move forward.

æ–¹æ³• \li{fd} ä¸æˆ‘ä»¬ç§°ä¹‹ä¸º \li{bob} çš„å¯¹è±¡æ˜¯ç›¸å…³è”çš„ã€‚è°ƒç”¨æ–¹æ³•å°±åƒæå‡ºä¸€ä¸ªè¯·æ±‚ï¼šä½ åœ¨è¯·æ±‚ \li{bob} å¾€å‰èµ°ã€‚

%ğŸ% The argument of {\tt fd} is a distance in pixels, so the actual
%ğŸ% size depends on your display.

\li{fd} æ–¹æ³•çš„å®å‚æ˜¯åƒç´ è·ç¦»ï¼Œæ‰€ä»¥å®é™…å‰è¿›çš„è·ç¦»å–å†³äºä½ çš„å±å¹•ã€‚

%ğŸ% Other methods you can call on a Turtle are {\tt bk} to move
%ğŸ% backward, {\tt lt} for left turn, and {\tt rt} right turn.  The
%ğŸ% argument for {\tt lt} and {\tt rt} is an angle in degrees.

\li{Turtle} å¯¹è±¡ä¸­ä½ èƒ½è°ƒç”¨çš„å…¶ä»–æ–¹æ³•è¿˜åŒ…æ‹¬ï¼šè®©å®ƒå‘åèµ°çš„ \li{bk} ï¼Œå‘å·¦è½¬çš„ \li{lt} ï¼Œå‘å³è½¬çš„ \li{rt} ã€‚ \li{lt} å’Œ \li{rt} è¿™ä¸¤ä¸ªæ–¹æ³•æ¥å—çš„å®å‚æ˜¯è§’åº¦ã€‚

%ğŸ% Also, each Turtle is holding a pen, which is
%ğŸ% either down or up; if the pen is down, the Turtle leaves
%ğŸ% a trail when it moves.  The methods {\tt pu} and {\tt pd}
%ğŸ% stand for ``pen up'' and ``pen down''.

å¦å¤–ï¼Œæ¯ä¸ª \li{Turtle} éƒ½æ¡ç€ä¸€æ”¯ç¬”ï¼Œä¸æ˜¯è½ç¬”å°±æ˜¯æŠ¬ç¬”ï¼›å¦‚æœè½ç¬”äº†ï¼Œ \li{Turtle} å°±ä¼šåœ¨ç§»åŠ¨æ—¶ç•™ä¸‹ç—•è¿¹ã€‚ \li{pu} å’Œ \li{pd} è¿™ä¸¤ä¸ªæ–¹æ³•åˆ†åˆ«ä»£è¡¨``æŠ¬ç¬” (pen up)''å’Œ ``è½ç¬” (pen down)''ã€‚

%ğŸ% To draw a right angle, add these lines to the program
%ğŸ% (after creating {\tt bob} and before calling \verb"mainloop"):

å¦‚æœè¦ç”»ä¸€ä¸ªç›´è§’ (right angle)ï¼Œè¯·åœ¨ç¨‹åºä¸­æ·»åŠ ä»¥ä¸‹ä»£ç ï¼ˆæ”¾åœ¨åˆ›å»º \li{bob} ä¹‹åï¼Œè°ƒç”¨ \li{mainloop} ä¹‹å‰ï¼‰ï¼š

\begin{lstlisting}
bob.fd(100)
bob.lt(90)
bob.fd(100)
\end{lstlisting}

%ğŸ% %
%ğŸ% When you run this program, you should see {\tt bob} move east and then
%ğŸ% north, leaving two line segments behind.

å½“ä½ è¿è¡Œæ­¤ç¨‹åºæ—¶ï¼Œä½ åº”è¯¥ä¼šçœ‹åˆ° \li{bob} å…ˆæœä¸œç§»åŠ¨ï¼Œç„¶åå‘åŒ—ç§»åŠ¨ï¼ŒåŒæ—¶åœ¨èº«åç•™ä¸‹ä¸¤æ¡çº¿æ®µ (line segment)ã€‚

%ğŸ% Now modify the program to draw a square.  Don't go on until
%ğŸ% you've got it working!

ç°åœ¨ä¿®æ”¹ç¨‹åºï¼Œç”»ä¸€ä¸ªæ­£æ–¹å½¢ã€‚åœ¨æ²¡æœ‰æˆåŠŸä¹‹å‰ï¼Œä¸è¦ç»§ç»­å¾€ä¸‹çœ‹ã€‚


%\newpage

%ğŸ% \section{Simple repetition  |  ç®€å•é‡å¤}
\section{ç®€å•é‡å¤}
\label{repetition}
\index{repetition}  
\index{é‡å¤}

%ğŸ% Chances are you wrote something like this:

å¾ˆæœ‰å¯èƒ½ä½ åˆšæ‰å†™äº†åƒä¸‹é¢è¿™æ ·çš„ä¸€ä¸ªç¨‹åºï¼š

\begin{lstlisting}
bob.fd(100)
bob.lt(90)

bob.fd(100)
bob.lt(90)

bob.fd(100)
bob.lt(90)

bob.fd(100)
\end{lstlisting}

%ğŸ% %
%ğŸ% We can do the same thing more concisely with a {\tt for} statement.
%ğŸ% Add this example to {\tt mypolygon.py} and run it again:

æˆ‘ä»¬å¯ä»¥åˆ©ç”¨ä¸€ä¸ª \li{for} è¯­å¥ï¼Œä»¥æ›´ç®€æ´çš„ä»£ç æ¥åšç›¸åŒçš„äº‹æƒ…ã€‚
å°†ä¸‹é¢çš„ç¤ºä¾‹ä»£ç åŠ å…¥ \li{mypolygon.py} ï¼Œå¹¶é‡æ–°è¿è¡Œï¼š
\index{for loop}  \index{loop!for}  \index{statement!for}

\begin{lstlisting}
for i in range(4):
    print('Hello!')
\end{lstlisting}

%ğŸ% %
%ğŸ% You should see something like this:

ä½ ä¼šçœ‹åˆ°ä»¥ä¸‹è¾“å‡ºï¼š

\begin{lstlisting}
Hello!
Hello!
Hello!
Hello!
\end{lstlisting}

%ğŸ% %
%ğŸ% This is the simplest use of the {\tt for} statement; we will see
%ğŸ% more later.  But that should be enough to let you rewrite your
%ğŸ% square-drawing program.  Don't go on until you do.

è¿™æ˜¯ \li{for} è¯­å¥æœ€ç®€å•çš„ç”¨æ³•ï¼›åé¢æˆ‘ä»¬ä¼šä»‹ç»æ›´å¤šçš„ç”¨æ³•ã€‚
ä½†æ˜¯è¿™å¯¹äºè®©ä½ é‡å†™ç”»æ­£æ–¹å½¢çš„ç¨‹åºå·²ç»è¶³å¤Ÿäº†ã€‚ å¦‚æœæ²¡æœ‰å®Œæˆï¼Œè¯·ä¸è¦å¾€ä¸‹çœ‹ã€‚

%ğŸ% Here is a {\tt for} statement that draws a square:

ä¸‹é¢æ˜¯ä¸€ä¸ªç”»æ­£æ–¹å½¢çš„ \li{for} è¯­å¥ï¼š

\begin{lstlisting}
for i in range(4):
    bob.fd(100)
    bob.lt(90)
\end{lstlisting}

%ğŸ% %
%ğŸ% The syntax of a {\tt for} statement is similar to a function
%ğŸ% definition.  It has a header that ends with a colon and an indented
%ğŸ% body.  The body can contain any number of statements.

forè¯­å¥çš„è¯­æ³•å’Œå‡½æ•°å®šä¹‰ç±»ä¼¼ã€‚
å®ƒæœ‰ä¸€ä¸ªä»¥å†’å·ç»“å°¾çš„è¯­å¥å¤´ (header) ä»¥åŠä¸€ä¸ªç¼©è¿›çš„è¯­å¥ä½“ (body)ã€‚
è¯­å¥ä½“å¯ä»¥åŒ…å«ä»»æ„æ¡è¯­å¥ã€‚

%ğŸ% A {\tt for} statement is also called a {\bf loop} because
%ğŸ% the flow of execution runs through the body and then loops back
%ğŸ% to the top.  In this case, it runs the body four times.
\index{loop}

\li{for} è¯­å¥æœ‰æ—¶ä¹Ÿè¢«ç§°ä¸º \emph{å¾ªç¯} (loop) ï¼Œ 
å› ä¸ºæ‰§è¡Œæµç¨‹ä¼šè´¯ç©¿æ•´ä¸ªè¯­å¥ä½“ï¼Œç„¶åå†å¾ªç¯å›é¡¶éƒ¨ã€‚  

åœ¨æ­¤ä¾‹ä¸­ï¼Œå®ƒå°†è¿è¡Œè¯­å¥ä½“å››æ¬¡ã€‚


%ğŸ% This version is actually a little different from the previous
%ğŸ% square-drawing code because it makes another turn after
%ğŸ% drawing the last side of the square.  The extra turn takes
%ğŸ% more time, but it simplifies the code if we do the same thing
%ğŸ% every time through the loop.  This version also has the effect
%ğŸ% of leaving the turtle back in the starting position, facing in
%ğŸ% the starting direction.

è¿™ä¸ªç‰ˆæœ¬äº‹å®ä¸Šå’Œå‰é¢ç”»æ­£æ–¹å½¢çš„ä»£ç æœ‰æ‰€ä¸åŒï¼Œ å› ä¸ºå®ƒåœ¨ç”»å®Œæ­£æ–¹å½¢çš„æœ€åä¸€æ¡è¾¹åï¼Œ 
åˆå¤šè½¬äº†ä¸€ä¸‹ã€‚  
è¿™ä¸ªé¢å¤–çš„è½¬åŠ¨å¤šèŠ±äº†äº›æ—¶é—´ï¼Œ
ä½†æ˜¯å¦‚æœæˆ‘ä»¬æ¯æ¬¡éƒ½é€šè¿‡å¾ªç¯æ¥åšè¿™ä»¶äº‹æƒ…ï¼Œ è¿™æ ·åè€Œæ˜¯ç®€åŒ–äº†ä»£ç ã€‚  
è¿™ä¸ªç‰ˆæœ¬è¿˜è®©æµ·é¾Ÿå›åˆ°äº†åˆå§‹ä½ç½®ï¼Œ æœå‘ä¹Ÿä¸å‡ºå‘æ—¶ä¸€è‡´ã€‚  



%ğŸ% \section{Exercises  |  ç»ƒä¹ }
\section{ç»ƒä¹ }

%ğŸ% The following is a series of exercises using TurtleWorld.  They
%ğŸ% are meant to be fun, but they have a point, too.  While you are
%ğŸ% working on them, think about what the point is.

ä¸‹é¢æ˜¯ä¸€ç³»åˆ—å­¦ä¹ ä½¿ç”¨ \li{Turtle} \footnote{è¯‘æ³¨ï¼šåŸæ–‡ä¸­ä½¿ç”¨çš„è¿˜æ˜¯ \li{TurtleWorld} ï¼Œåº”è¯¥æ˜¯ä½œè€…å¿˜äº†ä¿®æ”¹ã€‚} çš„ç»ƒä¹ ã€‚  
è¿™äº›ç»ƒä¹ å¾ˆæœ‰æ„æ€ï¼Œä½†å®ƒä»¬çš„è®¾è®¡æ˜¯æœ‰é’ˆå¯¹æ€§ã€‚
åšè¿™äº›ç»ƒä¹ çš„æ—¶å€™ï¼Œå¯ä»¥æ€è€ƒä¸€ä¸‹å®ƒä»¬çš„ç›®çš„æ˜¯ä»€ä¹ˆã€‚

%ğŸ% The following sections have solutions to the exercises, so
%ğŸ% don't look until you have finished (or at least tried).

åé¢å‡ èŠ‚æ˜¯ä¸­ä»‹ç»äº†è¿™äº›ç»ƒä¹ çš„ç­”æ¡ˆï¼Œå› æ­¤å¦‚æœä½ è¿˜æ²¡å®Œæˆï¼ˆæˆ–è€…è‡³å°‘è¯•è¿‡ï¼‰ï¼Œè¯·ä¸è¦çœ‹ç­”æ¡ˆã€‚

%ğŸ% \begin{enumerate}
%ğŸ% 
%ğŸ% \item Write a function called {\tt square} that takes a parameter
%ğŸ% named {\tt t}, which is a turtle.  It should use the turtle to draw
%ğŸ% a square.
%ğŸ% 
%ğŸ% Write a function call that passes {\tt bob} as an argument to
%ğŸ% {\tt square}, and then run the program again.
%ğŸ% 
%ğŸ% \item Add another parameter, named {\tt length}, to {\tt square}.
%ğŸ% Modify the body so length of the sides is {\tt length}, and then
%ğŸ% modify the function call to provide a second argument.  Run the
%ğŸ% program again.  Test your program with a range of values for {\tt
%ğŸ% length}.
%ğŸ% 
%ğŸ% \item Make a copy of {\tt square} and change the name to {\tt
%ğŸ%   polygon}.  Add another parameter named {\tt n} and modify the body
%ğŸ%   so it draws an n-sided regular polygon.  Hint: The exterior angles
%ğŸ%   of an n-sided regular polygon are $360/n$ degrees.  \index{polygon
%ğŸ%     function} \index{function!polygon}
%ğŸ% 
%ğŸ% \item Write a function called {\tt circle} that takes a turtle,
%ğŸ% {\tt t}, and radius, {\tt r}, as parameters and that draws an
%ğŸ% approximate circle by calling {\tt polygon} with an appropriate
%ğŸ% length and number of sides.  Test your function with a range of values
%ğŸ% of {\tt r}.  \index{circle function} \index{function!circle}
%ğŸ% 
%ğŸ% Hint: figure out the circumference of the circle and make sure that
%ğŸ% {\tt length * n = circumference}.
%ğŸ% 
%ğŸ% \item Make a more general version of {\tt circle} called {\tt arc}
%ğŸ% that takes an additional parameter {\tt angle}, which determines
%ğŸ% what fraction of a circle to draw.  {\tt angle} is in units of
%ğŸ% degrees, so when {\tt angle=360}, {\tt arc} should draw a complete
%ğŸ% circle.
%ğŸ% \index{arc function}
%ğŸ% \index{function!arc}
%ğŸ% 
%ğŸ% \end{enumerate}

\begin{enumerate}

\item å†™ä¸€ä¸ªåä¸º \li{square} çš„å‡½æ•°ï¼Œæ¥å—ä¸€ä¸ªåä¸º \li{t} çš„å½¢å‚ï¼Œ \li {t} æ˜¯ä¸€ä¸ªæµ·é¾Ÿã€‚ è¿™ä¸ªå‡½æ•°åº”ç”¨è¿™åªæµ·é¾Ÿç”»ä¸€ä¸ªæ­£æ–¹å½¢ã€‚

å†™ä¸€ä¸ªå‡½æ•°è°ƒç”¨ï¼Œå°† \li{bob} ä½œä¸ºå®å‚ä¼ ç»™ \li{square} ï¼Œç„¶åå†é‡æ–°è¿è¡Œç¨‹åºã€‚

\item ç»™ \li{square} å¢åŠ å¦ä¸€ä¸ªåä¸º \li{length} çš„å½¢å‚ã€‚
 ä¿®æ”¹å‡½æ•°ä½“ï¼Œä½¿å¾—æ­£æ–¹å½¢è¾¹çš„é•¿åº¦æ˜¯ \li{length} ï¼Œç„¶åä¿®æ”¹å‡½æ•°è°ƒç”¨ï¼Œæä¾›ç¬¬äºŒä¸ªå®å‚ã€‚
 é‡æ–°è¿è¡Œç¨‹åºã€‚ç”¨ä¸€ç³»åˆ— \li{length} å€¼æµ‹è¯•ä½ çš„ç¨‹åºã€‚

\item å¤åˆ¶ \li{square} ï¼Œå¹¶å°†å‡½æ•°æ”¹åä¸º \li{polygon} ã€‚
   å¢åŠ å¦å¤–ä¸€ä¸ªåä¸º \li{n} çš„å½¢å‚å¹¶ä¿®æ”¹å‡½æ•°ä½“ï¼Œè®©å®ƒç”»ä¸€ä¸ªæ­£ n è¾¹å½¢ (n-sided regular polygon)ã€‚

æç¤ºï¼šæ­£nè¾¹å½¢çš„å¤–è§’æ˜¯ $360/n$ åº¦ã€‚

\item ç¼–å†™ä¸€ä¸ªåä¸º \li{circle} çš„å‡½æ•°ï¼Œå®ƒæ¥å—ä¸€ä¸ªæµ·é¾Ÿtå’ŒåŠå¾„rä½œä¸ºå½¢å‚ï¼Œ ç„¶åä»¥åˆé€‚çš„è¾¹é•¿å’Œè¾¹æ•°è°ƒç”¨ \li{polygon} ï¼Œç”»ä¸€ä¸ªè¿‘ä¼¼åœ†å½¢ã€‚ç”¨ä¸€ç³»åˆ—rå€¼æµ‹è¯•ä½ çš„å‡½æ•°ã€‚

æç¤ºï¼šç®—å‡ºåœ†çš„å‘¨é•¿ï¼Œå¹¶ç¡®ä¿ \li{length \* n = circumference} ã€‚

\item å®Œæˆä¸€ä¸ªæ›´æ³›åŒ– (general) çš„ \li{circle} å‡½æ•°ï¼Œç§°å…¶ä¸º \li{arc} ï¼Œæ¥å—ä¸€ä¸ªé¢å¤–çš„å‚æ•° \li{angle} ï¼Œ ç¡®å®šç”»å¤šå®Œæ•´çš„åœ†ã€‚ \li{angle} çš„å•ä½æ˜¯åº¦ï¼Œå› æ­¤å½“ \li{angle = 360} æ—¶ï¼Œ \li{arc} åº”è¯¥ç”»ä¸€ä¸ªå®Œæ•´çš„åœ†ã€‚

\index{arc function}  \index{function!arc}

\end{enumerate}


%ğŸ% \section{Encapsulation  |  å°è£…}
\section{å°è£…}

%ğŸ% The first exercise asks you to put your square-drawing code
%ğŸ% into a function definition and then call the function, passing
%ğŸ% the turtle as a parameter.  Here is a solution:

ç¬¬ä¸€ä¸ªç»ƒä¹ è¦æ±‚ä½ å°†ç”»æ­£æ–¹å½¢çš„ä»£ç æ”¾åˆ°ä¸€ä¸ªå‡½æ•°å®šä¹‰ä¸­,ç„¶åè°ƒç”¨è¯¥å‡½æ•°ï¼Œ
å°†æµ·é¾Ÿä½œä¸ºå½¢å‚ä¼ é€’ç»™å®ƒã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªè§£æ³•ï¼š

\begin{lstlisting}
def square(t):
    for i in range(4):
        t.fd(100)
        t.lt(90)

square(bob)
\end{lstlisting}

%ğŸ% %
%ğŸ% The innermost statements, {\tt fd} and {\tt lt} are indented twice to
%ğŸ% show that they are inside the {\tt for} loop, which is inside the
%ğŸ% function definition.  The next line, {\tt square(bob)}, is flush with
%ğŸ% the left margin, which indicates the end of both the {\tt for} loop
%ğŸ% and the function definition.

æœ€å†…å±‚çš„è¯­å¥ \li{fd} å’Œ \li{lt} è¢«ç¼©è¿›ä¸¤æ¬¡ï¼Œä»¥æ˜¾ç¤ºå®ƒä»¬å¤„åœ¨ \li{for} å¾ªç¯å†…ï¼Œ è€Œè¯¥å¾ªç¯åˆåœ¨å‡½æ•°å®šä¹‰å†…ã€‚ä¸‹ä¸€è¡Œ \li{square(bob)} å’Œå·¦è¾¹ç•Œï¼ˆleft marginï¼‰å¯¹é½ï¼Œ è¡¨ç¤º \li{for} å¾ªç¯å’Œå‡½æ•°å®šä¹‰ç»“æŸã€‚

%ğŸ% Inside the function, {\tt t} refers to the same turtle {\tt bob}, so
%ğŸ% {\tt t.lt(90)} has the same effect as {\tt bob.lt(90)}.  In that
%ğŸ% case, why not
%ğŸ% call the parameter {\tt bob}?  The idea is that {\tt t} can be any
%ğŸ% turtle, not just {\tt bob}, so you could create a second turtle and
%ğŸ% pass it as an argument to {\tt square}:

åœ¨å‡½æ•°å†…éƒ¨ï¼Œ \li{t} æŒ‡çš„æ˜¯åŒä¸€åªæµ·é¾Ÿ \li{bob} ï¼Œ æ‰€ä»¥ \li{t.lt(90)} å’Œ \li{bob.lt(90)} çš„æ•ˆæœç›¸åŒã€‚
é‚£ä¹ˆæ—¢ç„¶è¿™æ ·ï¼Œä¸ºä»€ä¹ˆä¸å°†å½¢å‚å‘½åä¸º \li{bob} å‘¢ï¼Ÿ å› ä¸º \li{t} å¯ä»¥æ˜¯ä»»ä½•æµ·é¾Ÿè€Œä¸ä»…ä»…æ˜¯ \li{bob} ï¼Œ
ä¹Ÿå°±æ˜¯è¯´ä½ å¯ä»¥åˆ›å»ºç¬¬äºŒåªæµ·é¾Ÿï¼Œå¹¶ä¸”å°†å®ƒä½œä¸ºå®å‚ä¼ é€’ç»™ \li{square} ï¼š

\begin{lstlisting}
alice = Turtle()
square(alice)
\end{lstlisting}

%ğŸ% %
%ğŸ% Wrapping a piece of code up in a function is called {\bf
%ğŸ% encapsulation}.  One of the benefits of encapsulation is that it
%ğŸ% attaches a name to the code, which serves as a kind of documentation.
%ğŸ% Another advantage is that if you re-use the code, it is more concise
%ğŸ% to call a function twice than to copy and paste the body!

å°†ä¸€éƒ¨åˆ†ä»£ç åŒ…è£…åœ¨å‡½æ•°é‡Œè¢«ç§°ä½œ \emph{å°è£…} (encapsulation) ã€‚
å°è£…çš„å¥½å¤„ä¹‹ä¸€ï¼Œä¸ºè¿™äº›ä»£ç èµ‹äºˆä¸€ä¸ªåå­—ï¼Œ
è¿™å……å½“äº†æŸç§æ–‡æ¡£è¯´æ˜ã€‚å¦ä¸€ä¸ªå¥½å¤„æ˜¯ï¼Œå¦‚æœä½ é‡å¤ä½¿ç”¨è¿™äº›ä»£ç ï¼Œ
è°ƒç”¨å‡½æ•°ä¸¤æ¬¡æ¯”æ‹·è´ç²˜è´´å‡½æ•°ä½“è¦æ›´åŠ ç®€æ´ï¼
\index{encapsulation}
\index{å°è£…}


%ğŸ% \section{Generalization  |  æ³›åŒ–}
\section{æ³›åŒ–}

%ğŸ% The next step is to add a {\tt length} parameter to {\tt square}.
%ğŸ% Here is a solution:

ä¸‹ä¸€ä¸ªç»ƒä¹ æ˜¯ç»™ \li{square} å¢åŠ ä¸€ä¸ª \li{length} å½¢å‚ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªè§£æ³•ï¼š

\begin{lstlisting}
def square(t, length):
    for i in range(4):
        t.fd(length)
        t.lt(90)

square(bob, 100)
\end{lstlisting}

%
%ğŸ% Adding a parameter to a function is called {\bf generalization}
%ğŸ% because it makes the function more general: in the previous
%ğŸ% version, the square is always the same size; in this version
%ğŸ% it can be any size.

ä¸ºå‡½æ•°å¢åŠ ä¸€ä¸ªå½¢å‚è¢«ç§°ä½œ \emph{æ³›åŒ–} (generalization) ï¼Œ
å› ä¸ºè¿™ä½¿å¾—å‡½æ•°æ›´é€šç”¨ï¼šåœ¨å‰é¢çš„ç‰ˆæœ¬ä¸­ï¼Œ
æ­£æ–¹å½¢çš„è¾¹é•¿æ€»æ˜¯ä¸€æ ·çš„ï¼›æ­¤ç‰ˆæœ¬ä¸­ï¼Œå®ƒå¯ä»¥æ˜¯ä»»æ„å¤§å°ã€‚
\index{generalization}
\index{æ³›åŒ–}

%ğŸ% The next step is also a generalization.  Instead of drawing
%ğŸ% squares, {\tt polygon} draws regular polygons with any number of
%ğŸ% sides.  Here is a solution:

ä¸‹ä¸€ä¸ªç»ƒä¹ ä¹Ÿæ˜¯æ³›åŒ–ã€‚æ³›åŒ–ä¹‹åä¸å†æ˜¯åªèƒ½ç”»ä¸€ä¸ªæ­£æ–¹å½¢ï¼Œ\li{polygon} å¯ä»¥ç”»ä»»æ„çš„æ­£å¤šè¾¹å½¢ã€‚ ä¸‹é¢æ˜¯ä¸€ä¸ªæ–¹æ¡ˆï¼š

\begin{lstlisting}
def polygon(t, n, length):
    angle = 360 / n
    for i in range(n):
        t.fd(length)
        t.lt(angle)

polygon(bob, 7, 70)
\end{lstlisting}

%ğŸ% %
%ğŸ% This example draws a 7-sided polygon with side length 70.

è¿™ä¸ªç¤ºä¾‹ä»£ç ç”»äº†ä¸€ä¸ªè¾¹é•¿ä¸º70çš„ä¸ƒè¾¹å½¢ã€‚

%ğŸ% If you are using Python 2, the value of {\tt angle} might be off
%ğŸ% because of integer division.  A simple solution is to compute
%ğŸ% {\tt angle = 360.0 / n}.  Because the numerator is a floating-point
%ğŸ% number, the result is floating point.

å¦‚æœä½ åœ¨ä½¿ç”¨Python 2ï¼Œ\li{angle} çš„å€¼å¯èƒ½ç”±äºæ•´å‹æ•°é™¤æ³• (integer division) å‡ºç°åå·®ã€‚ä¸€ä¸ªç®€å•çš„è§£å†³åŠæ³•æ˜¯è¿™æ ·è®¡ç®— \li{angle} ï¼š \li{angle = 360.0 / n} ã€‚å› ä¸ºåˆ†å­ (numerator) æ˜¯ä¸€ä¸ªæµ®ç‚¹æ•°ï¼Œæœ€ç»ˆçš„ç»“æœä¹Ÿä¼šæ˜¯ä¸€ä¸ªæµ®ç‚¹æ•°ã€‚
\index{Python 2}

%ğŸ% When a function has more than a few numeric arguments, it is easy to
%ğŸ% forget what they are, or what order they should be in.  In that case
%ğŸ% it is often a good idea to include the names of the parameters in the
%ğŸ% argument list:

å¦‚æœä¸€ä¸ªå‡½æ•°æœ‰å‡ ä¸ªæ•°å­—å®å‚ï¼Œå¾ˆå®¹æ˜“å¿˜è®°å®ƒä»¬æ˜¯ä»€ä¹ˆæˆ–è€…å®ƒä»¬çš„é¡ºåºã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œ
åœ¨å®å‚åˆ—è¡¨ä¸­åŠ å…¥å½¢å‚çš„åç§°æ˜¯é€šå¸¸æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„åŠæ³•ï¼š

\begin{lstlisting}
polygon(bob, n=7, length=70)
\end{lstlisting}

%ğŸ% %
%ğŸ% These are called {\bf keyword arguments} because they include
%ğŸ% the parameter names as ``keywords'' (not to be confused with
%ğŸ% Python keywords like {\tt while} and {\tt def}).

è¿™äº›è¢«ç§°ä½œ \emph{å…³é”®å­—å®å‚} (keyword arguments) ï¼Œ
å› ä¸ºå®ƒä»¬jåŠ ä¸Šäº†å½¢å‚åä½œä¸º ``å…³é”®å­—''ï¼ˆä¸è¦å’Œ Python çš„å…³é”®å­—ææ··äº†ï¼Œå¦‚ \li{while} å’Œ \li{def} ï¼‰ã€‚
\index{keyword argument}  \index{argument!keyword}

%ğŸ% This syntax makes the program more readable.  It is also a reminder
%ğŸ% about how arguments and parameters work: when you call a function, the
%ğŸ% arguments are assigned to the parameters.

è¿™ä¸€è¯­æ³•ä½¿å¾—ç¨‹åºçš„å¯è¯»æ€§æ›´å¼ºã€‚å®ƒä¹Ÿæé†’äº†æˆ‘ä»¬å®å‚å’Œå½¢å‚çš„å·¥ä½œæ–¹å¼ï¼š
å½“ä½ è°ƒç”¨å‡½æ•°æ—¶ï¼Œå®å‚è¢«èµ‹ç»™å½¢å‚ã€‚

%ğŸ% \section{Interface design  |  æ¥å£è®¾è®¡}
\section{æ¥å£è®¾è®¡}

%ğŸ% The next step is to write {\tt circle}, which takes a radius,
%ğŸ% {\tt r}, as a parameter.  Here is a simple solution that uses
%ğŸ% {\tt polygon} to draw a 50-sided polygon:

ä¸‹ä¸€ä¸ªç»ƒä¹ æ˜¯ç¼–å†™æ¥å—åŠå¾„rä½œä¸ºå½¢å‚çš„ \li{circle} å‡½æ•°ã€‚
ä¸‹é¢æ˜¯ä¸€ä¸ªä½¿ç”¨ \li{polygon} ç”»ä¸€ä¸ª50è¾¹å½¢çš„ç®€å•è§£æ³•ï¼š

\begin{lstlisting}
import math

def circle(t, r):
    circumference = 2 * math.pi * r
    n = 50
    length = circumference / n
    polygon(t, n, length)
\end{lstlisting}

%ğŸ% %
%ğŸ% The first line computes the circumference of a circle with radius
%ğŸ% {\tt r} using the formula $2 \pi r$.  Since we use {\tt math.pi}, we
%ğŸ% have to import {\tt math}.  By convention, {\tt import} statements
%ğŸ% are usually at the beginning of the script.

å‡½æ•°çš„ç¬¬ä¸€è¡Œé€šè¿‡åŠå¾„rè®¡ç®—åœ†çš„å‘¨é•¿ï¼Œå…¬å¼æ˜¯ $2 \pi r$ ã€‚
ç”±äºç”¨äº† \li{math.pi} ï¼Œæˆ‘ä»¬éœ€è¦å¯¼å…¥ \li{math} æ¨¡å—ã€‚
æŒ‰ç…§æƒ¯ä¾‹ï¼Œ\li{import} è¯­å¥é€šå¸¸ä½äºè„šæœ¬çš„å¼€å§‹ä½ç½®ã€‚

%ğŸ% {\tt n} is the number of line segments in our approximation of a circle,
%ğŸ% so {\tt length} is the length of each segment.  Thus, {\tt polygon}
%ğŸ% draws a 50-sides polygon that approximates a circle with radius {\tt r}.

\li{n} æ˜¯æˆ‘ä»¬çš„è¿‘ä¼¼åœ†ä¸­çº¿æ®µçš„æ¡æ•°ï¼Œ \li{length} æ˜¯æ¯ä¸€æ¡çº¿æ®µçš„é•¿åº¦ã€‚
è¿™æ · \li{polygon} ç”»å‡ºçš„å°±æ˜¯ä¸€ä¸ª50è¾¹å½¢ï¼Œè¿‘ä¼¼ä¸€ä¸ªåŠå¾„ä¸º \li{r} çš„åœ†ã€‚

%ğŸ% One limitation of this solution is that {\tt n} is a constant, which
%ğŸ% means that for very big circles, the line segments are too long, and
%ğŸ% for small circles, we waste time drawing very small segments.  One
%ğŸ% solution would be to generalize the function by taking {\tt n} as
%ğŸ% a parameter.  This would give the user (whoever calls {\tt circle})
%ğŸ% more control, but the interface would be less clean.

è¿™ç§è§£æ³•çš„ä¸€ä¸ªå±€é™åœ¨äºï¼Œ \li{n} æ˜¯ä¸€ä¸ªå¸¸é‡ï¼Œæ„å‘³ç€å¯¹äºéå¸¸å¤§çš„åœ†ï¼Œ
çº¿æ®µä¼šéå¸¸é•¿ï¼Œè€Œå¯¹äºå°åœ†ï¼Œæˆ‘ä»¬ä¼šæµªè´¹æ—¶é—´ç”»éå¸¸å°çš„çº¿æ®µã€‚
ä¸€ä¸ªè§£å†³æ–¹æ¡ˆæ˜¯å°†nä½œä¸ºå½¢å‚ï¼Œæ³›åŒ–å‡½æ•°ã€‚
è¿™å°†ç»™ç”¨æˆ·ï¼ˆè°ƒç”¨ \li{circle} çš„äººï¼‰æ›´å¤šçš„æŒæ§åŠ›ï¼Œ ä½†æ˜¯æ¥å£å°±ä¸é‚£ä¹ˆå¹²å‡€äº†ã€‚
\index{interface}
\index{æ¥å£}

%ğŸ% The {\bf interface} of a function is a summary of how it is used: what
%ğŸ% are the parameters?  What does the function do?  And what is the return
%ğŸ% value?  An interface is ``clean'' if it allows the caller to do
%ğŸ% what they want without dealing with unnecessary details.

å‡½æ•°çš„ \emph{æ¥å£} (interface) æ˜¯ä¸€ä»½å…³äºå¦‚ä½•ä½¿ç”¨è¯¥å‡½æ•°çš„æ€»ç»“ï¼š
å½¢å‚æ˜¯ä»€ä¹ˆï¼Ÿå‡½æ•°åšä»€ä¹ˆï¼Ÿè¿”å›å€¼æ˜¯ä»€ä¹ˆï¼Ÿ
å¦‚æœæ¥å£è®©è°ƒç”¨è€…é¿å…å¤„ç†ä¸å¿…è¦çš„ç»†èŠ‚ï¼Œç›´æ¥åšè‡ªå·±æƒ³åšçš„å¼ï¼Œé‚£ä¹ˆè¿™ä¸ªæ¥å£å°±æ˜¯``å¹²å‡€çš„''ã€‚

%ğŸ% In this example, {\tt r} belongs in the interface because it
%ğŸ% specifies the circle to be drawn.  {\tt n} is less appropriate
%ğŸ% because it pertains to the details of {\em how} the circle should
%ğŸ% be rendered.

åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œ \li{r} å±äºæ¥å£çš„ä¸€éƒ¨åˆ†ï¼Œå› ä¸ºå®ƒæŒ‡å®šäº†è¦ç”»å¤šå¤§çš„åœ†ã€‚
nå°±ä¸å¤ªåˆé€‚ï¼Œå› ä¸ºå®ƒæ˜¯å…³äº \emph{å¦‚ä½•} ç”»åœ†çš„ç»†èŠ‚ã€‚

%ğŸ% Rather than clutter up the interface, it is better
%ğŸ% to choose an appropriate value of {\tt n}
%ğŸ% depending on {\tt circumference}:

ä¸å…¶æŠŠæ¥å£å¼„ä¹±ï¼Œä¸å¦‚æ ¹æ®å‘¨é•¿ (circumference) é€‰æ‹©ä¸€ä¸ªåˆé€‚çš„\li{n}å€¼ï¼š

\begin{lstlisting}
def circle(t, r):
    circumference = 2 * math.pi * r
    n = int(circumference / 3) + 1
    length = circumference / n
    polygon(t, n, length)
\end{lstlisting}

%
%ğŸ% Now the number of segments is an integer near {\tt circumference/3},
%ğŸ% so the length of each segment is approximately 3, which is small
%ğŸ% enough that the circles look good, but big enough to be efficient,
%ğŸ% and acceptable for any size circle.

ç°åœ¨çº¿æ®µçš„æ•°é‡ï¼Œæ˜¯çº¦ä¸ºå‘¨é•¿ä¸‰åˆ†ä¹‹ä¸€çš„æ•´å‹æ•°ï¼Œ
æ‰€ä»¥æ¯æ¡çº¿æ®µçš„é•¿åº¦ï¼ˆå¤§æ¦‚ï¼‰æ˜¯3ï¼Œå°åˆ°è¶³ä»¥ä½¿åœ†çœ‹ä¸Šå»é€¼çœŸï¼Œ
åˆå¤§åˆ°æ•ˆç‡è¶³å¤Ÿé«˜ï¼Œå¯¹ä»»æ„å¤§å°çš„åœ†éƒ½èƒ½æ¥å—ã€‚

%ğŸ% \section{Refactoring  |  é‡æ„}
\section{é‡æ„}
\label{refactoring}
\index{refactoring}  \index{é‡æ„}

%ğŸ% When I wrote {\tt circle}, I was able to re-use {\tt polygon}
%ğŸ% because a many-sided polygon is a good approximation of a circle.
%ğŸ% But {\tt arc} is not as cooperative; we can't use {\tt polygon}
%ğŸ% or {\tt circle} to draw an arc.

å½“æˆ‘å†™ \li{circle} ç¨‹åºçš„æ—¶å€™ï¼Œæˆ‘èƒ½å¤Ÿå¤ç”¨ \li{polygon} ï¼Œ
å› ä¸ºä¸€ä¸ªå¤šè¾¹å½¢æ˜¯ä¸åœ†å½¢éå¸¸è¿‘ä¼¼ã€‚
ä½†æ˜¯ \li{arc} å°±ä¸é‚£ä¹ˆå®¹æ˜“å®ç°äº†ï¼›æˆ‘ä»¬ä¸èƒ½ä½¿ç”¨ \li{polygon} æˆ–è€… \li{circle} æ¥ç”»ä¸€ä¸ªå¼§ã€‚

%ğŸ% One alternative is to start with a copy
%ğŸ% of {\tt polygon} and transform it into {\tt arc}.  The result
%ğŸ% might look like this:

ä¸€ç§æ›¿ä»£æ–¹æ¡ˆæ˜¯ä»å¤åˆ¶ \li{polygon} å¼€å§‹ï¼Œ
ç„¶åå°†å®ƒè½¬åŒ–ä¸º \li{arc} ã€‚æœ€åçš„å‡½æ•°çœ‹ä¸Šå»å¯åƒè¿™æ ·ï¼š

\begin{lstlisting}
def arc(t, r, angle):
    arc_length = 2 * math.pi * r * angle / 360
    n = int(arc_length / 3) + 1
    step_length = arc_length / n
    step_angle = angle / n

    for i in range(n):
        t.fd(step_length)
        t.lt(step_angle)
\end{lstlisting}

%ğŸ% %
%ğŸ% The second half of this function looks like {\tt polygon}, but we
%ğŸ% can't re-use {\tt polygon} without changing the interface.  We could
%ğŸ% generalize {\tt polygon} to take an angle as a third argument,
%ğŸ% but then {\tt polygon} would no longer be an appropriate name!
%ğŸ% Instead, let's call the more general function {\tt polyline}:

è¯¥å‡½æ•°çš„ååŠéƒ¨åˆ†çœ‹ä¸Šå»å¾ˆåƒ \li{polygon} ï¼Œ
ä½†æ˜¯åœ¨ä¸æ”¹å˜æ¥å£çš„æ¡ä»¶ä¸‹ï¼Œæˆ‘ä»¬æ— æ³•å¤ç”¨ \li{polygon} ã€‚
æˆ‘ä»¬å¯ä»¥æ³›åŒ– \li{polygon} æ¥æ¥å—ä¸€ä¸ªè§’åº¦ä½œä¸ºç¬¬ä¸‰ä¸ªå®å‚ï¼Œ ä½†æ˜¯è¿™æ · \li{polygon} å°±ä¸å†æ˜¯ä¸€ä¸ªåˆé€‚çš„åå­—äº†ï¼ è®©æˆ‘ä»¬ç§°è¿™ä¸ªæ›´é€šç”¨çš„å‡½æ•°ä¸º \li{polyline} ï¼š

\begin{lstlisting}
def polyline(t, n, length, angle):
    for i in range(n):
        t.fd(length)
        t.lt(angle)
\end{lstlisting}

%ğŸ% %
%ğŸ% Now we can rewrite {\tt polygon} and {\tt arc} to use {\tt polyline}:

ç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ \li{polyline} é‡å†™ \li{polygon} å’Œ \li{arc} ï¼š

\begin{lstlisting}
def polygon(t, n, length):
    angle = 360.0 / n
    polyline(t, n, length, angle)

def arc(t, r, angle):
    arc_length = 2 * math.pi * r * angle / 360
    n = int(arc_length / 3) + 1
    step_length = arc_length / n
    step_angle = float(angle) / n
    polyline(t, n, step_length, step_angle)
\end{lstlisting}

%ğŸ% %
%ğŸ% Finally, we can rewrite {\tt circle} to use {\tt arc}:

æœ€åï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ \li{arc} é‡å†™ \li{circle} ï¼š

\begin{lstlisting}
def circle(t, r):
    arc(t, r, 360)
\end{lstlisting}

%ğŸ% %
%ğŸ% This process---rearranging a program to improve
%ğŸ% interfaces and facilitate code re-use---is called {\bf refactoring}.
%ğŸ% In this case, we noticed that there was similar code in {\tt arc} and
%ğŸ% {\tt polygon}, so we ``factored it out'' into {\tt polyline}.
\index{refactoring}
\index{é‡æ„}

é‡æ–°æ•´ç†ä¸€ä¸ªç¨‹åºä»¥æ”¹è¿›å‡½æ•°æ¥å£å’Œä¿ƒè¿›ä»£ç å¤ç”¨çš„è¿™ä¸ªè¿‡ç¨‹ï¼Œ
è¢«ç§°ä½œ \emph{é‡æ„} (refactoring) ã€‚
åœ¨æ­¤ä¾‹ä¸­ï¼Œæˆ‘ä»¬æ³¨æ„åˆ° \li{arc} å’Œ \li{polygon} ä¸­æœ‰ç›¸ä¼¼çš„ä»£ç ï¼Œ
å› æ­¤ï¼Œæˆ‘ä»¬â€œå°†å®ƒåˆ†è§£å‡ºæ¥â€ï¼ˆfactor it outï¼‰ï¼Œæ”¾å…¥ \li{polyline} å‡½æ•°ã€‚

%ğŸ% If we had planned ahead, we might have written {\tt polyline} first
%ğŸ% and avoided refactoring, but often you don't know enough at the
%ğŸ% beginning of a project to design all the interfaces.  Once you start
%ğŸ% coding, you understand the problem better.  Sometimes refactoring is a
%ğŸ% sign that you have learned something.

å¦‚æœæˆ‘ä»¬æå‰å·²ç»è®¡åˆ’å¥½äº†ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šé¦–å…ˆå†™ \li{polyline} å‡½æ•°ï¼Œé¿å…é‡æ„ï¼Œ
ä½†æ˜¯åœ¨ä¸€ä¸ªé¡¹ç›®å¼€å§‹çš„æ—¶å€™ï¼Œä½ å¸¸å¸¸å¹¶ä¸çŸ¥é“é‚£ä¹ˆå¤šï¼Œä¸èƒ½è®¾è®¡å¥½å…¨éƒ¨çš„æ¥å£ã€‚
ä¸€æ—¦ä½ å¼€å§‹ç¼–ç åï¼Œä½ æ‰èƒ½æ›´å¥½åœ°ç†è§£é—®é¢˜ã€‚
æœ‰æ—¶é‡æ„æ˜¯ä¸€ä¸ªè¯´æ˜ä½ å·²ç»å­¦åˆ°æŸäº›ä¸œè¥¿çš„é¢„å…†ã€‚


%ğŸ% \section{A development plan  |  å¼€å‘æ–¹æ¡ˆ}
\section{å¼€å‘æ–¹æ¡ˆ}

\index{development plan!encapsulation and generalization}
\index{å¼€å‘æ–¹æ¡ˆ!å°è£…å’Œæ³›åŒ–}

%ğŸ% A {\bf development plan} is a process for writing programs.  The
%ğŸ% process we used in this case study is ``encapsulation and
%ğŸ% generalization''.  The steps of this process are:

\emph{å¼€å‘è®¡åˆ’} (development plan) æ˜¯ä¸€ç§ç¼–å†™ç¨‹åºçš„è¿‡ç¨‹ã€‚
æ­¤ä¾‹ä¸­æˆ‘ä»¬ä½¿ç”¨çš„è¿‡ç¨‹æ˜¯ ``å°è£…å’Œæ³›åŒ–''ã€‚ è¿™ä¸ªè¿‡ç¨‹çš„å…·ä½“æ­¥éª¤æ˜¯ï¼š

å› æ­¤ï¼Œæˆ‘ä»¬ ``å°†å®ƒåˆ†è§£å‡ºæ¥'' (factor it out)ï¼Œæ”¾å…¥ \li{polyline} å‡½æ•°ã€‚

%ğŸ% \begin{enumerate}
%ğŸ% 
%ğŸ% \item Start by writing a small program with no function definitions.
%ğŸ% 
%ğŸ% \item Once you get the program working, identify a coherent piece of
%ğŸ%   it, encapsulate the piece in a function and give it a name.
%ğŸ% 
%ğŸ% \item Generalize the function by adding appropriate parameters.
%ğŸ% 
%ğŸ% \item Repeat steps 1--3 until you have a set of working functions.
%ğŸ% Copy and paste working code to avoid retyping (and re-debugging).
%ğŸ% 
%ğŸ% \item Look for opportunities to improve the program by refactoring.
%ğŸ% For example, if you have similar code in several places, consider
%ğŸ% factoring it into an appropriately general function.
%ğŸ% 
%ğŸ% \end{enumerate}

\begin{enumerate}

\item ä»å†™ä¸€ä¸ªæ²¡æœ‰å‡½æ•°å®šä¹‰çš„å°ç¨‹åºå¼€å§‹ã€‚

\item ä¸€æ—¦è¯¥ç¨‹åºè¿è¡Œæ­£å¸¸ï¼Œæ‰¾å‡ºå…¶ä¸­ç›¸å…³æ€§å¼ºçš„éƒ¨åˆ†ï¼Œå°†å®ƒä»¬å°è£…è¿›ä¸€ä¸ªå‡½æ•°å¹¶ç»™å®ƒä¸€ä¸ªåå­—ã€‚

\item é€šè¿‡å¢åŠ é€‚å½“çš„å½¢å‚ï¼Œæ³›åŒ–è¯¥å‡½æ•°ã€‚

\item é‡å¤1â€“3æ­¥ï¼Œç›´åˆ°ä½ æœ‰ä¸€äº›å¯æ­£å¸¸è¿è¡Œçš„å‡½æ•°ã€‚
   å¤åˆ¶ç²˜è´´æœ‰ç”¨çš„ä»£ç ï¼Œé¿å…é‡å¤è¾“å…¥ï¼ˆå’Œé‡æ–°è°ƒè¯•ï¼‰ã€‚

\item å¯»æ‰¾æœºä¼šé€šè¿‡é‡æ„æ”¹è¿›ç¨‹åºã€‚
   ä¾‹å¦‚ï¼Œå¦‚æœåœ¨å¤šä¸ªåœ°æ–¹æœ‰ç›¸ä¼¼çš„ä»£ç ï¼Œè€ƒè™‘å°†å®ƒåˆ†è§£åˆ°ä¸€ä¸ªåˆé€‚çš„é€šç”¨å‡½æ•°ä¸­ã€‚

\end{enumerate}

%ğŸ% This process has some drawbacks---we will see alternatives later---but
%ğŸ% it can be useful if you don't know ahead of time how to divide the
%ğŸ% program into functions.  This approach lets you design as you go
%ğŸ% along.

è¿™ä¸ªè¿‡ç¨‹ä¹Ÿæœ‰ä¸€äº›ç¼ºç‚¹ã€‚åé¢æˆ‘ä»¬å°†ä»‹ç»å…¶ä»–æ›¿ä»£æ–¹æ¡ˆï¼Œ
ä½†æ˜¯å¦‚æœä½ äº‹å…ˆä¸çŸ¥é“å¦‚ä½•å°†ç¨‹åºåˆ†è§£ä¸ºå‡½æ•°ï¼Œè¿™æ˜¯ä¸ªå¾ˆæœ‰ç”¨åŠæ³•ã€‚
è¯¥æ–¹æ³•å¯ä»¥è®©ä½ ä¸€è¾¹ç¼–ç¨‹ï¼Œä¸€è¾¹è®¾è®¡ã€‚

%ğŸ% \section{docstring  |  æ–‡æ¡£å­—ç¬¦ä¸²}
\section{æ–‡æ¡£å­—ç¬¦ä¸²}
\label{docstring}
\index{docstring}

%ğŸ% A {\bf docstring} is a string at the beginning of a function that
%ğŸ% explains the interface (``doc'' is short for ``documentation'').  Here
%ğŸ% is an example:

\emph{æ–‡æ¡£å­—ç¬¦ä¸²} (docstring) æ˜¯ä½äºå‡½æ•°å¼€å§‹ä½ç½®çš„ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œ
è§£é‡Šäº†å‡½æ•°çš„æ¥å£ï¼ˆ``doc'' æ˜¯ ``documentation'' çš„ç¼©å†™ï¼‰ã€‚ ä¸‹é¢æ˜¯ä¸€ä¸ªä¾‹å­ï¼š

\begin{lstlisting}
def polyline(t, n, length, angle):
    """Draws n line segments with the given length and
    angle (in degrees) between them.  t is a turtle.
    """
    for i in range(n):
        t.fd(length)
        t.lt(angle)
\end{lstlisting}

%ğŸ% %
%ğŸ% By convention, all docstrings are triple-quoted strings, also known
%ğŸ% as multiline strings because the triple quotes allow the string
%ğŸ% to span more than one line.

æŒ‰ç…§æƒ¯ä¾‹ï¼Œæ‰€æœ‰çš„æ–‡æ¡£å­—ç¬¦ä¸²éƒ½æ˜¯ä¸‰é‡å¼•å·ï¼ˆtriple-quotedï¼‰å­—ç¬¦ä¸²ï¼Œä¹Ÿè¢«ç§°ä¸ºå¤šè¡Œå­—ç¬¦ä¸²ï¼Œ
å› ä¸ºä¸‰é‡å¼•å·å…è®¸å­—ç¬¦ä¸²è¶…è¿‡ä¸€è¡Œã€‚
\index{quotation mark}  \index{triple-quoted string}
\index{string!triple-quoted}  \index{multiline string}
\index{string!multiline}

%ğŸ% It is terse, but it contains the essential information
%ğŸ% someone would need to use this function.  It explains concisely what
%ğŸ% the function does (without getting into the details of how it does
%ğŸ% it).  It explains what effect each parameter has on the behavior of
%ğŸ% the function and what type each parameter should be (if it is not
%ğŸ% obvious).

å®ƒå¾ˆç®€è¦\footnote{terse}ï¼Œä½†æ˜¯åŒ…æ‹¬äº†ä»–äººä½¿ç”¨æ­¤å‡½æ•°æ—¶éœ€è¦äº†è§£çš„å…³é”®ä¿¡æ¯ã€‚
å®ƒæ‰¼è¦åœ°è¯´æ˜è¯¥å‡½æ•°åšä»€ä¹ˆï¼ˆä¸ä»‹ç»èƒŒåçš„å…·ä½“ç»†èŠ‚ï¼‰ã€‚
å®ƒè§£é‡Šäº†æ¯ä¸ªå½¢å‚å¯¹å‡½æ•°çš„è¡Œä¸ºæœ‰ä»€ä¹ˆå½±å“ï¼Œä»¥åŠæ¯ä¸ªå½¢å‚åº”æœ‰çš„ç±»å‹
ï¼ˆå¦‚æœå®ƒä¸æ˜æ˜¾çš„è¯ï¼‰ã€‚

%ğŸ% Writing this kind of documentation is an important part of interface
%ğŸ% design.  A well-designed interface should be simple to explain;
%ğŸ% if you have a hard time explaining one of your functions,
%ğŸ% maybe the interface could be improved.

å†™è¿™ç§æ–‡æ¡£æ˜¯æ¥å£è®¾è®¡ä¸­å¾ˆé‡è¦çš„ä¸€éƒ¨åˆ†ã€‚ ä¸€ä¸ªè®¾è®¡è‰¯å¥½çš„æ¥å£åº”è¯¥å¾ˆå®¹æ˜“è§£é‡Šï¼Œ
å¦‚æœä½ å¾ˆéš¾è§£é‡Šä½ çš„æŸä¸ªå‡½æ•°ï¼Œé‚£ä¹ˆä½ çš„æ¥å£ä¹Ÿè®¸è¿˜æœ‰æ”¹è¿›ç©ºé—´ã€‚


%ğŸ% \section{Debugging  |  è°ƒè¯•}
\section{è°ƒè¯•}
\index{debugging}  \index{interface}
\index{è°ƒè¯•}  \index{æ¥å£}

%ğŸ% An interface is like a contract between a function and a caller.
%ğŸ% The caller agrees to provide certain parameters and the function
%ğŸ% agrees to do certain work.

æ¥å£å°±åƒæ˜¯å‡½æ•°å’Œè°ƒç”¨è€…ä¹‹é—´çš„åˆåŒã€‚
è°ƒç”¨è€…åŒæ„æä¾›åˆé€‚çš„å‚æ•°ï¼Œå‡½æ•°åŒæ„å®Œæˆç›¸åº”çš„å·¥ä½œã€‚

%ğŸ% For example, {\tt polyline} requires four arguments: {\tt t} has to be
%ğŸ% a Turtle; {\tt n} has to be an
%ğŸ% integer; {\tt length} should be a positive number; and {\tt
%ğŸ%   angle} has to be a number, which is understood to be in degrees.

ä¾‹å¦‚ï¼Œ \li{polyline} å‡½æ•°éœ€è¦4ä¸ªå®å‚ï¼š \li{t} å¿…é¡»æ˜¯ä¸€ä¸ª \li{Turtle} ï¼›
\li{n} å¿…é¡»æ˜¯ä¸€ä¸ªæ•´å‹æ•°ï¼› \li{length} åº”è¯¥æ˜¯ä¸€ä¸ªæ­£æ•°ï¼›
\li{angle} å¿…é¡»æ˜¯ä¸€ä¸ªæ•°ï¼Œå•ä½æ˜¯åº¦æ•°ã€‚

%ğŸ% These requirements are called {\bf preconditions} because they
%ğŸ% are supposed to be true before the function starts executing.
%ğŸ% Conversely, conditions at the end of the function are
%ğŸ% {\bf postconditions}.  Postconditions include the intended
%ğŸ% effect of the function (like drawing line segments) and any
%ğŸ% side effects (like moving the Turtle or making other changes).

è¿™äº›è¦æ±‚è¢«ç§°ä½œ \emph{å…ˆå†³æ¡ä»¶} (preconditions) ï¼Œ
å› ä¸ºå®ƒä»¬åº”å½“åœ¨å‡½æ•°å¼€å§‹æ‰§è¡Œä¹‹å‰æˆç«‹ï¼ˆtrueï¼‰ã€‚  
ç›¸åï¼Œ å‡½æ•°ç»“æŸæ—¶çš„æ¡ä»¶æ˜¯ \emph{åç½®æ¡ä»¶} (postconditions) ã€‚  
åç½®æ¡ä»¶åŒ…æ‹¬å‡½æ•°é¢„æœŸçš„æ•ˆæœï¼ˆå¦‚ç”»çº¿æ®µï¼‰ä»¥åŠä»»ä½•å…¶ä»–é™„å¸¦æ•ˆæœ
ï¼ˆå¦‚ç§»åŠ¨ \li{Turtle} æˆ–è€…åšå…¶å®ƒæ”¹å˜ï¼‰ã€‚
\index{precondition}  \index{postcondition}
\index{å…ˆå†³æ¡ä»¶}  \index{åç½®æ¡ä»¶}

%ğŸ% Preconditions are the responsibility of the caller.  If the caller
%ğŸ% violates a (properly documented!) precondition and the function
%ğŸ% doesn't work correctly, the bug is in the caller, not the function.

å…ˆå†³æ¡ä»¶ç”±è°ƒç”¨è€…è´Ÿè´£æ»¡è¶³ã€‚å¦‚æœè°ƒç”¨è€…è¿åä¸€ä¸ªï¼ˆå·²ç»å……åˆ†è®°å½•æ–‡æ¡£çš„ï¼ï¼‰
å…ˆå†³æ¡ä»¶ï¼Œå¯¼è‡´å‡½æ•°æ²¡æœ‰æ­£ç¡®å·¥ä½œï¼Œåˆ™æ•…éšœ (bug) å‡ºç°åœ¨è°ƒç”¨è€…ä¸€æ–¹ï¼Œè€Œä¸æ˜¯å‡½æ•°ã€‚

%ğŸ% If the preconditions are satisfied and the postconditions are
%ğŸ% not, the bug is in the function.  If your pre- and postconditions
%ğŸ% are clear, they can help with debugging.

å¦‚æœæ»¡è¶³äº†å…ˆå†³æ¡ä»¶ï¼Œæ²¡æœ‰æ»¡è¶³åç½®æ¡ä»¶ï¼Œæ•…éšœå°±åœ¨å‡½æ•°ä¸€æ–¹ã€‚å¦‚æœä½ çš„å…ˆå†³æ¡ä»¶å’Œåç½®æ¡ä»¶éƒ½å¾ˆæ¸…æ¥šï¼Œå°†æœ‰åŠ©äºè°ƒè¯•ã€‚


%ğŸ% \section{Glossary  |  æœ¯è¯­è¡¨}
\section{æœ¯è¯­è¡¨}

\begin{description}

%ğŸ% \item[method:] A function that is associated with an object and called
%ğŸ% using dot notation.
\index{method}

\item[æ–¹æ³• (method)ï¼š]
    ä¸å¯¹è±¡ç›¸å…³è”çš„å‡½æ•°ï¼Œå¹¶ä½¿ç”¨ç‚¹æ ‡è®°æ³• (dot notation)è°ƒç”¨ã€‚

%ğŸ% \item[loop:] A part of a program that can run repeatedly.
\index{loop}

\item[å¾ªç¯ (loop)ï¼š]
    ç¨‹åºä¸­èƒ½å¤Ÿé‡å¤æ‰§è¡Œçš„é‚£éƒ¨åˆ†ä»£ç ã€‚

%ğŸ% \item[encapsulation:] The process of transforming a sequence of
%ğŸ% statements into a function definition.
\index{encapsulation}

\item[å°è£… (encapsulation)ï¼š]
    å°†ä¸€ä¸ªè¯­å¥åºåˆ—è½¬æ¢æˆå‡½æ•°å®šä¹‰çš„è¿‡ç¨‹ã€‚

%ğŸ% \item[generalization:] The process of replacing something
%ğŸ% unnecessarily specific (like a number) with something appropriately
%ğŸ% general (like a variable or parameter).
\index{generalization}

\item[æ³›åŒ– (generalization)ï¼š]
    ä½¿ç”¨æŸç§å¯ä»¥ç®—æ˜¯æ¯”è¾ƒé€šç”¨çš„ä¸œè¥¿ (åƒå˜é‡å’Œå½¢å‚)ï¼Œæ›¿ä»£æŸäº›æ²¡å¿…è¦é‚£ä¹ˆå…·ä½“çš„ä¸œè¥¿ (åƒä¸€ä¸ªæ•°å­—)çš„è¿‡ç¨‹ã€‚

%ğŸ% \item[keyword argument:] An argument that includes the name of
%ğŸ% the parameter as a ``keyword''.
\index{keyword argument}
\index{argument!keyword}

\item[å…³é”®å­—å®å‚ (keyword argument)ï¼š]
    åŒ…æ‹¬äº†å½¢å‚åç§°ä½œä¸ºâ€œå…³é”®å­—â€çš„å®å‚ã€‚

%ğŸ% \item[interface:] A description of how to use a function, including
%ğŸ% the name and descriptions of the arguments and return value.
\index{interface}

\item[æ¥å£ (interface)ï¼š]
    å¯¹å¦‚ä½•ä½¿ç”¨ä¸€ä¸ªå‡½æ•°çš„æè¿°ï¼ŒåŒ…æ‹¬å‡½æ•°åã€å‚æ•°è¯´æ˜å’Œè¿”å›å€¼ã€‚

%ğŸ% \item[refactoring:] The process of modifying a working program to
%ğŸ%   improve function interfaces and other qualities of the code.
\index{refactoring}

\item[é‡æ„ (refactoring)ï¼š]
    ä¿®æ”¹ä¸€ä¸ªæ­£å¸¸è¿è¡Œçš„å‡½æ•°ï¼Œæ”¹å–„å‡½æ•°æ¥å£åŠå…¶ä»–æ–¹é¢ä»£ç è´¨é‡çš„è¿‡ç¨‹ã€‚

%ğŸ% \item[development plan:] A process for writing programs.
\index{development plan}

\item[å¼€å‘è®¡åˆ’ (development plan)ï¼š]
    ç¼–å†™ç¨‹åºçš„ä¸€ç§è¿‡ç¨‹ã€‚

%ğŸ% \item[docstring:] A string that appears at the top of a function
%ğŸ%   definition to document the function's interface.
\index{docstring}

\item[æ–‡æ¡£å­—ç¬¦ä¸² (docstring)ï¼š]
    å‡ºç°åœ¨å‡½æ•°å®šä¹‰é¡¶éƒ¨çš„ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œç”¨äºè®°å½•å‡½æ•°çš„æ¥å£ã€‚

%ğŸ% \item[precondition:] A requirement that should be satisfied by
%ğŸ% the caller before a function starts.
\index{precondition}

\item[å…ˆå†³æ¡ä»¶ (preconditions)ï¼š]
    åœ¨å‡½æ•°è¿è¡Œä¹‹å‰ï¼Œè°ƒç”¨è€…åº”è¯¥æ»¡è¶³çš„è¦æ±‚ã€‚

%ğŸ% \item[postcondition:] A requirement that should be satisfied by
%ğŸ% the function before it ends.
\index{precondition}

\item[åç½®æ¡ä»¶ (postconditions)ï¼š]
    å‡½æ•°ç»ˆæ­¢ä¹‹å‰åº”è¯¥æ»¡è¶³çš„æ¡ä»¶ã€‚

\end{description}


%ğŸ% \section{Exercises  |  ç»ƒä¹ }
\section{ç»ƒä¹ }

\begin{exercise}

%ğŸ% Download the code in this chapter from
%ğŸ% \url{http://thinkpython2.com/code/polygon.py}.

å¯ä» \href{http://thinkpython2.com/code/polygon.py}{æ­¤å¤„}ä¸‹è½½æœ¬ç« çš„ä»£ç ã€‚

%ğŸ% \begin{enumerate}
%ğŸ% 
%ğŸ% \item Draw a stack diagram that shows the state of the program
%ğŸ% while executing {\tt circle(bob, radius)}.  You can do the
%ğŸ% arithmetic by hand or add {\tt print} statements to the code.
%ğŸ% \index{stack diagram}
%ğŸ% 
%ğŸ% \item The version of {\tt arc} in Section~\ref{refactoring} is not
%ğŸ% very accurate because the linear approximation of the
%ğŸ% circle is always outside the true circle.  As a result,
%ğŸ% the Turtle ends up a few pixels away from the correct
%ğŸ% destination.  My solution shows a way to reduce
%ğŸ% the effect of this error.  Read the code and see if it makes
%ğŸ% sense to you.  If you draw a diagram, you might see how it works.
%ğŸ% 
%ğŸ% \end{enumerate}

\begin{enumerate}

\item ç”»ä¸€ä¸ªæ‰§è¡Œ {\em \li{circle(bob, radius)}} æ—¶çš„å †æ ˆå›¾ {\em (stack diagram) } ï¼Œè¯´æ˜ç¨‹åºçš„å„ä¸ªçŠ¶æ€ã€‚ ä½ å¯ä»¥æ‰‹åŠ¨è¿›è¡Œè®¡ç®—ï¼Œä¹Ÿå¯ä»¥åœ¨ä»£ç ä¸­åŠ å…¥æ‰“å°è¯­å¥ã€‚

\item {\em \ref{refactoring}}~èŠ‚ ä¸­ç»™å‡ºçš„ {\em \li{arc} } å‡½æ•°ç‰ˆæœ¬å¹¶ä¸å¤ªç²¾ç¡®ï¼Œå› ä¸ºåœ†å½¢çš„çº¿æ€§è¿‘ä¼¼\footnote{linear approximation}æ°¸è¿œå¤„åœ¨çœŸæ­£çš„åœ†å½¢ä¹‹å¤–ã€‚  
å› æ­¤ï¼Œ{\em \li{Turtle}} æ€»æ˜¯å’Œæ­£ç¡®çš„ç»ˆç‚¹ç›¸å·®å‡ ä¸ªåƒç´ ã€‚  
æˆ‘çš„ç­”æ¡ˆä¸­å±•ç¤ºäº†é™ä½è¿™ä¸ªé”™è¯¯å½±å“çš„ä¸€ç§æ–¹æ³•ã€‚  
é˜…è¯»å…¶ä¸­çš„ä»£ç ï¼Œ çœ‹çœ‹ä½ æ˜¯å¦èƒ½å¤Ÿç†è§£ã€‚  
å¦‚æœä½ ç”»ä¸€ä¸ªå †æ ˆå›¾çš„è¯ï¼Œ ä½ å¯èƒ½ä¼šæ›´å®¹æ˜“æ˜ç™½èƒŒåçš„åŸç†ã€‚

\end{enumerate}

\end{exercise}


\begin{figure}
\centerline
{\includegraphics[scale=0.85]{../source/figs/flowers.pdf}}
\caption{Turtle flowers.}
\label{fig.flowers}
\end{figure}

\begin{exercise}
\index{flower}

%ğŸ% Write an appropriately general set of functions that
%ğŸ% can draw flowers as in Figure~\ref{fig.flowers}.

ç¼–å†™æ¯”è¾ƒé€šç”¨çš„ä¸€ä¸ªå¯ä»¥ç”»å‡ºåƒå›¾4-1ä¸­é‚£æ ·èŠ±æœµçš„å‡½æ•°é›†ã€‚

%ğŸ% Solution: \url{http://thinkpython2.com/code/flower.py},
%ğŸ% also requires \url{http://thinkpython2.com/code/polygon.py}.

\href{http://thinkpython2.com/code/flower.py}{å‚è€ƒç­”æ¡ˆ}ï¼Œéœ€è¦ä½¿ç”¨\href{http://thinkpython2.com/code/polygon.py}{è¿™ä¸ªæ¨¡å—}ã€‚

\end{exercise}



\begin{figure}
\centerline
{\includegraphics[scale=0.99]{../source/figs/pies.pdf}}
\caption{Turtle pies.}
\label{fig.pies}
\end{figure}


\begin{exercise}
\index{pie}

%ğŸ% Write an appropriately general set of functions that
%ğŸ% can draw shapes as in Figure~\ref{fig.pies}.

ç¼–å†™æ¯”è¾ƒé€šç”¨çš„ä¸€ä¸ªå¯ä»¥ç”»å‡ºå›¾~{\em \ref{fig.flowers} }ä¸­é‚£æ ·å›¾å½¢çš„å‡½æ•°é›†ã€‚

%ğŸ% Solution: \url{http://thinkpython2.com/code/pie.py}.

\href{http://thinkpython2.com/code/pie.py}{å‚è€ƒç­”æ¡ˆ}

\end{exercise}


\begin{exercise}
\index{alphabet}  \index{turtle typewriter}  \index{typewriter, turtle}

%ğŸ% The letters of the alphabet can be constructed from a moderate number
%ğŸ% of basic elements, like vertical and horizontal lines and a few
%ğŸ% curves.  Design an alphabet that can be drawn with a minimal
%ğŸ% number of basic elements and then write functions that draw the letters.

å­—æ¯è¡¨ä¸­çš„å­—æ¯å¯ä»¥ç”±å°‘é‡åŸºæœ¬å…ƒç´ æ„æˆï¼Œä¾‹å¦‚ç«–çº¿å’Œæ¨ªçº¿ï¼Œä»¥åŠä¸€äº›æ›²çº¿ã€‚
è®¾è®¡ä¸€ç§å¯ç”¨ç”±æœ€å°‘çš„åŸºæœ¬å…ƒç´ ç»˜åˆ¶å‡ºçš„å­—æ¯è¡¨ï¼Œç„¶åç¼–å†™èƒ½ç”»å‡ºå„ä¸ªå­—æ¯çš„å‡½æ•°ã€‚

%ğŸ% You should write one function for each letter, with names
%ğŸ% \verb"draw_a", \verb"draw_b", etc., and put your functions
%ğŸ% in a file named {\tt letters.py}.  You can download a
%ğŸ% ``turtle typewriter'' from \url{http://thinkpython2.com/code/typewriter.py}
%ğŸ% to help you test your code.

ä½ åº”è¯¥ä¸ºæ¯ä¸ªå­—æ¯å†™ä¸€ä¸ªå‡½æ•°ï¼Œèµ·åä¸º {\em \li{draw_a} } ï¼Œ{\em \li{draw_b} }  ç­‰ç­‰ï¼Œ
ç„¶åå°†ä½ çš„å‡½æ•°æ”¾åœ¨ä¸€ä¸ªåä¸º {\em \li{letters.py} }  çš„æ–‡ä»¶é‡Œã€‚
ä½ å¯ä»¥ä» \href{http://thinkpython2.com/code/typewriter.py}{è¿™é‡Œ}
ä¸‹è½½ä¸€ä¸ª``æµ·é¾Ÿæ‰“å­—å‘˜''æ¥å¸®ä½ æµ‹è¯•ä»£ç ã€‚

%ğŸ% You can get a solution from \url{http://thinkpython2.com/code/letters.py};
%ğŸ% it also requires \url{http://thinkpython2.com/code/polygon.py}.

ä½ å¯ä»¥åœ¨ \href{http://thinkpython2.com/code/letters.py}{è¿™é‡Œ}æ‰¾åˆ°å‚è€ƒç­”æ¡ˆï¼›è¿™ä¸ªè§£æ³•è¿˜è¦æ±‚ä½¿ç”¨ \href{http://thinkpython2.com/code/polygon.py}{è¿™ä¸ªæ¨¡å—} ã€‚

\end{exercise}


\begin{exercise}

%ğŸ% Read about spirals at \url{http://en.wikipedia.org/wiki/Spiral}; then
%ğŸ% write a program that draws an Archimedian spiral (or one of the other
%ğŸ% kinds).  Solution: \url{http://thinkpython2.com/code/spiral.py}.

é˜…è¯»å…³äº \href{https://zh.wikipedia.org/wiki/%E8%9E%BA%E7%BA%BF}{èºçº¿} {\em (\href{http://en.wikipedia.org/wiki/Spiral}{spiral})} çš„ç›¸å…³çŸ¥è¯†ï¼›
ç„¶åç¼–å†™ä¸€ä¸ªç»˜åˆ¶é˜¿åŸºç±³å¾·èºçº¿ï¼ˆæˆ–è€…å…¶ä»–ç§ç±»çš„èºçº¿ï¼‰çš„ç¨‹åºã€‚
\index{spiral}  \index{Archimedian spiral}

\href{http://thinkpython2.com/code/spiral.py}{å‚è€ƒç­”æ¡ˆ}

\end{exercise}

% SEIKA
% 23 Mar 2016
% 09 Jul 2016