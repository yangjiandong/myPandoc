

%ğŸ% \chapter{The Goodies}
\chapter{è¿›é˜¶å°æŠ€å·§}

%ğŸ% One of my goals for this book has been to teach you as little Python
%ğŸ% as possible.  When there were two ways to do something, I picked
%ğŸ% one and avoided mentioning the other.  Or sometimes I put the second
%ğŸ% one into an exercise.

æˆ‘å†™è¿™æœ¬ä¹¦æ—¶çš„ä¸€ä¸ªç›®æ ‡ï¼Œ å°±æ˜¯å°½é‡å°‘æ•™äº›Pythonã€‚  å¦‚æœæœ‰ä¸¤ç§å®ç°æ–¹æ³•ï¼Œ æˆ‘ä¼šæŒ‘å…¶ä¸­ä¹‹ä¸€è®²è§£ï¼Œ é¿å…å†æå¦ä¸€ç§æ–¹æ³•ã€‚  æœ‰æ—¶å€™å¯èƒ½ä¼šå°†ç¬¬äºŒç§æ–¹æ³•æ”¾åœ¨ç»ƒä¹ é¢˜é‡Œã€‚

%ğŸ% Now I want to go back for some of the good bits that got left behind.
%ğŸ% Python provides a number of features that are not really necessary---you
%ğŸ% can write good code without them---but with them you can sometimes
%ğŸ% write code that's more concise, readable or efficient, and sometimes
%ğŸ% all three.

ç°åœ¨æˆ‘æƒ³å›è¿‡å¤´æ¥è®²ä¸€äº›ä¹‹å‰æ²¡æœ‰æ¶‰åŠçš„å†…å®¹ã€‚  Pythonæä¾›çš„ç‰¹æ€§ä¸­ï¼Œ æœ‰ä¸€äº›å…¶å®å¹¶ä¸æ˜¯å¿…é¡»çš„ --- æ²¡æœ‰å®ƒä»¬ä½ ä¹Ÿèƒ½å†™å‡ºå¥½çš„ä»£ç  --- ä½†æ˜¯æœ‰äº†å®ƒä»¬ä¹‹åï¼Œæœ‰æ—¶å€™ä½ èƒ½å†™å‡ºæ›´ç®€æ´ã€ å¯è¯»æ€§æ›´é«˜æˆ–è€…æ•ˆç‡æ›´é«˜çš„ä»£ç ï¼Œ æœ‰æ—¶å€™ç”šè‡³ä¸‰ä¸ªå¥½å¤„éƒ½æœ‰ã€‚

%ğŸ% % TODO: add the with statement

%ğŸ% \section{Conditional expressions}
\section{æ¡ä»¶è¡¨è¾¾å¼}

%ğŸ% We saw conditional statements in Section~\ref{conditional.execution}.
%ğŸ% Conditional statements are often used to choose one of two values;
%ğŸ% for example:

åœ¨ \ref{conditional.execution}~èŠ‚ä¸­ï¼Œ æˆ‘ä»¬å­¦ä¹ äº†æ¡ä»¶è¯­å¥ã€‚
æ¡ä»¶è¯­å¥é€šå¸¸ç”¨äºåœ¨ä¸¤ä¸ªå€¼ä¹‹é—´è¿›è¡ŒäºŒé€‰ä¸€ï¼›ä¾‹å¦‚ï¼š

\index{conditional expression}
\index{expression!conditional}

\begin{lstlisting}
if x > 0:
    y = math.log(x)
else:
    y = float('nan')
\end{lstlisting}

%ğŸ% This statement checks whether {\tt x} is positive.  If so, it computes
%ğŸ% {\tt math.log}.  If not, {\tt math.log} would raise a ValueError.  To
%ğŸ% avoid stopping the program, we generate a ``NaN'', which is a special
%ğŸ% floating-point value that represents ``Not a Number''.

è¿™ä¸ªè¯­å¥æ£€æµ‹ \li{x} æ˜¯å¦æ˜¯æ­£å€¼ã€‚
å¦‚æœæ˜¯ï¼Œå®ƒå°†è®¡ç®—å®ƒçš„ \li{math.log}ã€‚
å¦‚æœä¸æ˜¯ï¼Œ \li{math.log} ä¼šæŠ›å‡º \li{ValueError}ã€‚
ä¸ºäº†é¿å…ç¨‹åºå‡ºé”™ï¼Œæˆ‘ä»¬ç”Ÿæˆä¸€ä¸ª \li{"NaN"}ï¼Œ è¿™æ˜¯ä¸€ä¸ªä»£è¡¨ ``éæ•°å­—''çš„ç‰¹æ®Šæµ®ç‚¹å€¼ã€‚

\index{NaN}
\index{floating-point}

%ğŸ% We can write this statement more concisely using a {\bf conditional
%ğŸ% expression}:

æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ {\em æ¡ä»¶è¡¨è¾¾å¼} ç®€åŒ–è¿™ä¸ªè¯­å¥ï¼š

\begin{lstlisting}
y = math.log(x) if x > 0 else float('nan')
\end{lstlisting}

%ğŸ% You can almost read this line like English: ``{\tt y} gets log-{\tt x}
%ğŸ% if {\tt x} is greater than 0; otherwise it gets NaN''.

è¿™æ¡è¯­å¥è¯»èµ·æ¥å¾ˆåƒè‹±è¯­ï¼š``y gets log-x if x is
greater than 0; otherwise it gets NaN''
(å¦‚æœ x å¤§äº 0ï¼Œy çš„å€¼åˆ™æ˜¯ x çš„ logï¼›å¦åˆ™ y çš„å€¼ä¸º NaN )ã€‚

%ğŸ% Recursive functions can sometimes be rewritten using conditional
%ğŸ% expressions.  For example, here is a recursive version of {\tt factorial}:

æœ‰æ—¶å€™ä¹Ÿå¯ä»¥ä½¿ç”¨æ¡ä»¶è¡¨è¾¾å¼æ”¹å†™ é€’å½’å‡½æ•°ã€‚  ä¾‹å¦‚ï¼Œä¸‹é¢æ˜¯é˜¶ä¹˜å‡½æ•°çš„ é€’å½’ç‰ˆæœ¬ï¼š

\index{factorial}
\index{function!factorial}

\begin{lstlisting}
def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n-1)
\end{lstlisting}

%ğŸ% We can rewrite it like this:

æˆ‘ä»¬å¯ä»¥åƒè¿™æ ·é‡å†™ï¼š

\begin{lstlisting}
def factorial(n):
    return 1 if n == 0 else n * factorial(n-1)
\end{lstlisting}

%ğŸ% Another use of conditional expressions is handling optional
%ğŸ% arguments.  For example, here is the init method from
%ğŸ% {\tt GoodKangaroo} (see Exercise~\ref{kangaroo}):

æ¡ä»¶è¡¨è¾¾å¼çš„å¦ä¸€ä¸ªç”¨å¤„æ˜¯å¤„ç†å¯é€‰å‚æ•°ã€‚ä¾‹å¦‚ï¼Œä¸‹é¢æ˜¯ \ref{kangaroo}~èŠ‚ä¸­ \li{GoodKangaroo} ç±»çš„ init æ–¹æ³•ï¼š

\index{optional argument}
\index{argument!optional}

\begin{lstlisting}
    def __init__(self, name, contents=None):
        self.name = name
        if contents == None:
            contents = []
        self.pouch_contents = contents
\end{lstlisting}

%ğŸ% We can rewrite this one like this:

æˆ‘ä»¬å¯ä»¥åƒè¿™æ ·é‡å†™ï¼š

\begin{lstlisting}
    def __init__(self, name, contents=None):
        self.name = name
        self.pouch_contents = [] if contents == None else contents
\end{lstlisting}

%ğŸ% In general, you can replace a conditional statement with a conditional
%ğŸ% expression if both branches contain simple expressions that are
%ğŸ% either returned or assigned to the same variable.

ä¸€èˆ¬æ¥è¯´ï¼Œå¦‚æœæ¡ä»¶è¯­å¥çš„ä¸¤ä¸ªåˆ†æ”¯ä¸­å‡ä¸ºç®€å•çš„è¡¨è¾¾å¼ï¼Œä¸æ˜¯è¢«è¿”å›å°±æ˜¯è¢«èµ‹å€¼ç»™ç›¸åŒçš„å˜é‡ï¼Œé‚£ä¹ˆä½ å¯ä»¥ç”¨æ¡ä»¶è¡¨è¾¾å¼æ›¿æ¢è°ƒè¯¥æ¡ä»¶è¯­å¥ã€‚

\index{conditional statement}
\index{statement!conditional}


%ğŸ% \section{List comprehensions}
\section{åˆ—è¡¨æ¨å¯¼å¼}

%ğŸ% In Section~\ref{filter} we saw the map and filter patterns.  For
%ğŸ% example, this function takes a list of strings, maps the string method
%ğŸ% {\tt capitalize} to the elements, and returns a new list of strings:

åœ¨\ref{filter}~èŠ‚ä¸­ï¼Œ æˆ‘ä»¬å­¦ä¹ äº†æ˜ å°„å’Œç­›é€‰æ¨¡å¼ã€‚  ä¾‹å¦‚ï¼Œ ä¸‹é¢è¿™ä¸ªå‡½æ•°æ¥å—ä¸€ä¸ªå­—ç¬¦ä¸²åˆ—è¡¨ï¼Œ å°†å­—ç¬¦ä¸²æ–¹æ³• \li{capitalize} æ˜ å°„è‡³å…ƒç´ ï¼Œ å¹¶è¿”å›ä¸€ä¸ªæ–°çš„å­—ç¬¦ä¸²åˆ—è¡¨ï¼š

\begin{lstlisting}
def capitalize_all(t):
    res = []
    for s in t:
        res.append(s.capitalize())
    return res
\end{lstlisting}

%ğŸ% We can write this more concisely using a {\bf list comprehension}:

æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ {\em åˆ—è¡¨æ¨å¯¼å¼} ç®€åŒ–è¯¥å‡½æ•°ï¼š

\index{list comprehension}

\begin{lstlisting}
def capitalize_all(t):
    return [s.capitalize() for s in t]
\end{lstlisting}

%ğŸ% The bracket operators indicate that we are constructing a new
%ğŸ% list.  The expression inside the brackets specifies the elements
%ğŸ% of the list, and the {\tt for} clause indicates what sequence
%ğŸ% we are traversing.

æ–¹æ‹¬å·æ“ä½œç¬¦è¡¨ç¤ºï¼Œæˆ‘ä»¬æ­£åœ¨æ„é€ ä¸€ä¸ªæ–°åˆ—è¡¨ã€‚
æ–¹æ‹¬å·ä¸­çš„è¡¨è¾¾å¼æŒ‡å®šåˆ—è¡¨ä¸­çš„å…ƒç´ ï¼Œ \li{for} å­å¥è¡¨ç¤ºæˆ‘ä»¬è¦éå†çš„åºåˆ—ã€‚

\index{list}  \index{for loop}

%ğŸ% The syntax of a list comprehension is a little awkward because
%ğŸ% the loop variable, {\tt s} in this example, appears in the expression
%ğŸ% before we get to the definition.

åˆ—è¡¨æ¨å¯¼å¼çš„è¯­æ³•æœ‰ç‚¹å¥‡æ€ªï¼Œå› ä¸ºæ­¤ä¾‹ä¸­çš„å¾ªç¯å˜é‡ \li{s} åœ¨å®šä¹‰ä¹‹å‰å°±å‡ºç°äº†ã€‚
\index{loop variable}

%ğŸ% List comprehensions can also be used for filtering.  For example,
%ğŸ% this function selects only the elements of {\tt t} that are
%ğŸ% upper case, and returns a new list:

åˆ—è¡¨æ¨å¯¼å¼ä¹Ÿå¯ä»¥ç”¨äºç­›é€‰ã€‚ä¾‹å¦‚ï¼Œè¿™ä¸ªå‡½æ•°åªé€‰æ‹© \li{t} ä¸­ä¸ºå¤§å†™çš„å…ƒç´ ï¼Œå¹¶è¿”å›ä¸€ä¸ªæ–°åˆ—è¡¨ï¼š

\index{filter pattern}  \index{pattern!filter}

\begin{lstlisting}
def only_upper(t):
    res = []
    for s in t:
        if s.isupper():
            res.append(s)
    return res
\end{lstlisting}

%ğŸ% We can rewrite it using a list comprehension

æˆ‘ä»¬å¯ä»¥ä½¿ç”¨åˆ—è¡¨æ¨å¯¼å¼é‡å†™è¿™ä¸ªå‡½æ•°ï¼š

\begin{lstlisting}
def only_upper(t):
    return [s for s in t if s.isupper()]
\end{lstlisting}

%ğŸ% List comprehensions are concise and easy to read, at least for simple
%ğŸ% expressions.  And they are usually faster than the equivalent for
%ğŸ% loops, sometimes much faster.  So if you are mad at me for not
%ğŸ% mentioning them earlier, I understand.

åˆ—è¡¨æ¨å¯¼å¼éå¸¸ç®€æ´ã€æ˜“è¯»ï¼Œè‡³å°‘å¯¹ç®€å•çš„è¡¨è¾¾å¼æ˜¯è¿™æ ·çš„ã€‚
è€Œä¸”é€šå¸¸æ¯”å¯¹åº”çš„ \li{for} å¾ªç¯è¦æ›´å¿«ï¼Œ æœ‰æ—¶è¦å¿«å¾ˆå¤šã€‚
æ‰€ä»¥ï¼Œ å¦‚æœä½ åŸ‹æ€¨æˆ‘ä¹‹å‰æ²¡ä»‹ç»ï¼Œ å¯ä»¥ç†è§£ã€‚

%ğŸ% But, in my defense, list comprehensions are harder to debug because
%ğŸ% you can't put a print statement inside the loop.  I suggest that you
%ğŸ% use them only if the computation is simple enough that you are likely
%ğŸ% to get it right the first time.  And for beginners that means never.

ä½†æ˜¯ï¼Œ æˆ‘è¿™ä¹ˆåšä¹Ÿæ˜¯æœ‰åŸå› çš„ï¼Œ åˆ—è¡¨æ¨å¯¼å¼çš„è°ƒè¯•éš¾åº¦æ›´å¤§ï¼Œ å› ä¸ºä½ ä¸èƒ½åœ¨å¾ªç¯ä¸­æ·»åŠ æ‰“å°è¯­å¥ã€‚
æˆ‘å»ºè®®ä½ åªåœ¨è®¡ç®—è¶³å¤Ÿç®€å•ã€ ç¬¬ä¸€æ¬¡å°±èƒ½å†™å‡ºæ­£ç¡®ä»£ç çš„å‰æä¸‹ä½¿ç”¨ã€‚
ä¸è¿‡å¯¹åˆå­¦æ¥è¯´ï¼Œ ç¬¬ä¸€æ¬¡å°±å†™å¯¹å‡ ä¹ä¸å¯èƒ½ã€‚

\index{debugging}

%ğŸ% \section{Generator expressions}
\section{ç”Ÿæˆå™¨è¡¨è¾¾å¼}

%ğŸ% {\bf Generator expressions} are similar to list comprehensions, but
%ğŸ% with parentheses instead of square brackets:

{\em ç”Ÿæˆå™¨è¡¨è¾¾å¼} ä¸åˆ—è¡¨æ¨å¯¼å¼ç±»ä¼¼ï¼Œ ä½†æ˜¯ä½¿ç”¨çš„æ˜¯åœ†æ‹¬å·ï¼Œ è€Œä¸æ˜¯æ–¹æ‹¬å·ï¼š

\index{generator expression}  \index{expression!generator}

\begin{lstlisting}
>>> g = (x**2 for x in range(5))
>>> g
<generator object <genexpr> at 0x7f4c45a786c0>
\end{lstlisting}

%ğŸ% %
%ğŸ% The result is a generator object that knows how to iterate through
%ğŸ% a sequence of values.  But unlike a list comprehension, it does not
%ğŸ% compute the values all at once; it waits to be asked.  The built-in
%ğŸ% function {\tt next} gets the next value from the generator:

ç»“æœæ˜¯ä¸€ä¸ªè¡¨è¾¾å¼å¯¹è±¡ï¼Œ è¯¥å¯¹è±¡çŸ¥é“å¦‚ä½•éå†ä¸€ä¸ªå€¼åºåˆ—ã€‚  ä½†ä¸åˆ—ä¸¾æ¨å¯¼å¼ä¸åŒçš„æ˜¯ï¼Œ å®ƒä¸ä¼šä¸€æ¬¡æ€§è®¡ç®—å‡ºæ‰€æœ‰çš„å€¼ï¼› è€Œæ˜¯ç­‰å¾…æ±‚å€¼è¯·æ±‚ã€‚  å†…å»ºå‡½æ•° \li{next} ä»ç”Ÿæˆå™¨è·å–ä¸‹ä¸€ä¸ªå€¼ï¼š

\index{generator object}
\index{object!generator}

\begin{lstlisting}
>>> next(g)
0
>>> next(g)
1
\end{lstlisting}

%ğŸ% %
%ğŸ% When you get to the end of the sequence, {\tt next} raises a
%ğŸ% StopIteration exception.  You can also use a {\tt for} loop to iterate
%ğŸ% through the values:

æŠµè¾¾åºåˆ—çš„æœ«å°¾æ—¶ï¼Œ \li{next} ä¼šæŠ›å‡º \li{StopIteration} å¼‚å¸¸ã€‚
ä½ è¿˜å¯ä»¥ä½¿ç”¨ \li{for} å¾ªç¯éå†è¿™äº›å€¼ï¼š

\index{StopIteration}
\index{exception!StopIteration}

\begin{lstlisting}
>>> for val in g:
...     print(val)
4
9
16
\end{lstlisting}

%ğŸ% %
%ğŸ% The generator object keeps track of where it is in the sequence,
%ğŸ% so the {\tt for} loop picks up where {\tt next} left off.  Once the
%ğŸ% generator is exhausted, it continues to raise {\tt StopException}:

ç”Ÿæˆå™¨å¯¹è±¡ä¼šè®°å½•å…¶åœ¨åºåˆ—ä¸­çš„ä½ç½®ï¼Œ å› æ­¤ \li{for} å¾ªç¯æ˜¯ä» \li{next} ç»“æŸçš„åœ°æ–¹å¼€å§‹çš„ã€‚  ä¸€æ—¦ç”Ÿæˆå™¨è¢«æ¶ˆè€—å®Œï¼Œå®ƒä¼šæŠ›å‡º \li{StopException} ã€‚

\begin{lstlisting}
>>> next(g)
StopIteration
\end{lstlisting}

%ğŸ% Generator expressions are often used with functions like {\tt sum},
%ğŸ% {\tt max}, and {\tt min}:

ç”Ÿæˆå™¨è¡¨è¾¾å¼å¸¸ä¸ \li{sum} ã€ \li{max} å’Œ \li{min} ç­‰å‡½æ•°ä¸€èµ·ä½¿ç”¨ï¼š

\index{sum}
\index{function!sum}

\begin{lstlisting}
>>> sum(x**2 for x in range(5))
30
\end{lstlisting}

%ğŸ% \section{{\tt any} and {\tt all}}
\section{{\tt any} å’Œ {\tt all}}

%ğŸ% Python provides a built-in function, {\tt any}, that takes a sequence
%ğŸ% of boolean values and returns {\tt True} if any of the values are {\tt
%ğŸ%   True}.  It works on lists:

Pythonæä¾›äº†ä¸€ä¸ªå†…å»ºå‡½æ•° \li{any}ï¼Œå®ƒæ¥å—ä¸€ä¸ªå¸ƒå°”å€¼åºåˆ—ï¼Œå¦‚æœå…¶ä¸­æœ‰ä»»æ„ä¸€ä¸ªå€¼ä¸º \li{True} åˆ™è¿”å› \li{True}ã€‚  å®ƒä¹Ÿé€‚ç”¨äºåˆ—è¡¨ï¼š

\index{any}
\index{built-in function!any}

\begin{lstlisting}
>>> any([False, False, True])
True
\end{lstlisting}

%ğŸ% %
%ğŸ% But it is often used with generator expressions:

ä½†æ˜¯å®ƒé€šå¸¸ç”¨äºç”Ÿæˆå™¨è¡¨è¾¾å¼ï¼š

\index{generator expression}
\index{expression!generator}

\begin{lstlisting}
>>> any(letter == 't' for letter in 'monty')
True
\end{lstlisting}

%ğŸ% %
%ğŸ% That example isn't very useful because it does the same thing
%ğŸ% as the {\tt in} operator.  But we could use {\tt any} to rewrite
%ğŸ% some of the search functions we wrote in Section~\ref{search}.  For
%ğŸ% example, we could write {\tt avoids} like this:

ä¸Šé¢è¿™ä¸ªä¾‹å­ä¸æ˜¯å¾ˆæœ‰ç”¨ï¼Œå› ä¸ºå®ƒçš„åŠŸèƒ½å’Œ in æ“ä½œç¬¦ä¸€æ ·ã€‚ä½†æ˜¯æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ \li{any} é‡å†™ \ref{search}~èŠ‚ ä¸­çš„éƒ¨åˆ†æœç´¢å‡½æ•°ã€‚  ä¾‹å¦‚ï¼Œ æˆ‘ä»¬å¯ä»¥åƒè¿™æ ·ç¼–å†™ \li{avoids} å‡½æ•°ï¼š

\index{search pattern}
\index{pattern!search}

\begin{lstlisting}
def avoids(word, forbidden):
    return not any(letter in forbidden for letter in word)
\end{lstlisting}

%ğŸ% %
%ğŸ% The function almost reads like English, ``{\tt word} avoids
%ğŸ% {\tt forbidden} if there are not any forbidden letters in {\tt word}.''

ä¸Šé¢çš„å‡½æ•°è¯»å–æ¥å’Œè‹±è¯­æ²¡ä»€ä¹ˆåŒºåˆ«ï¼š``word avoids forbidden if there
are not any forbidden letters in word.''
(å¦‚æœæŸä¸ªè¯ä¸­æ²¡æœ‰ä»»ä½•ç¦ç”¨å­—æ¯ï¼Œé‚£ä¹ˆè¯¥è¯å°±ç®—é¿å…äº†ä½¿ç”¨ç¦ç”¨è¯ã€‚)

%ğŸ% Using {\tt any} with a generator expression is efficient because
%ğŸ% it stops immediately if it finds a {\tt True} value,
%ğŸ% so it doesn't have to evaluate the whole sequence.

å°† \li{any} ä¸ç”Ÿæˆå™¨è¡¨è¾¾å¼ç»“åˆä½¿ç”¨çš„æ•ˆç‡è¾ƒé«˜ï¼Œ å› ä¸ºå®ƒåªè¦ä¸€é‡åˆ°çœŸå€¼å°±ä¼šç»ˆæ­¢ï¼Œ æ‰€ä»¥ä¸ä¼šå¯¹æ•´ä¸ªåºåˆ—è¿›è¡Œè®¡ç®—ã€‚

%ğŸ% Python provides another built-in function, {\tt all}, that returns
%ğŸ% {\tt True} if every element of the sequence is {\tt True}.  As
%ğŸ% an exercise, use {\tt all} to re-write \verb"uses_all" from
%ğŸ% Section~\ref{search}.

Pythonè¿˜æä¾›äº†å¦ä¸€ä¸ªå†…å»ºå‡½æ•° \li{all}ï¼Œ å¦‚æœåºåˆ—ä¸­çš„æ¯ä¸ªå…ƒç´ å‡ä¸º \li{True} æ‰ä¼šè¿”å› \li{True} ã€‚ æˆ‘ä»¬åšä¸ªç»ƒä¹ ï¼Œä½¿ç”¨ \li{all} é‡å†™ \ref{search}~èŠ‚ä¸­ \li{uses_all} å‡½æ•°ã€‚

\index{all}
\index{built-in function!any}


%ğŸ% \section{Sets}
\section{é›†åˆ}
\label{sets}

%ğŸ% In Section~\ref{dictsub} I use dictionaries to find the words
%ğŸ% that appear in a document but not in a word list.  The function
%ğŸ% I wrote takes {\tt d1}, which contains the words from the document
%ğŸ% as keys, and {\tt d2}, which contains the list of words.  It
%ğŸ% returns a dictionary that contains the keys from {\tt d1} that
%ğŸ% are not in {\tt d2}.

åœ¨ \ref{dictsub}~èŠ‚ ä¸­ï¼Œ æˆ‘ä½¿ç”¨å­—å…¸å¯¹é‚£äº›åœ¨æ–‡æ¡£ä¸­ä½†ä¸åœ¨å•è¯åˆ—è¡¨é‡Œçš„å•è¯è¿›è¡Œäº†æŸ¥æ‰¾ã€‚
æˆ‘å†™çš„é‚£ä¸ªå‡½æ•°æ¥å—å‚æ•° \li{d1} å’Œ \li{d2} ï¼Œ åˆ†åˆ«åŒ…å«æ–‡æ¡£ä¸­çš„å•è¯(ä½œä¸ºé”®ä½¿ç”¨)å’Œå•è¯åˆ—è¡¨ã€‚
å®ƒè¿”å›ä¸åœ¨ \li{d2} ä¸­ä½†åœ¨ \li{d1} é‡Œçš„é”®ç»„æˆçš„å­—å…¸ã€‚

\begin{lstlisting}
def subtract(d1, d2):
    res = dict()
    for key in d1:
        if key not in d2:
            res[key] = None
    return res
\end{lstlisting}

%ğŸ% %
%ğŸ% In all of these dictionaries, the values are {\tt None} because
%ğŸ% we never use them.  As a result, we waste some storage space.

åœ¨ä¸Šé¢çš„å­—å…¸ä¸­ï¼Œæ‰€æœ‰é”®çš„å€¼å‡ä¸º \li{None} ï¼Œ å› ä¸ºæˆ‘ä»¬ä¸ä¼šä½¿ç”¨è¿™äº›å€¼ã€‚  åæœå°±æ˜¯ä¼šæµªè´¹ä¸€äº›å­˜å‚¨ç©ºé—´ã€‚
\index{dictionary subtraction}

%ğŸ% Python provides another built-in type, called a {\tt set}, that
%ğŸ% behaves like a collection of dictionary keys with no values.  Adding
%ğŸ% elements to a set is fast; so is checking membership.  And sets
%ğŸ% provide methods and operators to compute common set operations.
\index{set}
\index{object!set}

Python æä¾›äº†å¦ä¸€ä¸ªå«åšé›†åˆçš„å†…å»ºç±»å‹ï¼Œ å®ƒçš„è¡Œä¸ºç±»ä¼¼æ²¡æœ‰å€¼çš„å­—å…¸é”®é›†åˆã€‚
å¾€é›†åˆä¸­æ·»åŠ å…ƒç´ æ˜¯éå¸¸å¿«çš„ï¼› æˆå‘˜å…³ç³»æ£€æµ‹ä¹Ÿå¾ˆå¿«ã€‚
å¦å¤–ï¼Œ é›†åˆè¿˜æä¾›äº†è®¡ç®—å¸¸è§é›†åˆæ“ä½œçš„æ–¹æ³•å’Œæ“ä½œç¬¦ã€‚

%ğŸ% For example, set subtraction is available as a method called
%ğŸ% {\tt difference} or as an operator, {\tt -}.  So we can rewrite
%ğŸ% {\tt subtract} like this:
\index{set subtraction}

ä¾‹å¦‚ï¼Œé›†åˆå·®é›†å°±æœ‰ä¸€ä¸ªå¯¹åº”çš„ \li{difference} æ–¹æ³•ï¼Œæˆ–è€…æ“ä½œç¬¦ \li{-}ã€‚
å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥è¿™æ ·é‡å†™ \li{subtract} å‡½æ•°ï¼š

\begin{lstlisting}
def subtract(d1, d2):
    return set(d1) - set(d2)
\end{lstlisting}

%ğŸ% %
%ğŸ% The result is a set instead of a dictionary, but for operations like
%ğŸ% iteration, the behavior is the same.

ç»“æœæ˜¯ä¸€ä¸ªé›†åˆï¼Œ è€Œä¸æ˜¯å­—å…¸ï¼Œ ä½†å¯¹äºåƒè¿­ä»£è¿™æ ·çš„æ“ä½œè€Œè¨€ï¼Œ äºŒè€…æ˜¯æ²¡æœ‰åŒºåˆ«çš„ã€‚

%ğŸ% Some of the exercises in this book can be done concisely and
%ğŸ% efficiently with sets.  For example, here is a solution to
%ğŸ% \verb"has_duplicates", from
%ğŸ% Exercise~\ref{duplicate}, that uses a dictionary:

å¦‚æœä½¿ç”¨é›†åˆæ¥å®Œæˆæœ¬ä¹¦ä¸­çš„éƒ¨åˆ†ç»ƒä¹ é¢˜ï¼Œ ä»£ç ä¼šæ¯”è¾ƒç®€æ´ã€ é«˜æ•ˆã€‚
ä¾‹å¦‚ï¼Œ ä¸‹é¢æ˜¯ \ref{duplicate} ä¸­ \li{has_duplicates} å‡½æ•°çš„ä¸€ç§ä½¿ç”¨å­—å…¸çš„å®ç°ï¼š

\begin{lstlisting}
def has_duplicates(t):
    d = {}
    for x in t:
        if x in d:
            return True
        d[x] = True
    return False
\end{lstlisting}

%ğŸ% When an element appears for the first time, it is added to the
%ğŸ% dictionary.  If the same element appears again, the function returns
%ğŸ% {\tt True}.

å½“æŸä¸ªå…ƒç´ é¦–æ¬¡å‡ºç°æ—¶ï¼Œå®ƒè¢«æ·»åŠ è‡³å­—å…¸ä¸­ã€‚å¦‚æœåŒæ ·çš„å…ƒç´ å†æ¬¡å‡ºç°ï¼Œå‡½æ•°åˆ™è¿”å› \li{True} ã€‚

%ğŸ% Using sets, we can write the same function like this:

å¦‚æœä½¿ç”¨é›†åˆï¼Œæˆ‘ä»¬å¯ä»¥åƒè¿™æ ·é‡å†™è¯¥å‡½æ•°ï¼š

\begin{lstlisting}
def has_duplicates(t):
    return len(set(t)) < len(t)
\end{lstlisting}

%ğŸ% %
%ğŸ% An element can only appear in a set once, so if an element in {\tt t}
%ğŸ% appears more than once, the set will be smaller than {\tt t}.  If there
%ğŸ% are no duplicates, the set will be the same size as {\tt t}.
\index{duplicate}

ä¸€ä¸ªå…ƒç´ åœ¨é›†åˆä¸­åªèƒ½å‡ºç°ä¸€æ¬¡ï¼Œ å› æ­¤å¦‚æœ \li{t} ä¸­çš„æŸä¸ªå…ƒç´ å‡ºç°æ¬¡æ•°è¶…è¿‡ä¸€æ¬¡ï¼Œ é‚£ä¹ˆé›†åˆçš„å¤§å°å°±ä¼šå°äº \li{t}ã€‚  å¦‚æœæ²¡æœ‰é‡å¤çš„å…ƒç´ ï¼Œé›†åˆå’Œ \li{t} çš„å¤§å°åˆ™ç›¸åŒã€‚

%ğŸ% We can also use sets to do some of the exercises in
%ğŸ% Chapter~\ref{wordplay}.  For example, here's a version of
%ğŸ% \verb"uses_only" with a loop:

æˆ‘ä»¬è¿˜å¯ä»¥ä½¿ç”¨é›†åˆå®Œæˆ \ref{wordplay} ä¸­çš„éƒ¨åˆ†ç»ƒä¹ é¢˜ã€‚
ä¾‹å¦‚ï¼Œ ä¸‹é¢æ˜¯ä½¿ç”¨å¾ªç¯å®ç°çš„ \li{uses_only} å‡½æ•°ï¼š

\begin{lstlisting}
def uses_only(word, available):
    for letter in word:
        if letter not in available:
            return False
    return True
\end{lstlisting}

%ğŸ% %
%ğŸ% \verb"uses_only" checks whether all letters in {\tt word} are
%ğŸ% in {\tt available}.  We can rewrite it like this:

\li{uses_only} æ£€æŸ¥ \li{word} ä¸­çš„æ‰€æœ‰å­—ç¬¦ä¹Ÿåœ¨ \li{available} ä¸­ã€‚
æˆ‘ä»¬å¯ä»¥åƒè¿™æ ·é‡å†™è¯¥å‡½æ•°ï¼š

\begin{lstlisting}
def uses_only(word, available):
    return set(word) <= set(available)
\end{lstlisting}

%ğŸ% %
%ğŸ% The \verb"<=" operator checks whether one set is a subset or another,
%ğŸ% including the possibility that they are equal, which is true if all
%ğŸ% the letters in {\tt word} appear in {\tt available}.
\index{subset}

æ“ä½œç¬¦ \li{<=} æ£€æŸ¥æŸä¸ªé›†åˆæ˜¯å¦æ˜¯å¦ä¸€ä¸ªé›†åˆçš„å­é›†æˆ–æœ¬èº«ï¼Œ åŒ…æ‹¬äº†äºŒè€…ç›¸ç­‰çš„å¯èƒ½æ€§ã€‚
å¦‚æœ \li{word} ä¸­æ‰€æœ‰çš„å­—ç¬¦éƒ½å‡ºç°åœ¨ \li{available} ä¸­ï¼Œåˆ™è¿”å› \li{True} ã€‚

%ğŸ% As an exercise, rewrite \verb"avoids" using sets.

æ¥ä¸‹æ¥åšä¸ªç»ƒä¹ ï¼Œ ä½¿ç”¨é›†åˆé‡å†™ \li{avoids} å‡½æ•°ã€‚

%ğŸ% \section{Counters}
\section{è®¡æ•°å™¨}

%ğŸ% A Counter is like a set, except that if an element appears more
%ğŸ% than once, the Counter keeps track of how many times it appears.
%ğŸ% If you are familiar with the mathematical idea of a {\bf multiset},
%ğŸ% a Counter is a natural way to represent a multiset.
\index{Counter}
\index{object!Counter}
\index{multiset}

{\em è®¡æ•°å™¨} (Counter) ç±»ä¼¼é›†åˆï¼Œ åŒºåˆ«åœ¨äºå¦‚æœæŸä¸ªå…ƒç´ å‡ºç°æ¬¡æ•°è¶…è¿‡ä¸€æ¬¡ï¼Œ è®¡æ•°å™¨å°±ä¼šè®°å½•å…¶å‡ºç°æ¬¡æ•°ã€‚  å¦‚æœä½ ç†Ÿæ‚‰æ•°å­¦ä¸­çš„ {\em å¤šé‡é›†} æ¦‚å¿µï¼Œ è®¡æ•°å™¨å°±æ˜¯ç”¨æ¥è¡¨ç¤ºä¸€ä¸ªå¤šé‡é›†çš„è‡ªç„¶é€‰æ‹©ã€‚

%ğŸ% Counter is defined in a standard module called {\tt collections},
%ğŸ% so you have to import it.  You can initialize a Counter with a string,
%ğŸ% list, or anything else that supports iteration:
\index{collections}
\index{module!collections}

è®¡æ•°å™¨å®šä¹‰åœ¨å«åš \li{collections} çš„æ ‡å‡†æ¨¡å—ä¸­ï¼Œ å› æ­¤ä½ å¿…é¡»é¦–å…ˆå¯¼å…¥è¯¥æ¨¡å—ã€‚
ä½ å¯ä»¥é€šè¿‡å­—ç¬¦ä¸²ã€ åˆ—è¡¨æˆ–ä»»ä½•æ”¯æŒè¿­ä»£çš„æ•°æ®ç»“æ„æ¥åˆå§‹åŒ–è®¡æ•°å™¨ï¼š

\begin{lstlisting}
>>> from collections import Counter
>>> count = Counter('parrot')
>>> count
Counter({'r': 2, 't': 1, 'o': 1, 'p': 1, 'a': 1})
\end{lstlisting}

%ğŸ% Counters behave like dictionaries in many ways; they map from each
%ğŸ% key to the number of times it appears.  As in dictionaries,
%ğŸ% the keys have to be hashable.

è®¡æ•°å™¨çš„è¡Œä¸ºä¸å­—å…¸æœ‰å¾ˆå¤šç›¸ä¼¼çš„åœ°æ–¹ï¼š å®ƒä»¬å°†æ¯ä¸ªé”®æ˜ å°„è‡³å…¶å‡ºç°çš„æ¬¡æ•°ã€‚
ä¸å­—å…¸ä¸€æ ·ï¼Œ é”®å¿…é¡»æ˜¯å¯å“ˆå¸Œçš„ã€‚

%ğŸ% Unlike dictionaries, Counters don't raise an exception if you access
%ğŸ% an element that doesn't appear.  Instead, they return 0:

ä¸å­—å…¸ä¸åŒçš„æ˜¯ï¼Œ å¦‚æœä½ è®¿é—®ä¸€ä¸ªæ²¡æœ‰å‡ºç°è¿‡çš„å…ƒç´ ï¼Œ è®¡æ•°å™¨ä¸ä¼šæŠ›å‡ºå¼‚å¸¸ï¼Œ è€Œåªæ˜¯è¿”å› 0 ï¼š

\begin{lstlisting}
>>> count['d']
0
\end{lstlisting}

%ğŸ% We can use Counters to rewrite \verb"is_anagram" from
%ğŸ% Exercise~\ref{anagram}:

æˆ‘ä»¬å¯ä»¥ä½¿ç”¨è®¡æ•°å™¨é‡å†™ ç»ƒä¹ ~\ref{anagram} ä¸­çš„ \li{is_anagram} å‡½æ•°ï¼š

\begin{lstlisting}
def is_anagram(word1, word2):
    return Counter(word1) == Counter(word2)
\end{lstlisting}

%ğŸ% If two words are anagrams, they contain the same letters with the same
%ğŸ% counts, so their Counters are equivalent.

å¦‚æœä¸¤ä¸ªå•è¯æ˜¯å˜ä½è¯ï¼Œ é‚£ä¹ˆå®ƒä»¬ä¼šåŒ…å«ç›¸åŒçš„å­—ç¬¦ï¼Œ è€Œä¸”å­—ç¬¦çš„è®¡æ•°ä¹Ÿç›¸åŒï¼Œ å› æ­¤å®ƒä»¬çš„è®¡æ•°å™¨ä¹Ÿæ˜¯ç­‰ä»·çš„ã€‚

%ğŸ% Counters provide methods and operators to perform set-like operations,
%ğŸ% including addition, subtraction, union and intersection.  And
%ğŸ% they provide an often-useful method, \verb"most_common", which
%ğŸ% returns a list of value-frequency pairs, sorted from most common to
%ğŸ% least:

è®¡æ•°å™¨æä¾›äº†æ‰§è¡Œç±»ä¼¼é›†åˆæ“ä½œçš„æ–¹æ³•å’Œæ“ä½œç¬¦ï¼Œ åŒ…æ‹¬é›†åˆæ·»åŠ ã€ å·®é›†ã€ å¹¶é›†å’Œäº¤é›†ã€‚
å¦å¤–ï¼Œ è¿˜æä¾›äº†ä¸€ä¸ªé€šå¸¸éå¸¸æœ‰ç”¨çš„æ–¹æ³• \li{most_common} ï¼Œè¿”å›ä¸€ä¸ªç”± å€¼-é¢‘ç‡ å¯¹ç»„æˆçš„åˆ—è¡¨ï¼ŒæŒ‰ç…§é¢‘ç‡é«˜ä½

\begin{lstlisting}
>>> count = Counter('parrot')
>>> for val, freq in count.most_common(3):
...     print(val, freq)
r 2
p 1
a 1
\end{lstlisting}


%ğŸ% \section{defaultdict}
\section{defaultdict}

%ğŸ% The {\tt collections} module also provides {\tt defaultdict}, which is
%ğŸ% like a dictionary except that if you access a key that doesn't exist,
%ğŸ% it can generate a new value on the fly.
\index{defaultdict}
\index{object!defaultdict}
\index{collections}
\index{module!collections}

\li{collections} æ¨¡å—ä¸­è¿˜æä¾›äº†ä¸€ä¸ª \li{defaultdict} ï¼Œ å®ƒç±»ä¼¼å­—å…¸ï¼Œ ä½†æ˜¯å¦‚æœä½ è®¿é—®ä¸€ä¸ªä¸å­˜åœ¨çš„é”®ï¼Œ å®ƒä¼šä¸´æ—¶ç”Ÿæˆä¸€ä¸ªæ–°å€¼ã€‚

%ğŸ% When you create a defaultdict, you provide a function that's used to
%ğŸ% create new values.  A function used to create objects is sometimes
%ğŸ% called a {\bf factory}.  The built-in functions that create lists, sets,
%ğŸ% and other types can be used as factories:
\index{factory function}

åœ¨åˆ›å»º \li{defaultdict} æ—¶ï¼Œ ä½ æä¾›ä¸€ä¸ªç”¨äºåˆ›å»ºæ–°å€¼çš„å‡½æ•°ã€‚
è¿™ä¸ªç”¨äºåˆ›å»ºå¯¹è±¡çš„å‡½æ•°æœ‰æ—¶ä¹Ÿè¢«ç§°ä¸º {\em å·¥å‚} ã€‚  ç”¨äºåˆ›å»ºåˆ—è¡¨ã€ é›†åˆå’Œå…¶ä»–ç±»å‹çš„å†…å»ºå‡½æ•°ä¹Ÿå¯ä»¥ç”¨ä½œå·¥å‚ï¼š

\begin{lstlisting}
>>> from collections import defaultdict
>>> d = defaultdict(list)
\end{lstlisting}

%ğŸ% Notice that the argument is {\tt list}, which is a class object,
%ğŸ% not {\tt list()}, which is a new list.  The function you provide
%ğŸ% doesn't get called unless you access a key that doesn't exist.

è¯·æ³¨æ„ï¼Œè¿™é‡Œçš„å®å‚æ˜¯ \li{list}ï¼Œ å®ƒæ˜¯ä¸€ä¸ªç±»å¯¹è±¡ï¼Œ è€Œä¸æ˜¯ \li{list()} ï¼Œ åè€…æ˜¯ä¸€ä¸ªæ–°åˆ—è¡¨ã€‚
ä½ æä¾›çš„å‡½æ•°åªæœ‰åœ¨è®¿é—®ä¸å­˜åœ¨çš„é”®æ—¶ï¼Œ æ‰ä¼šè¢«è°ƒç”¨ã€‚

\begin{lstlisting}
>>> t = d['new key']
>>> t
[]
\end{lstlisting}

%ğŸ% The new list, which we're calling {\tt t}, is also added to the
%ğŸ% dictionary.  So if we modify {\tt t}, the change appears in {\tt d}:

æ–°åˆ—è¡¨ \li{t} ä¹Ÿè¢«æ·»åŠ è‡³å­—å…¸ä¸­ã€‚
å› æ­¤å¦‚æœæˆ‘ä»¬ä¿®æ”¹ \li{t} ï¼Œ æ”¹åŠ¨ä¹Ÿä¼šå‡ºç°åœ¨ \li{d} ä¸­ã€‚

\begin{lstlisting}
>>> t.append('new value')
>>> d
defaultdict(<class 'list'>, {'new key': ['new value']})
\end{lstlisting}

%ğŸ% If you are making a dictionary of lists, you can often write simpler
%ğŸ% code using {\tt defaultdict}.  In my solution to
%ğŸ% Exercise~\ref{anagrams}, which you can get from
%ğŸ% \url{http://thinkpython2.com/code/anagram_sets.py}, I make a
%ğŸ% dictionary that maps from a sorted string of letters to the list of
%ğŸ% words that can be spelled with those letters.  For example, {\tt
%ğŸ%   'opst'} maps to the list {\tt ['opts', 'post', 'pots', 'spot',
%ğŸ%     'stop', 'tops']}.

å¦‚æœä½ è¦åˆ›å»ºä¸€ä¸ªåˆ—è¡¨ç»„æˆçš„å­—å…¸ï¼Œ é€šå¸¸ä½ å¯ä»¥ä½¿ç”¨ \li{defaultdict} æ¥ç®€åŒ–ä»£ç ã€‚
åœ¨\ref{anagrams} çš„ \href{http://thinkpython2.com/code/anagram_sets.py}{ç­”æ¡ˆ}ä¸­ï¼Œ æˆ‘åˆ›å»ºçš„å­—å…¸å°†æ’å¥½åºçš„å­—ç¬¦ä¸²æ˜ å°„è‡³ä¸€ä¸ªå¯ä»¥ç”±è¿™äº›å­—ç¬¦ä¸²æ„æˆçš„å•è¯åˆ—è¡¨ã€‚
ä¾‹å¦‚ï¼Œ\li{'opst'} æ˜ å°„è‡³åˆ—è¡¨ \li{['opts', 'post', 'pots', 'spot', 'stop', 'tops']}ã€‚

%ğŸ% Here's the original code:

ä¸‹é¢æ˜¯ä»£ç ï¼š

\begin{lstlisting}
def all_anagrams(filename):
    d = {}
    for line in open(filename):
        word = line.strip().lower()
        t = signature(word)
        if t not in d:
            d[t] = [word]
        else:
            d[t].append(word)
    return d
\end{lstlisting}

%ğŸ% This can be simplified using {\tt setdefault}, which you might
%ğŸ% have used in Exercise~\ref{setdefault}:
\index{setdefault}

è¿™ä¸ªå‡½æ•°å¯ä»¥ä½¿ç”¨ \li{setdefault} è¿›è¡Œç®€åŒ–ï¼Œ ä½ å¯èƒ½åœ¨ \ref{setdefault} ä¸­ä¹Ÿç”¨åˆ°äº†ï¼š

\begin{lstlisting}
def all_anagrams(filename):
    d = {}
    for line in open(filename):
        word = line.strip().lower()
        t = signature(word)
        d.setdefault(t, []).append(word)
    return d
\end{lstlisting}

%ğŸ% This solution has the drawback that it makes a new list
%ğŸ% every time, regardless of whether it is needed.  For lists,
%ğŸ% that's no big deal, but if the factory
%ğŸ% function is complicated, it might be.
\index{factory function}

è¿™ç§æ–¹æ¡ˆæœ‰ä¸€ä¸ªç¼ºç‚¹ï¼Œ å³ä¸ç®¡æ˜¯å¦éœ€è¦ï¼Œ æ¯æ¬¡éƒ½ä¼šåˆ›å»ºä¸€ä¸ªæ–°åˆ—è¡¨ã€‚
å¦‚æœåªæ˜¯åˆ›å»ºåˆ—è¡¨ï¼Œ è¿™é—®é¢˜ä½ ä¸å¤§ï¼Œ ä½†æ˜¯å¦‚æœå·¥å‚å‡½æ•°éå¸¸å¤æ‚ï¼Œ å°±å¯èƒ½ä¼šæˆä¸ºä¸€ä¸ªå¤§é—®é¢˜ã€‚

%ğŸ% We can avoid this problem and
%ğŸ% simplify the code using a {\tt defaultdict}:

æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ \li{defaultdict} æ¥é¿å…è¿™ä¸ªé—®é¢˜ï¼ŒåŒæ—¶ç®€åŒ–ä»£ç ï¼š

\begin{lstlisting}
def all_anagrams(filename):
    d = defaultdict(list)
    for line in open(filename):
        word = line.strip().lower()
        t = signature(word)
        d[t].append(word)
    return d
\end{lstlisting}

%ğŸ% My solution to Exercise~\ref{poker}, which you can download from
%ğŸ% \url{http://thinkpython2.com/code/PokerHandSoln.py},
%ğŸ% uses {\tt setdefault} in the function
%ğŸ% \verb"has_straightflush".  This solution has the drawback
%ğŸ% of creating a {\tt Hand} object every time through the loop, whether
%ğŸ% it is needed or not.  As an exercise, rewrite it using
%ğŸ% a defaultdict.

ç»ƒä¹ ~\ref{poker} çš„ \href{http://thinkpython2.com/code/PokerHandSoln.py}{ç­”æ¡ˆ}ä¸­ï¼Œ \li{has_straightflush} å‡½æ•°ä½¿ç”¨äº† \li{setdefault}ã€‚
è¿™ä¸ªç­”æ¡ˆçš„ç¼ºç‚¹å°±æ˜¯æ¯æ¬¡å¾ªç¯æ—¶éƒ½ä¼šåˆ›å»ºä¸€ä¸ª \li{Hand} å¯¹è±¡ï¼Œ ä¸ç®¡æ˜¯å¦éœ€è¦ã€‚
æˆ‘ä»¬åšä¸ªç»ƒä¹ ï¼Œ ä½¿ç”¨ \li{defaultdict} æ”¹å†™è¿™ä¸ªå‡½æ•°ã€‚


%ğŸ% \section{Named tuples}
\section{å‘½åå…ƒç»„}

%ğŸ% Many simple objects are basically collections of related values.
%ğŸ% For example, the Point object defined in Chapter~\ref{clobjects} contains
%ğŸ% two numbers, {\tt x} and {\tt y}.  When you define a class like
%ğŸ% this, you usually start with an init method and a str method:

è®¸å¤šç®€å•å¯¹è±¡åŸºæœ¬ä¸Šå°±æ˜¯ç›¸å…³å€¼çš„é›†åˆã€‚
ä¾‹å¦‚ï¼Œ\ref{clobjects} ä¸­å®šä¹‰çš„ \li{Point} å¯¹è±¡åŒ…å«ä¸¤ä¸ªæ•°å­— \li{x} å’Œ \li{y} ã€‚
å½“ä½ åƒä¸‹é¢è¿™æ ·å®šä¹‰ç±»æ—¶ï¼Œ ä½ é€šå¸¸å…ˆå¼€å§‹å®šä¹‰ init å’Œ str æ–¹æ³•ï¼š

\begin{lstlisting}
class Point:

    def __init__(self, x=0, y=0):
        self.x = x
        self.y = y

    def __str__(self):
        return '(%g, %g)' % (self.x, self.y)
\end{lstlisting}

%ğŸ% This is a lot of code to convey a small amount of information.
%ğŸ% Python provides a more concise way to say the same thing:

ä½†æ˜¯ç¼–å†™äº†è¿™ä¹ˆå¤šä»£ç ï¼Œ å´åªä¼ é€’äº†å¾ˆå°‘çš„ä¿¡æ¯ã€‚
Pythonæä¾›äº†ä¸€ä¸ªæ›´ç®€æ´çš„å®ç°æ–¹å¼ï¼š

\begin{lstlisting}
from collections import namedtuple
Point = namedtuple('Point', ['x', 'y'])
\end{lstlisting}

%ğŸ% The first argument is the name of the class you want to create.
%ğŸ% The second is a list of the attributes Point objects should have,
%ğŸ% as strings.  The return value from {\tt namedtuple} is a class object:
\index{namedtuple}
\index{object!namedtuple}
\index{collections}
\index{module!collections}

ç¬¬ä¸€ä¸ªå®å‚æ˜¯ä½ å¸Œæœ›åˆ›å»ºçš„ç±»çš„åç§°ã€‚ ç¬¬äºŒä¸ªå®å‚æ˜¯ \li{Point} å¯¹è±¡åº”è¯¥å…·å¤‡çš„å±æ€§åˆ—è¡¨ï¼Œ ä»¥å­—ç¬¦ä¸²çš„å½¢å¼æŒ‡å®šã€‚  \li{namedtuple} çš„è¿”å›å€¼æ˜¯ä¸€ä¸ªç±»å¯¹è±¡ï¼š

\begin{lstlisting}
>>> Point
<class '__main__.Point'>
\end{lstlisting}

%ğŸ% {\tt Point} automatically provides methods like \verb"__init__" and
%ğŸ% \verb"__str__" so you don't have to write them.
\index{class object}
\index{object!class}

è¿™é‡Œçš„ \li{Point} è‡ªåŠ¨æä¾›äº†åƒ \li{__init__} å’Œ \li{__str__} è¿™æ ·çš„æ–¹æ³•ï¼Œ ä½ æ²¡æœ‰å¿…é¡»å†è‡ªå·±ç¼–å†™ã€‚

%ğŸ% To create a Point object, you use the Point class as a function:

å¦‚æœæƒ³åˆ›å»ºä¸€ä¸ª \li{Point} å¯¹è±¡ï¼Œ ä½ å¯ä»¥å°† \li{Point} ç±»å½“ä½œå‡½æ•°ä½¿ç”¨ï¼š

\begin{lstlisting}
>>> p = Point(1, 2)
>>> p
Point(x=1, y=2)
\end{lstlisting}

%ğŸ% The init method assigns the arguments to attributes using the names
%ğŸ% you provided.  The str method prints a representation of the Point
%ğŸ% object and its attributes.

init æ–¹æ³•å°†å®å‚èµ‹å€¼ç»™ä½ æä¾›çš„å±æ€§ã€‚
str æ–¹æ³•æ‰“å° \li{Point} å¯¹è±¡çš„å­—ç¬¦ä¸²å‘ˆç°åŠå…¶å±æ€§ã€‚

%ğŸ% You can access the elements of the named tuple by name:

ä½ å¯ä»¥é€šè¿‡åç§°è®¿é—®å‘½ä»¤å…ƒç»„çš„å…ƒç´ ï¼š

\begin{lstlisting}
>>> p.x, p.y
(1, 2)
\end{lstlisting}

%ğŸ% But you can also treat a named tuple as a tuple:

ä½†æ˜¯ä½ ä¹Ÿå¯ä»¥æŠŠå‘½åå…ƒç»„å½“ä½œå…ƒç»„ä½¿ç”¨ï¼š

\begin{lstlisting}
>>> p[0], p[1]
(1, 2)

>>> x, y = p
>>> x, y
(1, 2)
\end{lstlisting}

%ğŸ% Named tuples provide a quick way to define simple classes.
%ğŸ% The drawback is that simple classes don't always stay simple.
%ğŸ% You might decide later that you want to add methods to a named tuple.
%ğŸ% In that case, you could define a new class that inherits from
%ğŸ% the named tuple:
\index{inheritance}

å‘½åå…ƒç»„æ˜¯å®šä¹‰ç®€å•ç±»çš„ä¸€ç§ä¾¿æ·æ–¹å¼ã€‚
ç¼ºç‚¹æ˜¯è¿™äº›ç®€å•ç±»ä¸ä¼šä¸€æˆä¸å˜ã€‚
ä¹‹åä½ å¯èƒ½ä¼šå‘ç°æƒ³è¦ç»™å‘½åå…ƒç»„æ·»åŠ æ›´å¤šçš„æ–¹æ³•ã€‚
åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œ ä½ å¯ä»¥å®šä¹‰ä¸€ä¸ªç»§æ‰¿è‡ªå‘½åå…ƒç»„çš„æ–°ç±»ï¼š

\begin{lstlisting}
class Pointier(Point):
    # add more methods here
\end{lstlisting}

%ğŸ% Or you could switch to a conventional class definition.

æˆ–è€…ä½¿ç”¨ä¼ ç»Ÿçš„ç±»å®šä¹‰æ–¹å¼ã€‚

%ğŸ% \section{Gathering keyword args}
\section{æ±‡é›†å…³é”®å­—å®å‚}

%ğŸ% In Section~\ref{gather}, we saw how to write a function that
%ğŸ% gathers its arguments into a tuple:
\index{gather}

åœ¨ \ref{gather} ä¸€èŠ‚ä¸­ï¼Œ æˆ‘ä»¬å­¦ä¹ äº†å¦‚ä½•ç¼–å†™ä¸€ä¸ªå°†å®å‚æ±‡é›†åˆ°å…ƒç»„çš„å‡½æ•°ï¼š

\begin{lstlisting}
def printall(*args):
    print(args)
\end{lstlisting}

%ğŸ% %
%ğŸ% You can call this function with any number of positional arguments
%ğŸ% (that is, arguments that don't have keywords):
\index{positional argument}
\index{argument!positional}

ä½ å¯ä»¥ä½¿ç”¨ä»»æ„æ•°é‡çš„ä½ç½®å®å‚(å³ä¸å¸¦å…³é”®å­—çš„å‚æ•°)è°ƒç”¨è¯¥å‡½æ•°ï¼š

\begin{lstlisting}
>>> printall(1, 2.0, '3')
(1, 2.0, '3')
\end{lstlisting}

%ğŸ% %
%ğŸ% But the {\tt *} operator doesn't gather keyword arguments:
\index{keyword argument}
\index{argument!keyword}

ä¸è¿‡ \li{*} æ˜Ÿå·æ“ä½œç¬¦æ— æ³•æ±‡é›†å…³é”®å­—å‚æ•°ï¼š

\begin{lstlisting}
>>> printall(1, 2.0, third='3')
TypeError: printall() got an unexpected keyword argument 'third'
\end{lstlisting}

%ğŸ% %
%ğŸ% To gather keyword arguments, you can use the {\tt **} operator:

å¦‚æœè¦æ±‡é›†å…³é”®å­—å‚æ•°ï¼Œä½ å¯ä»¥ä½¿ç”¨ \li{**} åŒæ˜Ÿå·æ“ä½œç¬¦ï¼š

\begin{lstlisting}
def printall(*args, **kwargs):
    print(args, kwargs)
\end{lstlisting}

%ğŸ% %
%ğŸ% You can call the keyword gathering parameter anything you want, but
%ğŸ% {\tt kwargs} is a common choice.  The result is a dictionary that maps
%ğŸ% keywords to values:

ä½ å¯ä»¥ç»™å…³é”®å­—æ±‡é›†å½¢å‚å–ä»»æ„çš„åç§°ï¼Œä½†æ˜¯ \li{kwargs} æ˜¯å¸¸ç”¨åã€‚
ä¸Šé¢å‡½æ•°çš„ç»“æœæ˜¯ä¸€ä¸ªå°†å…³é”®å­—æ˜ å°„è‡³å€¼çš„å­—å…¸ï¼š

\begin{lstlisting}
>>> printall(1, 2.0, third='3')
(1, 2.0) {'third': '3'}
\end{lstlisting}

%ğŸ% %
%ğŸ% If you have a dictionary of keywords and values, you can use the
%ğŸ% scatter operator, {\tt **} to call a function:
\index{scatter}

å¦‚æœä½ æœ‰ä¸€ä¸ªæœ‰å…³é”®å­—å’Œå€¼ç»„æˆçš„å­—å…¸ï¼Œ å¯ä»¥ä½¿ç”¨åˆ†æ•£æ“ä½œç¬¦(scatter operator) \li{**} è°ƒç”¨å‡½æ•°ï¼š

\begin{lstlisting}
>>> d = dict(x=1, y=2)
>>> Point(**d)
Point(x=1, y=2)
\end{lstlisting}

%ğŸ% %
%ğŸ% Without the scatter operator, the function would treat {\tt d} as
%ğŸ% a single positional argument, so it would assign {\tt d} to
%ğŸ% {\tt x} and complain because there's nothing to assign to {\tt y}:

å¦‚æœæ²¡æœ‰åˆ†æ•£æ“ä½œç¬¦ï¼Œ å‡½æ•°ä¼šå°† \li{d} è§†ä¸ºä¸€ä¸ªä½ç½®å®å‚ï¼Œ å› æ­¤ä¼šå°† \li{d} èµ‹å€¼ç»™ \li{x} å¹¶æŠ¥é”™ï¼Œ å› ä¸ºæ²¡æœ‰ç»™ \li{y} èµ‹å€¼ï¼š

\begin{lstlisting}
>>> d = dict(x=1, y=2)
>>> Point(d)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: __new__() missing 1 required positional argument: 'y'
\end{lstlisting}

%ğŸ% %
%ğŸ% When you are working with functions that have a large number of
%ğŸ% parameters, it is often useful to create and pass around dictionaries
%ğŸ% that specify frequently used options.

åœ¨å¤„ç†æœ‰å¤§é‡å½¢å‚çš„å‡½æ•°æ—¶ï¼Œ é€šå¸¸å¯ä»¥åˆ›å»ºæŒ‡å®šäº†å¸¸ç”¨é€‰é¡¹çš„å­—å…¸ï¼Œ å¹¶å°†å…¶ä¼ å…¥å‡½æ•°ã€‚

%ğŸ% \section{Glossary}
\section{æœ¯è¯­è¡¨}

\begin{description}

%ğŸ% \item[conditional expression:] An expression that has one of two
%ğŸ% values, depending on a condition.
\index{conditional expression}
\index{expression!conditional}

\item[æ¡ä»¶è¡¨è¾¾å¼ (conditional expression):]  æ ¹æ®æ¡ä»¶åœ¨ä¸¤ä¸ªå€¼ä¸­äºŒé€‰ä¸€çš„è¡¨è¾¾å¼ã€‚

%ğŸ% \item[list comprehension:] An expression with a {\tt for} loop in square
%ğŸ% brackets that yields a new list.
\index{list comprehension}

\item[åˆ—è¡¨æ¨å¯¼å¼ (list comprehension):]  ä½äºæ–¹æ‹¬å·ä¸­å¸¦ for å¾ªç¯çš„è¡¨è¾¾å¼ï¼Œ æœ€ç»ˆç”Ÿæˆä¸€ä¸ªæ–°åˆ—è¡¨ã€‚

%ğŸ% \item[generator expression:] An expression with a {\tt for} loop in
%ğŸ% parentheses that yields a generator object.
\index{generator expression}
\index{expression!generator}

\item[ç”Ÿæˆå™¨è¡¨è¾¾å¼ (generator expression):]  ä½äºåœ†æ‹¬å·ä¸­å¸¦ for å¾ªç¯çš„è¡¨è¾¾å¼ï¼Œ æœ€ç»ˆç”Ÿæˆä¸€ä¸ªç”Ÿæˆå™¨å¯¹è±¡ã€‚

%ğŸ% \item[multiset:] A mathematical entity that represents a mapping
%ğŸ% between the elements of a set and the number of times they appear.

\item[å¤šé‡é›† (multiset):]  ä¸€ä¸ªæ•°å­¦æ¦‚å¿µï¼Œ è¡¨ç¤ºä¸€ä¸ªé›†åˆçš„å…ƒç´ ä¸å„å…ƒç´ å‡ºç°æ¬¡æ•°ä¹‹é—´çš„æ˜ å°„ã€‚

%ğŸ% \item[factory:] A function, usually passed as a parameter, used to
%ğŸ% create objects.
\index{factory}

\item[å·¥å‚ (factory):]  ç”¨äºåˆ›å»ºå¯¹è±¡çš„å‡½æ•°ï¼Œ é€šå¸¸ä½œä¸ºå½¢å‚ä¼ å…¥ã€‚

\end{description}




%ğŸ% \section{Exercises}
\section{ç»ƒä¹ }

\begin{exercise}

%ğŸ% The following is a function computes the binomial
%ğŸ% coefficient recursively.

ä¸‹é¢æ˜¯ä¸€ä¸ªé€’å½’è®¡ç®—äºŒé¡¹å¼ç³»æ•° {\em (binomial coefficient)} çš„å‡½æ•°ã€‚

\begin{em}
\begin{lstlisting}
def binomial_coeff(n, k):
    """Compute the binomial coefficient "n choose k".

    n: number of trials
    k: number of successes

    returns: int
    """
    if k == 0:
        return 1
    if n == 0:
        return 0

    res = binomial_coeff(n-1, k) + binomial_coeff(n-1, k-1)
    return res
\end{lstlisting}
\end{em}

%ğŸ% Rewrite the body of the function using nested conditional
%ğŸ% expressions.

ä½¿ç”¨åµŒå¥—æ¡ä»¶è¡¨è¾¾å¼é‡å†™å‡½æ•°ä½“ã€‚

%ğŸ% One note: this function is not very efficient because it ends up computing
%ğŸ% the same values over and over.  You could make it more efficient by
%ğŸ% memoizing (see Section~\ref{memoize}).  But you will find that it's harder
%ğŸ% to memoize if you write it using conditional expressions.

æ³¨æ„ï¼š è¿™ä¸ªå‡½æ•°ä¸æ˜¯ç‰¹åˆ«é«˜æ•ˆï¼Œ å› ä¸ºå®ƒæœ€ååœ¨ä¸æ–­åœ°é‡å¤è®¡ç®—ç›¸åŒçš„å€¼ã€‚
ä½ å¯ä»¥é€šè¿‡å¤‡å¿˜å½•æ¨¡å¼\footnote{memoizingï¼Œä¹Ÿå¯ç†è§£ä¸ºç¼“å­˜} æ¥æé«˜æ•ˆç‡
(å‚è§ {\em \ref{memoize}}~èŠ‚)ã€‚
ä¸è¿‡ä½ ä¼šå‘ç°ï¼Œå¦‚æœä½¿ç”¨æ¡ä»¶è¡¨è¾¾å¼ï¼Œè¿›è¡Œç¼“å­˜çš„éš¾åº¦ä¼šæ›´å¤§ã€‚

\end{exercise}