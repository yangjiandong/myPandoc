

%ğŸ% \chapter{Classes and functions}
\chapter{ç±»å’Œå‡½æ•°}
\label{time}

%ğŸ% Now that we know how to create new types, the next
%ğŸ% step is to write functions that take programmer-defined objects
%ğŸ% as parameters and return them as results.  In this chapter I
%ğŸ% also present ``functional programming style'' and two new
%ğŸ% program development plans.

ç°åœ¨æˆ‘ä»¬å·²ç»çŸ¥é“å¦‚ä½•å»å®šä¹‰ä¸€ä¸ªæ–°çš„ç±»å‹ï¼Œä¸‹ä¸€æ­¥å°±æ˜¯ç¼–å†™ä»¥è‡ªå®šä¹‰å¯¹è±¡ä¸ºå‚æ•°çš„å‡½æ•°ï¼Œå¹¶è¿”å›è‡ªå®šä¹‰å¯¹è±¡ä½œä¸ºç»“æœã€‚åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘è¿˜å°†ä»‹ç»â€œå‡½æ•°å¼ç¼–ç¨‹é£æ ¼â€å’Œä¸¤ç§æ–°çš„ç¼–ç¨‹å¼€å‘æ–¹æ¡ˆã€‚

%ğŸ% Code examples from this chapter are available from
%ğŸ% \url{http://thinkpython2.com/code/Time1.py}.
%ğŸ% Solutions to the exercises are at
%ğŸ% \url{http://thinkpython2.com/code/Time1_soln.py}.

æœ¬ç« çš„ä»£ç ç¤ºä¾‹å¯ä»¥ä» \href{http://thinkpython2.com/code/Time1.py}{è¿™é‡Œ} ä¸‹è½½ã€‚  ç»ƒä¹ çš„ç­”æ¡ˆå¯ä»¥ä» \href{http://thinkpython2.com/code/Time1_soln.py}{è¿™é‡Œ} ä¸‹è½½ã€‚

%ğŸ% \section{Time}
\section{æ—¶é—´}
\label{isafter}

%ğŸ% As another example of a programmer-defined type, we'll define a class
%ğŸ% called {\tt Time} that records the time of day.  The class definition
%ğŸ% looks like this: \index{programmer-defined type}

å†ä¸¾ä¸€ä¾‹ç¨‹åºå‘˜è‡ªå®šä¹‰çš„ç±»å‹ï¼Œæˆ‘ä»¬å®šä¹‰ä¸€ä¸ªå« \li{Time} çš„ç±»ï¼Œç”¨äºè®°å½•æ—¶é—´ã€‚
è¿™ä¸ªç±»å°†å¦‚ä¸‹å®šä¹‰ï¼š
\index{type!programmer-defined} \index{Time class} \index{class!Time}

\begin{lstlisting}
class Time:
    """Represents the time of day.

    attributes: hour, minute, second
    """
\end{lstlisting}

%
%ğŸ% We can create a new {\tt Time} object and assign
%ğŸ% attributes for hours, minutes, and seconds:

æˆ‘ä»¬å¯ä»¥åˆ›å»ºä¸€ä¸ªæ–°çš„ \li{Time} ç±»å¯¹è±¡ï¼Œå¹¶ä¸”ç»™å®ƒçš„å±æ€§ \li{hour} ,
\li{minutes} å’Œ \li{seconds} èµ‹å€¼ï¼š

\begin{lstlisting}
time = Time()
time.hour = 11
time.minute = 59
time.second = 30
\end{lstlisting}

%
%ğŸ% The state diagram for the {\tt Time} object looks like Figure~\ref{fig.time}.

\li{Time} å¯¹è±¡çš„çŠ¶æ€å›¾ç±»ä¼¼äº å›¾~\ref{fig.time}ã€‚

\index{state diagram}  \index{diagram!state}
\index{object diagram}  \index{diagram!object}

%ğŸ% As an exercise, write a function called \verb"print_time" that takes a
%ğŸ% Time object and prints it in the form {\tt hour:minute:second}.
%ğŸ% Hint: the format sequence \verb"'%.2d'" prints an integer using
%ğŸ% at least two digits, including a leading zero if necessary.

æˆ‘ä»¬åšä¸ªç»ƒä¹ ï¼Œç¼–å†™ä¸€ä¸ªå«åš \li{print_time} çš„å‡½æ•°ï¼Œ
æ¥æ”¶ä¸€ä¸ª \li{Time} å¯¹è±¡å¹¶ç”¨ \li{æ—¶:åˆ†:ç§’} çš„æ ¼å¼æ‰“å°å®ƒã€‚
æç¤ºï¼šæ ¼å¼åŒ–åºåˆ— \li{%.2d} å¯ä»¥è‡³å°‘ä¸¤ä½æ•°çš„å½¢å¼æ‰“å°ä¸€ä¸ªæ•´æ•°ï¼Œå¦‚æœä¸è¶³åˆ™åœ¨å‰é¢è¡¥0ã€‚

%ğŸ% Write a boolean function called \verb"is_after" that
%ğŸ% takes two Time objects, {\tt t1} and {\tt t2}, and
%ğŸ% returns {\tt True} if {\tt t1} follows {\tt t2} chronologically and
%ğŸ% {\tt False} otherwise.  Challenge: don't use an {\tt if} statement.

ç¼–å†™ä¸€ä¸ªå«åš \li{is_after} çš„å¸ƒå°”å‡½æ•°ï¼Œæ¥æ”¶ä¸¤ä¸ª \li{Time}  å¯¹è±¡ï¼Œ \li{t1}  å’Œ \li{t2} ï¼Œè‹¥ \li{t1} çš„æ—¶é—´åœ¨ \li{t2} ä¹‹åï¼Œ
åˆ™è¿”å› \li{True} ï¼Œå¦åˆ™è¿”å› \li{False} ã€‚ æŒ‘æˆ˜ï¼šä¸è¦ä½¿ç”¨ \li{if} è¯­å¥ã€‚

\begin{figure}
\centerline
{\includegraphics[scale=0.8]{../source/figs/time.pdf}}
%ğŸ%\caption{Object diagram.}
\caption{å¯¹è±¡å›¾ã€‚}
\label{fig.time}
\end{figure}

%ğŸ% \section{Pure functions}
\section{çº¯å‡½æ•°}
\index{prototype and patch}  \index{development plan!prototype and patch}

%ğŸ% In the next few sections, we'll write two functions that add time
%ğŸ% values.  They demonstrate two kinds of functions: pure functions and
%ğŸ% modifiers.  They also demonstrate a development plan I'll call {\bf
%ğŸ%   prototype and patch}, which is a way of tackling a complex problem
%ğŸ% by starting with a simple prototype and incrementally dealing with the
%ğŸ% complications.
%ğŸ%
%ğŸ% Here is a simple prototype of \verb"add_time":

ä¸‹é¢å‡ èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†ç¼–å†™ä¸¤ä¸ªç”¨æ¥å¢åŠ æ—¶é—´å€¼çš„å‡½æ•°ã€‚
å®ƒä»¬å±•ç¤ºäº†ä¸¤ç§ä¸åŒçš„å‡½æ•°ï¼š {\em çº¯å‡½æ•°} (pure functions) å’Œ
{\em ä¿®æ”¹å™¨} (modifiers)ã€‚
å®ƒä»¬ä¹Ÿå±•ç¤ºäº†æˆ‘æ‰€ç§°çš„ {\em åŸå‹å’Œè¡¥ä¸} (prototype and patch) çš„å¼€å‘æ–¹æ¡ˆã€‚
è¿™æ˜¯ä¸€ç§å¤„ç†å¤æ‚é—®é¢˜çš„æ–¹æ³•ï¼Œ ä»ç®€å•çš„åŸå‹å¼€å§‹ï¼Œ é€æ­¥è§£å†³å¤æ‚æƒ…å†µã€‚

ä¸‹é¢æ˜¯ä¸€ä¸ªç®€å•çš„ \li{add_time} åŸå‹ï¼š

\begin{lstlisting}
def add_time(t1, t2):
    sum = Time()
    sum.hour = t1.hour + t2.hour
    sum.minute = t1.minute + t2.minute
    sum.second = t1.second + t2.second
    return sum
\end{lstlisting}

%ğŸ% %
%ğŸ% The function creates a new {\tt Time} object, initializes its
%ğŸ% attributes, and returns a reference to the new object.  This is called
%ğŸ% a {\bf pure function} because it does not modify any of the objects
%ğŸ% passed to it as arguments and it has no effect,
%ğŸ% like displaying a value or getting user input,
%ğŸ% other than returning a value.

è¿™ä¸ªå‡½æ•°åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„ \li{Time}
å¯¹è±¡ï¼Œåˆå§‹åŒ–äº†å¯¹è±¡çš„å±æ€§ï¼Œå¹¶è¿”å›äº†è¿™ä¸ªå¯¹è±¡çš„å¼•ç”¨ã€‚
æˆ‘ä»¬æŠŠè¿™ä¸ªå‡½æ•°ç§°ä¸º {\em çº¯å‡½æ•°} (pure function)ï¼Œ
å› ä¸ºå®ƒé™¤äº†è¿”å›ä¸€ä¸ªå€¼ä»¥å¤–ï¼Œ å¹¶ä¸ä¿®æ”¹ä½œä¸ºå‚æ•°ä¼ å…¥çš„ä»»ä½•å¯¹è±¡ï¼Œ
ä¹Ÿæ²¡æœ‰äº§ç”Ÿå¦‚æ˜¾ç¤ºä¸€ä¸ªå€¼æˆ–è€…è·å–ç”¨æˆ·è¾“å…¥çš„å½±å“ã€‚

\index{pure function}  \index{function type!pure}

%ğŸ% To test this function, I'll create two Time objects: {\tt start}
%ğŸ% contains the start time of a movie, like {\em Monty Python and the
%ğŸ% Holy Grail}, and {\tt duration} contains the run time of the movie,
%ğŸ% which is one hour 35 minutes.

\index{Monty Python and the Holy Grail}

%ğŸ% \verb"add_time" figures out when the movie will be done.

ä¸ºäº†æµ‹è¯•è¿™ä¸ªå‡½æ•°ï¼Œæˆ‘å°†åˆ›å»ºä¸¤ä¸ª \li{Time} å¯¹è±¡ï¼š \li{start} ç”¨äºå­˜æ”¾ä¸€ä¸ªç”µå½±
(å¦‚ Monty Python and the Holy Grail)çš„å¼€å§‹æ—¶é—´ï¼Œ \li{duration} ç”¨äºå­˜æ”¾ç”µå½±çš„æ”¾æ˜ æ—¶é•¿ï¼Œè¿™é‡Œæ—¶é•¿å®šä¸º 1 å°æ—¶ 35 åˆ†é’Ÿã€‚

\li{add_time} å°†è®¡ç®—ç”µå½±ä½•æ—¶ç»“æŸã€‚


\begin{lstlisting}
>>> start = Time()
>>> start.hour = 9
>>> start.minute = 45
>>> start.second =  0

>>> duration = Time()
>>> duration.hour = 1
>>> duration.minute = 35
>>> duration.second = 0

>>> done = add_time(start, duration)
>>> print_time(done)
10:80:00
\end{lstlisting}

%ğŸ% %
%ğŸ% The result, {\tt 10:80:00} might not be what you were hoping
%ğŸ% for.  The problem is that this function does not deal with cases where the
%ğŸ% number of seconds or minutes adds up to more than sixty.  When that
%ğŸ% happens, we have to ``carry'' the extra seconds into the minute column
%ğŸ% or the extra minutes into the hour column.
\index{carrying, addition with}

%ğŸ% Here's an improved version:

è¿™ä¸ªç»“æœ \li{10:80:00} å¯èƒ½ä¸æ˜¯ä½ æ‰€å¸Œæœ›å¾—åˆ°çš„ã€‚
é—®é¢˜åœ¨äºè¿™ä¸ªå‡½æ•°å¹¶æ²¡æœ‰å¤„ç†å¥½ç§’æ•°å’Œåˆ†é’Ÿæ•°ç›¸åŠ è¶…è¿‡60çš„æƒ…å†µã€‚
å½“å‘ç”Ÿè¿™ç§æƒ…å†µæ—¶ï¼Œæˆ‘ä»¬è¦æŠŠå¤šä½™çš„ç§’æ•°æ”¾è¿›åˆ†é’Ÿæ ï¼Œæˆ–è€…æŠŠå¤šä½™çš„åˆ†é’ŸåŠ è¿›å°æ—¶æ ã€‚

ä¸‹é¢æ˜¯ä¸€ä¸ªæ”¹è¿›çš„ç‰ˆæœ¬ï¼š

\begin{lstlisting}
def add_time(t1, t2):
    sum = Time()
    sum.hour = t1.hour + t2.hour
    sum.minute = t1.minute + t2.minute
    sum.second = t1.second + t2.second

    if sum.second >= 60:
        sum.second -= 60
        sum.minute += 1

    if sum.minute >= 60:
        sum.minute -= 60
        sum.hour += 1

    return sum
\end{lstlisting}

%ğŸ% %
%ğŸ% Although this function is correct, it is starting to get big.
%ğŸ% We will see a shorter alternative later.

è¿™ä¸ªå‡½æ•°è™½ç„¶æ­£ç¡®ï¼Œä½†æ˜¯å®ƒå¼€å§‹å˜å¾—è‡ƒè‚¿ã€‚æˆ‘ä»¬ä¼šåœ¨åé¢çœ‹åˆ°ä¸€ä¸ªè¾ƒçŸ­çš„ç‰ˆæœ¬ã€‚

%ğŸ% \section{Modifiers}
\section{ä¿®æ”¹å™¨}

\label{increment}
\index{modifier}  \index{function type!modifier}

%ğŸ% Sometimes it is useful for a function to modify the objects it gets as
%ğŸ% parameters.  In that case, the changes are visible to the caller.
%ğŸ% Functions that work this way are called {\bf modifiers}.ã€

æœ‰æ—¶å€™ç”¨å‡½æ•°ä¿®æ”¹ä½œä¸ºå‚æ•°ä¼ å…¥çš„å¯¹è±¡æ˜¯å¾ˆæœ‰ç”¨çš„ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œè¿™ç§æ”¹å˜å¯¹
è°ƒç”¨è€…æ¥è¯´æ˜¯å¯è§çš„ã€‚è¿™ç§æ–¹å¼å·¥ä½œçš„å‡½æ•°ç§°ä¸º {\em ä¿®æ”¹å™¨} (modifiers)ã€‚

\index{increment}

%ğŸ% {\tt increment}, which adds a given number of seconds to a {\tt Time}
%ğŸ% object, can be written naturally as a
%ğŸ% modifier.  Here is a rough draft:

å‡½æ•° \li{increment} ç»™ä¸€ä¸ª \li{Time} å¯¹è±¡å¢åŠ æŒ‡å®šçš„ç§’æ•°ï¼Œ
å¯ä»¥å¾ˆè‡ªç„¶åœ°ç”¨ä¿®æ”¹å™¨æ¥ç¼–å†™ã€‚  ä¸‹é¢æ˜¯ä¸€ä¸ªåŸå‹ï¼š

\begin{lstlisting}
def increment(time, seconds):
    time.second += seconds

    if time.second >= 60:
        time.second -= 60
        time.minute += 1

    if time.minute >= 60:
        time.minute -= 60
        time.hour += 1
\end{lstlisting}

%ğŸ% %
%ğŸ% The first line performs the basic operation; the remainder deals
%ğŸ% with the special cases we saw before.

ç¬¬ä¸€è¡Œè¿›è¡ŒåŸºç¡€æ“ä½œï¼›å…¶ä½™éƒ¨åˆ†çš„å¤„ç†åˆ™æ˜¯æˆ‘ä»¬ä¹‹å‰çœ‹åˆ°çš„ç‰¹æ®Šæƒ…å†µã€‚

\index{special case}

%ğŸ% Is this function correct?  What happens if {\tt seconds}
%ğŸ% is much greater than sixty?

è¿™ä¸ªå‡½æ•°æ­£ç¡®å—ï¼Ÿ å¦‚æœ \li{seconds} æ¯” 60 å¤§å¾ˆå¤šä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ

%ğŸ% In that case, it is not enough to carry once; we have to keep doing it
%ğŸ% until {\tt time.second} is less than sixty.  One solution is to
%ğŸ% replace the {\tt if} statements with {\tt while} statements.  That
%ğŸ% would make the function correct, but not very efficient.  As an
%ğŸ% exercise, write a correct version of {\tt increment} that doesn't
%ğŸ% contain any loops.

åœ¨é‚£ç§æƒ…å†µä¸‹ï¼Œåªè¿›ä½ä¸€æ¬¡æ˜¯ä¸å¤Ÿçš„ï¼›æˆ‘ä»¬è¦é‡å¤æ‰§è¡Œç›´åˆ° \li{seconds} å°äº 60ã€‚
ä¸€ç§æ–¹æ³•æ˜¯ç”¨ \li{while} è¯­å¥ä»£æ›¿ \li{if} è¯­å¥ã€‚
è¿™æ ·èƒ½å¤Ÿè®©å‡½æ•°æ­£ç¡®ï¼Œä½†æ˜¯å¹¶ä¸æ˜¯å¾ˆé«˜æ•ˆã€‚

%ğŸ% Anything that can be done with modifiers can also be done with pure
%ğŸ% functions.  In fact, some programming languages only allow pure
%ğŸ% functions.  There is some evidence that programs that use pure
%ğŸ% functions are faster to develop and less error-prone than programs
%ğŸ% that use modifiers.  But modifiers are convenient at times,
%ğŸ% and functional programs tend to be less efficient.

ä»»ä½•èƒ½å¤Ÿç”¨ä¿®æ”¹å™¨å®ç°çš„å‡½æ•°åŒæ ·èƒ½å¤Ÿç”¨çº¯å‡½æ•°å®ç°ã€‚
äº‹å®ä¸Šï¼Œä¸€äº›ç¼–ç¨‹è¯­è¨€åªå…è®¸ç”¨çº¯å‡½æ•°ã€‚
ä¸€äº›è¯æ®è¡¨æ˜ç”¨çº¯å‡½æ•°å®ç°çš„ç¨‹åºæ¯”ç”¨ä¿®æ”¹å™¨å®ç°çš„å‡½æ•°å¼€å‘æ›´å¿«ã€æ›´ä¸æ˜“å‡ºé”™ã€‚
ä½†æ˜¯æœ‰æ—¶å€™ä¿®æ”¹å™¨æ˜¯å¾ˆæ–¹ä¾¿çš„ï¼Œè€Œå‡½æ•°å¼ç¨‹åºæ•ˆç‡åè€Œä¸é«˜ã€‚

%ğŸ% In general, I recommend that you write pure functions whenever it is
%ğŸ% reasonable and resort to modifiers only if there is a compelling
%ğŸ% advantage.  This approach might be called a {\bf functional
%ğŸ% programming style}.

é€šå¸¸æ¥è¯´ï¼Œæˆ‘æ¨èåªè¦æ˜¯åˆç†çš„æƒ…å†µä¸‹ï¼Œéƒ½ä½¿ç”¨çº¯å‡½æ•°æ–¹å¼ç¼–å†™ï¼Œ
åªåœ¨æœ‰å®Œå…¨ä»¤äººä¿¡æœçš„åŸå› ä¸‹é‡‡ç”¨ä¿®æ”¹å™¨ã€‚
è¿™ç§æ–¹æ³•å¯ä»¥ç§°ä¸º {\em å‡½æ•°å¼ç¼–ç¨‹é£æ ¼} (functional programming style)ã€‚

\index{functional programming style}

%ğŸ% As an exercise, write a ``pure'' version of {\tt increment} that
%ğŸ% creates and returns a new Time object rather than modifying the
%ğŸ% parameter.

æˆ‘ä»¬åšä¸ªç»ƒä¹ ï¼Œç¼–å†™ä¸€ä¸ªçº¯å‡½æ•°ç‰ˆæœ¬çš„ \li{increment}  ï¼Œ
åˆ›å»ºå¹¶è¿”å›ä¸€ä¸ª \li{Time} å¯¹è±¡ï¼Œè€Œä¸æ˜¯ä¿®æ”¹å‚æ•°ã€‚


%ğŸ% \section{Prototyping versus planning}
\section{åŸå‹ {\em v.s.} æ–¹æ¡ˆ}

\label{prototype}
\index{prototype and patch}  \index{development plan!prototype and patch}
\index{planned development}  \index{development plan!designed}

%ğŸ% The development plan I am demonstrating is called ``prototype and
%ğŸ% patch''.  For each function, I wrote a prototype that performed the
%ğŸ% basic calculation and then tested it, patching errors along the
%ğŸ% way.

æˆ‘åˆšæ‰å±•ç¤ºçš„å¼€å‘æ–¹æ¡ˆå«åš {\em åŸå‹å’Œè¡¥ä¸} (protptype and patch) ã€‚
é’ˆå¯¹æ¯ä¸ªå‡½æ•°ï¼Œæˆ‘ç¼–å†™äº†ä¸€ä¸ªå¯ä»¥è¿›è¡ŒåŸºæœ¬è¿ç®—çš„åŸå‹å¹¶å¯¹å…¶æµ‹è¯•ï¼Œé€æ­¥ä¿®æ­£é”™è¯¯ã€‚

%ğŸ% This approach can be effective, especially if you don't yet have a
%ğŸ% deep understanding of the problem.  But incremental corrections can
%ğŸ% generate code that is unnecessarily complicated---since it deals with
%ğŸ% many special cases---and unreliable---since it is hard to know if you
%ğŸ% have found all the errors.

è¿™ç§æ–¹æ³•åœ¨ä½ å¯¹é—®é¢˜æ²¡æœ‰æ·±å…¥ç†è§£æ—¶ç‰¹åˆ«æœ‰æ•ˆã€‚ä½†å¢é‡ä¿®æ­£å¯èƒ½å¯¼è‡´ä»£ç è¿‡åº¦å¤æ‚ï¼Œ
å› ä¸ºéœ€è¦å¤„ç†è®¸å¤šç‰¹æ®Šæƒ…å†µã€‚ä¹Ÿå¹¶ä¸å¯é ï¼Œå› ä¸ºå¾ˆéš¾çŸ¥é“ä½ æ˜¯å¦å·²ç»æ‰¾åˆ°äº†æ‰€æœ‰çš„é”™è¯¯ã€‚

%ğŸ% An alternative is {\bf designed development}, in which high-level
%ğŸ% insight into the problem can make the programming much easier.  In
%ğŸ% this case, the insight is that a Time object is really a three-digit
%ğŸ% number in base 60 (see \url{http://en.wikipedia.org/wiki/Sexagesimal}.)!  The
%ğŸ% {\tt second} attribute is the ``ones column'', the {\tt minute}
%ğŸ% attribute is the ``sixties column'', and the {\tt hour} attribute is
%ğŸ% the ``thirty-six hundreds column''.
\index{sexagesimal}

å¦ä¸€ç§æ–¹æ³•å«åš {\em è®¾è®¡å¼€å‘} (designed development)ã€‚
å¯¹é—®é¢˜æœ‰é«˜å±‚æ¬¡çš„ç†è§£èƒ½å¤Ÿä½¿å¼€å‘å˜å¾—æ›´å®¹æ˜“ã€‚
è¿™ç»™æˆ‘ä»¬çš„å¯ç¤ºæ˜¯ï¼Œ\li{Time} å¯¹è±¡æœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªåŸºäºå…­åè¿›åˆ¶çš„ä¸‰ä½æ•°\footnote{å‚è€ƒ \href{http://en.wikipedia.org/wiki/Sexagesimal}{ç»´åŸºç™¾ç§‘} ã€‚}ï¼
å±æ€§ \li{second} æ˜¯``ä¸ªä½''ï¼Œå±æ€§ \li{minute} æ˜¯ ``å…­åä½''ï¼Œå±æ€§ \li{hour} æ˜¯ ``360ä½æ•°''ã€‚

%ğŸ% When we wrote \verb"add_time" and {\tt increment}, we were effectively
%ğŸ% doing addition in base 60, which is why we had to carry from one
%ğŸ% column to the next.
\index{carrying, addition with}
\index{ç»´åŸºç™¾ç§‘}

å½“æˆ‘ä»¬ç¼–å†™ \li{add_time} å’Œ \li{increment} æ—¶ï¼Œå…¶å®æ˜¯åœ¨åŸºäºå…­åè¿›åˆ¶ç´¯åŠ ï¼Œ
æ‰€ä»¥æˆ‘ä»¬éœ€è¦æŠŠä¸€ä½è¿›ä½åˆ°ä¸‹ä¸€ä½ã€‚

%ğŸ% This observation suggests another approach to the whole problem---we
%ğŸ% can convert Time objects to integers and take advantage of the fact
%ğŸ% that the computer knows how to do integer arithmetic.

è¿™ä¸ªè§‚å¯Ÿæ„å‘³ç€æˆ‘ä»¬å¯ä»¥ç”¨å¦ä¸€ç§æ–¹æ³•å»è§£å†³æ•´ä¸ªé—®é¢˜â€”â€”æˆ‘ä»¬å¯ä»¥æŠŠ
\li{Time} å¯¹è±¡è½¬æ¢ä¸ºæ•´æ•°ï¼Œå¹¶åˆ©ç”¨è®¡ç®—æœºçŸ¥é“å¦‚ä½•è¿›è¡Œæ•´æ•°è¿ç®—çš„è¿™ä¸ªäº‹å®ã€‚

%ğŸ% Here is a function that converts Times to integers:

ä¸‹é¢æ˜¯ä¸€ä¸ªæŠŠ \li{Time} å¯¹è±¡è½¬æˆæ•´æ•°çš„å‡½æ•°ï¼š

\begin{lstlisting}
def time_to_int(time):
    minutes = time.hour * 60 + time.minute
    seconds = minutes * 60 + time.second
    return seconds
\end{lstlisting}

%
%ğŸ% And here is a function that converts an integer to a Time
%ğŸ% (recall that {\tt divmod} divides the first argument by the second
%ğŸ% and returns the quotient and remainder as a tuple).
\index{divmod}

ä¸‹é¢åˆ™æ˜¯ä¸€ä¸ªæŠŠæ•´æ•°è½¬æ¢ä¸º \li{Time} å¯¹è±¡(å›å¿†ä¸€ä¸‹ \li{divmod} æ˜¯ç”¨ç¬¬ä¸€ä¸ªå‚æ•°é™¤ä»¥ç¬¬äºŒä¸ªå‚æ•°å¹¶ä»¥å…ƒç»„çš„å½¢å¼è¿”å›å•†å’Œä½™æ•°)ã€‚

\begin{lstlisting}
def int_to_time(seconds):
    time = Time()
    minutes, time.second = divmod(seconds, 60)
    time.hour, time.minute = divmod(minutes, 60)
    return time
\end{lstlisting}

%
%ğŸ% You might have to think a bit, and run some tests, to convince
%ğŸ% yourself that these functions are correct.  One way to test them is to
%ğŸ% check that \verb"time_to_int(int_to_time(x)) == x" for many values of
%ğŸ% {\tt x}.  This is an example of a consistency check.
\index{consistency check}

ä½ å¯èƒ½éœ€è¦æ€è€ƒä¸€ä¸‹ï¼Œå¹¶è¿è¡Œä¸€äº›æµ‹è¯•ï¼Œä»¥æ­¤æ¥è¯´æœè‡ªå·±è¿™äº›å‡½æ•°æ˜¯æ­£ç¡®çš„ã€‚
ä¸€ç§æµ‹è¯•æ–¹æ³•æ˜¯å¯¹å¾ˆå¤šçš„ \li{x} æ£€æŸ¥ \li{time_to_int(int_to_time(x)) == x}
æ˜¯å¦æ­£ç¡®ã€‚  è¿™æ˜¯ä¸€è‡´æ€§æ£€æŸ¥çš„ä¾‹å­ã€‚

%ğŸ% Once you are convinced they are correct, you can use them to
%ğŸ% rewrite \verb"add_time":

ä¸€æ—¦ä½ ç¡®ä¿¡å®ƒä»¬æ˜¯æ­£ç¡®çš„ï¼Œä½ å°±èƒ½ä½¿ç”¨å®ƒä»¬é‡å†™ \li{add_time} ï¼š

\begin{lstlisting}
def add_time(t1, t2):
    seconds = time_to_int(t1) + time_to_int(t2)
    return int_to_time(seconds)
\end{lstlisting}

%
%ğŸ% This version is shorter than the original, and easier to verify.  As
%ğŸ% an exercise, rewrite {\tt increment} using \verb"time_to_int" and
%ğŸ% \verb"int_to_time".

è¿™ä¸ªç‰ˆæœ¬æ¯”å…ˆå‰çš„è¦æ›´çŸ­ï¼Œæ›´å®¹æ˜“æ ¡éªŒã€‚
æˆ‘ä»¬å†åšä¸ªç»ƒä¹ ï¼Œä½¿ç”¨ \li{time_to_int} å’Œ \li{int_to_time}
é‡å†™ \li{increment} å‡½æ•°ã€‚

%ğŸ% In some ways, converting from base 60 to base 10 and back is harder
%ğŸ% than just dealing with times.  Base conversion is more abstract; our
%ğŸ% intuition for dealing with time values is better.

ä»æŸä¸ªæ–¹é¢æ¥è¯´ï¼Œå…­åè¿›åˆ¶å’Œåè¿›åˆ¶ç›¸äº’è½¬æ¢æ¯”å¤„ç†æ—¶é—´æ›´éš¾äº›ã€‚ è¿›åˆ¶è½¬æ¢æ›´åŠ æŠ½è±¡ï¼›
æˆ‘ä»¬è§£å†³æ—¶é—´å€¼çš„æƒ³æ³•æ˜¯æ›´å¥½çš„ã€‚

%ğŸ% But if we have the insight to treat times as base 60 numbers and make
%ğŸ% the investment of writing the conversion functions (\verb"time_to_int"
%ğŸ% and \verb"int_to_time"), we get a program that is shorter, easier to
%ğŸ% read and debug, and more reliable.

ä½†å¦‚æœæˆ‘ä»¬æ„è¯†åˆ°æŠŠæ—¶é—´å½“ä½œå…­åè¿›åˆ¶ï¼Œå¹¶é¢„å…ˆåšå¥½ç¼–å†™è½¬æ¢å‡½æ•° (\li{time_to_int}
å’Œ \li{int_to_time}) çš„å‡†å¤‡ï¼Œæˆ‘ä»¬å°±èƒ½è·å¾—ä¸€ä¸ªæ›´çŸ­ã€æ›´æ˜“è¯»ã€æ›´å¯é çš„ç¨‹åºã€‚

%ğŸ% It is also easier to add features later.  For example, imagine
%ğŸ% subtracting two Times to find the duration between them.  The
%ğŸ% naive approach would be to implement subtraction with borrowing.
%ğŸ% Using the conversion functions would be easier and more likely to be
%ğŸ% correct.

è¿™è®©æˆ‘ä»¬æ—¥åæ›´åŠ å®¹æ˜“æ·»åŠ å…¶å®ƒåŠŸèƒ½ã€‚ ä¾‹å¦‚ï¼Œè¯•æƒ³å°†ä¸¤ä¸ª \li{Time}
å¯¹è±¡ç›¸å‡æ¥è·å¾—å®ƒä»¬ä¹‹é—´çš„æ—¶é—´é—´éš”ã€‚
æœ€ç®€å•çš„æ–¹æ³•æ˜¯ä½¿ç”¨å€Ÿä½æ¥å®ç°å‡æ³•ã€‚ ä½¿ç”¨è½¬æ¢å‡½æ•°åˆ™æ›´å®¹æ˜“ï¼Œä¹Ÿæ›´å®¹æ˜“æ­£ç¡®ã€‚

\index{subtraction with borrowing}  \index{borrowing, subtraction with}
\index{generalization}

%ğŸ% Ironically, sometimes making a problem harder (or more general) makes it
%ğŸ% easier (because there are fewer special cases and fewer opportunities
%ğŸ% for error).

è®½åˆºçš„æ˜¯ï¼Œæœ‰æ—¶å€™æŠŠä¸€ä¸ªé—®é¢˜å˜å¾—æ›´éš¾(æˆ–æ›´åŠ æ™®é)åè€Œèƒ½è®©å®ƒæ›´åŠ ç®€å•
(å› ä¸ºä¼šæœ‰æ›´å°‘çš„ç‰¹æ®Šæƒ…å†µå’Œæ›´å°‘å‡ºé”™çš„æœºä¼š)ã€‚

%ğŸ% \section{Debugging}
\section{è°ƒè¯•}
\index{debugging}

%ğŸ% A Time object is well-formed if the values of {\tt minute} and {\tt
%ğŸ% second} are between 0 and 60 (including 0 but not 60) and if
%ğŸ% {\tt hour} is positive.  {\tt hour} and {\tt minute} should be
%ğŸ% integral values, but we might allow {\tt second} to have a
%ğŸ% fraction part.
\index{invariant}

å¦‚æœ \li{minute} å’Œ \li{second} çš„å€¼ä»‹äº 0 å’Œ 60 ä¹‹é—´
(åŒ…æ‹¬ 0 ä½†ä¸åŒ…æ‹¬ 60 )ï¼Œå¹¶ä¸” \li{hour} æ˜¯æ­£å€¼ï¼Œ é‚£ä¹ˆè¿™ä¸ª \li{Time}
å¯¹è±¡å°±æ˜¯åˆæ³•çš„ã€‚ \li{hour} å’Œ \li{minute} åº”è¯¥æ˜¯æ•´æ•°å€¼ï¼Œ
ä½†æˆ‘ä»¬å¯èƒ½ä¹Ÿå…è®¸  \li{second} æœ‰å°æ•°éƒ¨åˆ†ã€‚

%ğŸ% Requirements like these are called {\bf invariants} because
%ğŸ% they should always be true.  To put it a different way, if they
%ğŸ% are not true, something has gone wrong.

è¿™æ ·çš„è¦æ±‚ç§°ä¸º {\em ä¸å˜å¼} (invariants)ã€‚ å› ä¸ºå®ƒä»¬åº”å½“æ€»æ˜¯ä¸ºçœŸã€‚
æ¢å¥è¯è¯´ï¼Œå¦‚æœå®ƒä»¬ä¸ä¸ºçœŸï¼Œè‚¯å®šæ˜¯æŸäº›åœ°æ–¹å‡ºé”™äº†ã€‚

%ğŸ% Writing code to check invariants can help detect errors
%ğŸ% and find their causes.  For example, you might have a function
%ğŸ% like \verb"valid_time" that takes a Time object and returns
%ğŸ% {\tt False} if it violates an invariant:

ç¼–å†™ä»£ç æ¥æ£€æŸ¥ä¸å˜å¼èƒ½å¤Ÿå¸®åŠ©æ£€æµ‹é”™è¯¯å¹¶æ‰¾åˆ°å‡ºé”™çš„åŸå› ã€‚
ä¾‹å¦‚ï¼Œä½ å¯èƒ½ä¼šå†™ä¸€ä¸ª \li{valid_time} è¿™æ ·çš„å‡½æ•°ï¼Œ
æ¥å—ä¸€ä¸ª \li{Time} å¯¹è±¡ï¼Œå¹¶åœ¨è¿åä¸å˜å¼çš„æ¡ä»¶ä¸‹è¿”å› \li{False} ï¼š

\begin{lstlisting}
def valid_time(time):
    if time.hour < 0 or time.minute < 0 or time.second < 0:
        return False
    if time.minute >= 60 or time.second >= 60:
        return False
    return True
\end{lstlisting}

%
%ğŸ% At the beginning of each function you could check the
%ğŸ% arguments to make sure they are valid:

åœ¨æ¯ä¸ªå‡½æ•°çš„å¼€å¤´ï¼Œä½ å¯ä»¥æ£€æŸ¥å‚æ•°ï¼Œç¡®è®¤å®ƒä»¬æ˜¯å¦åˆæ³•ï¼š

\index{raise statement}  \index{statement!raise}

\begin{lstlisting}
def add_time(t1, t2):
    if not valid_time(t1) or not valid_time(t2):
        raise ValueError('invalid Time object in add_time')
    seconds = time_to_int(t1) + time_to_int(t2)
    return int_to_time(seconds)
\end{lstlisting}

%
%ğŸ% Or you could use an {\bf assert statement}, which checks a given invariant
%ğŸ% and raises an exception if it fails:
\index{assert statement}  \index{statement!assert}

æˆ–è€…ä½ å¯ä»¥ä½¿ç”¨ **assertè¯­å¥**ï¼Œæ£€æŸ¥ä¸€ä¸ªç»™å®šçš„ä¸å˜å¼å¹¶åœ¨å¤±è´¥çš„æƒ…å†µä¸‹æŠ›å‡ºå¼‚å¸¸ï¼š

\begin{lstlisting}
def add_time(t1, t2):
    assert valid_time(t1) and valid_time(t2)
    seconds = time_to_int(t1) + time_to_int(t2)
    return int_to_time(seconds)
\end{lstlisting}

%
%ğŸ% {\tt assert} statements are useful because they distinguish
%ğŸ% code that deals with normal conditions from code
%ğŸ% that checks for errors.

\li{assert} è¯­å¥éå¸¸æœ‰ç”¨ï¼Œå› ä¸ºå®ƒä»¬åŒºåˆ†äº†å¤„ç†æ™®é€šæ¡ä»¶çš„ä»£ç å’Œæ£€æŸ¥é”™è¯¯çš„ä»£ç ã€‚

%ğŸ% \section{Glossary}
\section{æœ¯è¯­è¡¨}

%ğŸ% \begin{description}
%ğŸ%
%ğŸ% \item[prototype and patch:] A development plan that involves
%ğŸ% writing a rough draft of a program, testing, and correcting errors as
%ğŸ% they are found.
%ğŸ% \index{prototype and patch}
%ğŸ%
%ğŸ% \item[designed development:] A development plan that involves
%ğŸ% high-level insight into the problem and more planning than incremental
%ğŸ% development or prototype development.
%ğŸ% \index{designed development}
%ğŸ%
%ğŸ% \item[pure function:] A function that does not modify any of the objects it
%ğŸ% receives as arguments.  Most pure functions are fruitful.
%ğŸ% \index{pure function}
%ğŸ%
%ğŸ% \item[modifier:] A function that changes one or more of the objects it
%ğŸ%   receives as arguments.  Most modifiers are void; that is, they
%ğŸ%   return {\tt None}.  \index{modifier}
%ğŸ%
%ğŸ% \item[functional programming style:] A style of program design in which the
%ğŸ% majority of functions are pure.
%ğŸ% \index{functional programming style}
%ğŸ%
%ğŸ% \item[invariant:] A condition that should always be true during the
%ğŸ% execution of a program.
%ğŸ% \index{invariant}
%ğŸ%
%ğŸ% \item[assert statement:] A statement that check a condition and raises
%ğŸ% an exception if it fails.
%ğŸ% \index{assert statement}
%ğŸ% \index{statement!assert}
%ğŸ%
%ğŸ% \end{description}

\begin{description}

\item[åŸå‹å’Œè¡¥ä¸ (prototype and patch):]
ä¸€ç§å¼€å‘æ–¹æ¡ˆï¼Œç¼–å†™ä¸€ä¸ªç¨‹åºçš„åˆç¨¿ï¼Œæµ‹è¯•ï¼Œå‘ç°é”™è¯¯æ—¶ä¿®æ­£å®ƒä»¬ã€‚
\index{prototype and patch}

\item[è®¾è®¡å¼€å‘ (designed development):]
ä¸€ç§å¼€å‘æ–¹æ¡ˆï¼Œéœ€è¦å¯¹é—®é¢˜æœ‰æ›´é«˜å±‚æ¬¡çš„ç†è§£ï¼Œæ¯”å¢é‡å¼€å‘æˆ–åŸå‹å¼€å‘æ›´æœ‰è®¡åˆ’æ€§ã€‚
\index{designed development}

\item[çº¯å‡½æ•° (pure function):] ä¸€ç§ä¸ä¿®æ”¹ä»»ä½•ä½œä¸ºå‚æ•°ä¼ å…¥çš„å¯¹è±¡çš„å‡½æ•°ã€‚å¤§éƒ¨åˆ†çº¯å‡½æ•°æ˜¯æœ‰è¿”å›å€¼çš„(fruitful)ã€‚
\index{pure function}

\item[ä¿®æ”¹å™¨ (modifier):]
ä¸€ç§ä¿®æ”¹ä¸€ä¸ªæˆ–å¤šä¸ªä½œä¸ºå‚æ•°ä¼ å…¥çš„å¯¹è±¡çš„å‡½æ•°ã€‚
å¤§éƒ¨åˆ†ä¿®æ”¹å™¨æ²¡æœ‰è¿”å›å€¼ï¼›å³è¿”å› \li{None}
\index{modifier}

\item[å‡½æ•°å¼ç¼–ç¨‹é£æ ¼ (functional programming style):]
ä¸€ç§ç¨‹åºè®¾è®¡é£æ ¼ï¼Œå¤§éƒ¨åˆ†å‡½æ•°ä¸ºçº¯å‡½æ•°ã€‚
\index{functional programming style}

\item[ä¸å˜å¼ (invariant):]
åœ¨ç¨‹åºæ‰§è¡Œè¿‡ç¨‹ä¸­æ€»æ˜¯ä¸ºçœŸçš„æ¡ä»¶ã€‚
\index{invariant}

\item[(assert statement):]
ä¸€ç§æ£€æŸ¥æ¡ä»¶æ˜¯å¦æ»¡è¶³å¹¶åœ¨å¤±è´¥çš„æƒ…å†µä¸‹æŠ›å‡ºå¼‚å¸¸çš„è¯­å¥ã€‚
\index{assert statement}  \index{statement!assert}

\end{description}

%ğŸ% \section{Exercises}
\section{ç»ƒä¹ }
%ğŸ% Code examples from this chapter are available from
%ğŸ% \url{http://thinkpython2.com/code/Time1.py}; solutions to the
%ğŸ% exercises are available from \url{http://thinkpython2.com/code/Time1_soln.py}.

æœ¬ç« çš„ä»£ç ç¤ºä¾‹å¯ä»¥åœ¨ \href{http://thinkpython2.com/code/Time1.py}{æ­¤å¤„}ä¸‹è½½ï¼›
ç»ƒä¹ çš„ç­”æ¡ˆå¯ä»¥åœ¨ \href{http://thinkpython2.com/code/Time1_soln.py}{æ­¤å¤„}ä¸‹è½½ã€‚

\begin{exercise}

%ğŸ% Write a function called \verb"mul_time" that takes a Time object
%ğŸ% and a number and returns a new Time object that contains
%ğŸ% the product of the original Time and the number.
%ğŸ%
%ğŸ% Then use \verb"mul_time" to write a function that takes a Time
%ğŸ% object that represents the finishing time in a race, and a number
%ğŸ% that represents the distance, and returns a Time object that represents
%ğŸ% the average pace (time per mile).
%ğŸ% \index{running pace}

ç¼–å†™ä¸€ä¸ªå«åš {\em \li{mul_time}} çš„å‡½æ•°ï¼Œæ¥æ”¶ä¸€ä¸ª {\em \li{Time}} å¯¹è±¡å’Œä¸€ä¸ªæ•°ï¼Œå¹¶è¿”å›ä¸€ä¸ªæ–°çš„ {\em \li{Time}} å¯¹è±¡ï¼ŒåŒ…å«åŸå§‹æ—¶é—´å’Œæ•°çš„ä¹˜ç§¯ã€‚

ç„¶åä½¿ç”¨ {\em \li{mul_time}} ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œæ¥å—ä¸€ä¸ªè¡¨ç¤ºæ¯”èµ›å®Œèµ›æ—¶é—´çš„ {\em \li{Time}} å¯¹è±¡ä»¥åŠä¸€ä¸ªè¡¨ç¤ºè·ç¦»çš„æ•°å­—ï¼Œå¹¶è¿”å›ä¸€ä¸ªç”¨äºè¡¨ç¤ºå¹³å‡é…é€Ÿ(æ¯è‹±é‡Œæ‰€éœ€æ—¶é—´)çš„ {\em \li{Time}} å¯¹è±¡ã€‚

\index{running pace}

\end{exercise}


\begin{exercise}
\index{datetime module}  \index{module!datetime}

%ğŸ% The {\tt datetime} module provides {\tt time} objects
%ğŸ% that are similar to the Time objects in this chapter, but
%ğŸ% they provide a rich set of methods and operators.  Read the
%ğŸ% documentation at \url{http://docs.python.org/3/library/datetime.html}.
%ğŸ%
%ğŸ% \begin{enumerate}
%ğŸ%
%ğŸ% \item Use the {\tt datetime} module to write a program that gets the
%ğŸ%   current date and prints the day of the week.
%ğŸ%
%ğŸ% \item Write a program that takes a birthday as input and prints the
%ğŸ%   user's age and the number of days, hours, minutes and seconds until
%ğŸ%   their next birthday.
%ğŸ% \index{birthday}
%ğŸ%
%ğŸ% \item For two people born on different days, there is a day when one
%ğŸ%   is twice as old as the other.  That's their Double Day.  Write a
%ğŸ%   program that takes two birthdays and computes their Double Day.
%ğŸ%
%ğŸ% \item For a little more challenge, write the more general version that
%ğŸ%   computes the day when one person is $n$ times older than the other.
%ğŸ% \index{Double Day}
%ğŸ%
%ğŸ% \end{enumerate}
%ğŸ%
%ğŸ% Solution: \url{http://thinkpython2.com/code/double.py}


{\em \li{datetime}} æ¨¡å—æä¾›çš„ {\em \li{time}} å¯¹è±¡ï¼Œ
å’Œæœ¬ç« çš„ {\em \li{Time}} å¯¹è±¡ç±»ä¼¼ï¼Œ ä½†å‰è€…æä¾›äº†æ›´ä¸°å¯Œçš„æ–¹æ³•å’Œæ“ä½œç¬¦ã€‚
å‚è€ƒé˜…è¯» \href{http://docs.python.org/3/library/datetime.html}{ç›¸å…³æ–‡æ¡£}ã€‚

\begin{enumerate}

\item ä½¿ç”¨ {\em \li{datetime}} æ¨¡å—æ¥ç¼–å†™ä¸€ä¸ªç¨‹åºï¼Œè·å–å½“å‰æ—¥æœŸå¹¶æ‰“å°å½“å¤©æ˜¯å‘¨å‡ ã€‚

\item ç¼–å†™ä¸€ä¸ªç¨‹åºï¼Œæ¥å—ä¸€ä¸ªç”Ÿæ—¥ä½œä¸ºè¾“å…¥ï¼Œå¹¶æ‰“å°ç”¨æˆ·çš„å¹´é¾„ä»¥åŠè·ç¦»ä¸‹ä¸ªç”Ÿæ—¥æ‰€éœ€è¦çš„å¤©æ•°ã€å°æ—¶æ•°ã€åˆ†é’Ÿæ•°å’Œç§’æ•°ã€‚

\item å¯¹äºä¸¤ä¸ªä¸åœ¨åŒä¸€å¤©å‡ºç”Ÿçš„äººæ¥è¯´ï¼Œæ€»æœ‰ä¸€å¤©ï¼Œä¸€ä¸ªäººçš„å‡ºç”Ÿå¤©æ•°æ˜¯å¦ä¸€ä¸ªäººçš„ä¸¤å€ã€‚
   æˆ‘ä»¬æŠŠè¿™ä¸€å¤©ç§°ä¸º ``åŒå€æ—¥''ã€‚  ç¼–å†™ä¸€ä¸ªç¨‹åºï¼Œæ¥å—ä¸¤ä¸ªä¸åŒçš„å‡ºç”Ÿæ—¥æœŸï¼Œå¹¶è®¡ç®—ä»–ä»¬çš„ ``åŒå€æ—¥''ã€‚

\item å†å¢åŠ ç‚¹æŒ‘æˆ˜ï¼Œç¼–å†™ä¸€ä¸ªæ›´é€šç”¨çš„ç‰ˆæœ¬ï¼Œç”¨äºè®¡ç®—ä¸€ä¸ªäººå‡ºç”Ÿå¤©æ•°æ˜¯å¦ä¸€ä¸ªäºº $n$ å€çš„æ—¥å­ã€‚

\end{enumerate}

\href{http://thinkpython2.com/code/double.py}{å‚è€ƒç­”æ¡ˆ}

\end{exercise}