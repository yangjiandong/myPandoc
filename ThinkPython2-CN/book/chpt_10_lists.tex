

%ğŸ% \chapter{Lists  |  åˆ—è¡¨}
\chapter{åˆ—è¡¨}

%ğŸ% This chapter presents one of Python's most useful built-in types, lists.
%ğŸ% You will also learn more about objects and what can happen when you have
%ğŸ% more than one name for the same object.

æœ¬ç« ä»‹ç»Pythonä¸­æœ€æœ‰ç”¨çš„å†…ç½®ç±»å‹ä¹‹ä¸€ï¼š{\em åˆ—è¡¨} (list)ã€‚  ä½ è¿˜å°†è¿›ä¸€æ­¥å­¦ä¹ å…³äºå¯¹è±¡çš„çŸ¥è¯†ä»¥åŠåŒä¸€ä¸ªå¯¹è±¡æ‹¥æœ‰å¤šä¸ªåç§°æ—¶ä¼šå‘ç”Ÿä»€ä¹ˆã€‚

%ğŸ% \section{A list is a sequence  |  åˆ—è¡¨æ˜¯ä¸€ä¸ªåºåˆ—}
\section{åˆ—è¡¨æ˜¯ä¸€ä¸ªåºåˆ—}
\label{sequence}

%ğŸ% Like a string, a {\bf list} is a sequence of values.  In a string, the
%ğŸ% values are characters; in a list, they can be any type.  The values in
%ğŸ% a list are called {\bf elements} or sometimes {\bf items}.

ä¸å­—ç¬¦ä¸²ç±»ä¼¼ï¼Œ {\em åˆ—è¡¨} æ˜¯ç”±å¤šä¸ªå€¼ç»„æˆçš„åºåˆ—ã€‚  åœ¨å­—ç¬¦ä¸²ä¸­ï¼Œ æ¯ä¸ªå€¼éƒ½æ˜¯å­—ç¬¦ï¼›
åœ¨åˆ—è¡¨ä¸­ï¼Œ å€¼å¯ä»¥æ˜¯ä»»ä½•æ•°æ®ç±»å‹ã€‚  åˆ—è¡¨ä¸­çš„å€¼ç§°ä¸º {\em å…ƒç´ } (element) ï¼Œ æœ‰æ—¶ä¹Ÿè¢«ç§°ä¸º {\em é¡¹} (item)ã€‚

\index{list}  \index{type!list}
\index{element}  \index{sequence}
\index{item}

%ğŸ% There are several ways to create a new list; the simplest is to
%ğŸ% enclose the elements in square brackets (\verb"[" and \verb"]"):

åˆ›å»ºæ–°åˆ—è¡¨çš„æ–¹æ³•æœ‰å¤šç§ï¼›æœ€ç®€å•çš„æ–¹æ³•æ˜¯ç”¨æ–¹æ‹¬å·( \li{[} å’Œ \li{]} )å°†å…ƒç´ åŒ…æ‹¬èµ·æ¥:

\begin{lstlisting}
[10, 20, 30, 40]
['crunchy frog', 'ram bladder', 'lark vomit']
\end{lstlisting}

%
%ğŸ% The first example is a list of four integers.  The second is a list of
%ğŸ% three strings.  The elements of a list don't have to be the same type.
%ğŸ% The following list contains a string, a float, an integer, and
%ğŸ% (lo!) another list:

ç¬¬ä¸€ä¸ªä¾‹å­æ˜¯åŒ…å« 4 ä¸ªæ•´æ•°çš„åˆ—è¡¨ã€‚
ç¬¬äºŒä¸ªæ˜¯åŒ…å« 3 ä¸ªå­—ç¬¦ä¸²çš„åˆ—è¡¨ã€‚
ä¸€ä¸ªåˆ—è¡¨ä¸­çš„å…ƒç´ ä¸éœ€è¦æ˜¯ç›¸åŒçš„æ•°æ®ç±»å‹ã€‚
ä¸‹é¢çš„åˆ—è¡¨åŒ…å«ä¸€ä¸ªå­—ç¬¦ä¸²ã€ä¸€ä¸ªæµ®ç‚¹æ•°ã€ä¸€ä¸ªæ•´æ•°å’Œå¦ä¸€ä¸ªåˆ—è¡¨ï¼š

\begin{lstlisting}
['spam', 2.0, 5, [10, 20]]
\end{lstlisting}

%
%ğŸ% A list within another list is {\bf nested}.

ä¸€ä¸ªåˆ—è¡¨åœ¨å¦ä¸€ä¸ªåˆ—è¡¨ä¸­ï¼Œ ç§°ä¸º {\em åµŒå¥—\footnote{nested}åˆ—è¡¨}ã€‚
\index{nested list}  \index{list!nested}

%ğŸ% A list that contains no elements is
%ğŸ% called an empty list; you can create one with empty
%ğŸ% brackets, \verb"[]".

ä¸€ä¸ªä¸åŒ…å«å…ƒç´ çš„åˆ—è¡¨è¢«ç§°ä¸ºç©ºåˆ—è¡¨ï¼›ä½ å¯ä»¥ç”¨ç©ºçš„æ–¹æ‹¬å· \li{[]} åˆ›å»ºä¸€ä¸ªç©ºåˆ—è¡¨ã€‚

\index{empty list}  \index{list!empty}

%ğŸ% As you might expect, you can assign list values to variables:

æ­£å¦‚ä½ æƒ³çš„é‚£æ ·ï¼Œ ä½ å¯ä»¥å°†åˆ—è¡¨çš„å€¼èµ‹ç»™å˜é‡ï¼š

\begin{lstlisting}
>>> cheeses = ['Cheddar', 'Edam', 'Gouda']
>>> numbers = [42, 123]
>>> empty = []
>>> print(cheeses, numbers, empty)
['Cheddar', 'Edam', 'Gouda'] [42, 123] []
\end{lstlisting}
%
\index{assignment}

%ğŸ% \section{Lists are mutable  |  åˆ—è¡¨æ˜¯å¯å˜çš„}
\section{åˆ—è¡¨æ˜¯å¯å˜çš„}
\label{mutable}
\index{list!element}  \index{access}
\index{index}  \index{bracket operator}
\index{operator!bracket}

%ğŸ% The syntax for accessing the elements of a list is the same as for
%ğŸ% accessing the characters of a string---the bracket operator.  The
%ğŸ% expression inside the brackets specifies the index.  Remember that the
%ğŸ% indices start at 0:

è®¿é—®åˆ—è¡¨ä¸­å…ƒç´ çš„è¯­æ³•ï¼Œ ä¸è®¿é—®å­—ç¬¦ä¸²ä¸­å­—ç¬¦çš„è¯­æ³•ç›¸åŒï¼Œ éƒ½æ˜¯é€šè¿‡æ–¹æ‹¬å·è¿ç®—ç¬¦å®ç°çš„ã€‚
æ‹¬å·ä¸­çš„è¡¨è¾¾å¼æŒ‡å®šäº†å…ƒç´ çš„ç´¢å¼•ã€‚
è®°ä½ï¼Œ ç´¢å¼•ä»0å¼€å§‹ï¼š

\begin{lstlisting}
>>> cheeses[0]
'Cheddar'
\end{lstlisting}

%
%ğŸ% Unlike strings, lists are mutable.  When the bracket operator appears
%ğŸ% on the left side of an assignment, it identifies the element of the
%ğŸ% list that will be assigned.

å’Œå­—ç¬¦ä¸²ä¸åŒçš„æ˜¯ï¼Œ åˆ—è¡¨æ˜¯å¯å˜çš„ã€‚
å½“æ‹¬å·è¿ç®—ç¬¦å‡ºç°åœ¨èµ‹å€¼è¯­å¥çš„å·¦è¾¹æ—¶ï¼Œ å®ƒå°±æŒ‡å‘äº†åˆ—è¡¨ä¸­å°†è¢«èµ‹å€¼çš„å…ƒç´ ã€‚

\index{mutability}

\begin{lstlisting}
>>> numbers = [42, 123]
>>> numbers[1] = 5
>>> numbers
[42, 5]
\end{lstlisting}

%
%ğŸ% The one-eth element of {\tt numbers}, which
%ğŸ% used to be 123, is now 5.

\li{numbers} ä¸­ç´¢å¼•ä¸º 1 çš„å…ƒç´ ï¼Œ åŸæ¥æ˜¯ 123ï¼Œ ç°åœ¨å˜æˆäº† 5ã€‚
\index{index!starting at zero}  \index{zero, index starting at}

%ğŸ% Figure~\ref{fig.liststate} shows the state diagram for {\tt
%ğŸ% cheeses}, {\tt numbers} and {\tt empty}:
\index{state diagram}  \index{diagram!state}

å›¾~\ref{fig.liststate} å±•ç¤ºäº† \li{cheeses} ã€ \li{nubmers} å’Œ \li{empty} çš„çŠ¶æ€å›¾ã€‚

\begin{figure}
\centerline
{\includegraphics[scale=0.9]{../source/figs/liststate.pdf}}
% \caption{State diagram.}
\caption{çŠ¶æ€å›¾ã€‚  }
\label{fig.liststate}
\end{figure}

%ğŸ% Lists are represented by boxes with the word ``list'' outside
%ğŸ% and the elements of the list inside.  {\tt cheeses} refers to
%ğŸ% a list with three elements indexed 0, 1 and 2.
%ğŸ% {\tt numbers} contains two elements; the diagram shows that the
%ğŸ% value of the second element has been reassigned from 123 to 5.
%ğŸ% {\tt empty} refers to a list with no elements.
\index{item assignment}  \index{assignment!item}
\index{reassignment}

åˆ—è¡¨ç”¨å¤–éƒ¨æ ‡æœ‰ ``list'' çš„ç›’å­è¡¨ç¤ºï¼Œ ç›’å­å†…éƒ¨æ˜¯åˆ—è¡¨çš„å…ƒç´ ã€‚  \li{cheeses} æŒ‡å‘ä¸€ä¸ªæœ‰3ä¸ªå…ƒç´ çš„åˆ—è¡¨ï¼Œ 3ä¸ªå…ƒç´ çš„ä¸‹æ ‡åˆ†åˆ«æ˜¯0ã€1ã€2ã€‚  \li{numbers} åŒ…å«ä¸¤ä¸ªå…ƒç´ ï¼›
çŠ¶æ€å›¾æ˜¾ç¤ºç¬¬äºŒä¸ªå…ƒç´ åŸæ¥æ˜¯123ï¼Œ è¢«é‡æ–°èµ‹å€¼ä¸º5ã€‚  \li{empty} å¯¹åº”ä¸€ä¸ªæ²¡æœ‰å…ƒç´ çš„åˆ—è¡¨ã€‚

%ğŸ% List indices work the same way as string indices:

åˆ—è¡¨ä¸‹æ ‡çš„å·¥ä½œåŸç†å’Œå­—ç¬¦ä¸²ä¸‹æ ‡ç›¸åŒï¼š

%ğŸ% \begin{itemize}
%ğŸ%
%ğŸ% \item Any integer expression can be used as an index.
%ğŸ%
%ğŸ% \item If you try to read or write an element that does not exist, you
%ğŸ% get an {\tt IndexError}.
%ğŸ% \index{exception!IndexError}  \index{IndexError}
%ğŸ%
%ğŸ% \item If an index has a negative value, it counts backward from the
%ğŸ% end of the list.
%ğŸ%
%ğŸ% \end{itemize}

\begin{itemize}

\item ä»»ä½•æ•´æ•°è¡¨è¾¾å¼éƒ½å¯ä»¥ç”¨ä½œä¸‹æ ‡ã€‚

\item å¦‚æœä½ è¯•å›¾è¯»æˆ–å†™ä¸€ä¸ªä¸å­˜åœ¨çš„å…ƒç´ ï¼Œ ä½ å°†ä¼šå¾—åˆ°ä¸€ä¸ª {\em ç´¢å¼•é”™è¯¯ \footnote{ \li{IndexError}}}ã€‚
\index{exception!IndexError}  \index{IndexError}

\item å¦‚æœä¸‹æ ‡æ˜¯è´Ÿæ•°ï¼Œ å®ƒå°†ä»åˆ—è¡¨çš„æœ«ç«¯å¼€å§‹è®¿é—®åˆ—è¡¨ã€‚

\end{itemize}
\index{list!index}  \index{list!membership}
\index{membership!list}  \index{in operator}
\index{operator!in}

%ğŸ% The {\tt in} operator also works on lists.

\li{in} è¿ç®—ç¬¦åœ¨åˆ—è¡¨ä¸­åŒæ ·å¯ä»¥ä½¿ç”¨ã€‚

\begin{lstlisting}
>>> cheeses = ['Cheddar', 'Edam', 'Gouda']
>>> 'Edam' in cheeses
True
>>> 'Brie' in cheeses
False
\end{lstlisting}


%ğŸ% \section{Traversing a list  |  åˆ—è¡¨éå†}
\section{åˆ—è¡¨éå†}
\index{list!traversal}  \index{traversal!list}
\index{for loop}  \index{loop!for}
\index{statement!for}
\index{åˆ—è¡¨!éå†}  \index{éå†!åˆ—è¡¨}
\index{for å¾ªç¯}  \index{å¾ªç¯!for}
\index{è¯­å¥!for}

%ğŸ% The most common way to traverse the elements of a list is
%ğŸ% with a {\tt for} loop.  The syntax is the same as for strings:

æœ€å¸¸ç”¨çš„éå†åˆ—è¡¨çš„æ–¹å¼æ˜¯ä½¿ç”¨ \li{for} å¾ªç¯ã€‚  è¯­æ³•å’Œå­—ç¬¦ä¸²éå†ç±»ä¼¼ï¼š

\begin{lstlisting}
for cheese in cheeses:
    print(cheese)
\end{lstlisting}

%
%ğŸ% This works well if you only need to read the elements of the
%ğŸ% list.  But if you want to write or update the elements, you
%ğŸ% need the indices.  A common way to do that is to combine
%ğŸ% the built-in functions {\tt range} and {\tt len}:

å¦‚æœä½ åªéœ€è¦è¯»å–åˆ—è¡¨ä¸­çš„å…ƒç´ ï¼Œ è¿™ç§æ–¹æ³•å·²ç»è¶³å¤Ÿã€‚  ç„¶è€Œï¼Œ å¦‚æœä½ æƒ³è¦å†™å…¥æˆ–è€…æ›´æ–°åˆ—è¡¨ä¸­çš„å…ƒç´ ï¼Œ ä½ éœ€è¦é€šè¿‡ä¸‹æ ‡è®¿é—®ã€‚  ä¸€ç§å¸¸ç”¨çš„æ–¹æ³•æ˜¯ç»“åˆå†…ç½®å‡½æ•° \li{range} å’Œ \li{len} ï¼š
\index{å¾ªç¯!ä½¿ç”¨ç´¢å¼•}  \index{ç´¢å¼•!æ§åˆ¶å¾ªç¯}

\begin{lstlisting}
for i in range(len(numbers)):
    numbers[i] = numbers[i] * 2
\end{lstlisting}

%
%ğŸ% This loop traverses the list and updates each element.  {\tt len}
%ğŸ% returns the number of elements in the list.  {\tt range} returns
%ğŸ% a list of indices from 0 to $n-1$, where $n$ is the length of
%ğŸ% the list.  Each time through the loop {\tt i} gets the index
%ğŸ% of the next element.  The assignment statement in the body uses
%ğŸ% {\tt i} to read the old value of the element and to assign the
%ğŸ% new value.

è¿™ä¸ªå¾ªç¯å°†éå†åˆ—è¡¨å¹¶æ›´æ–°æ¯ä¸ªå…ƒç´ ã€‚  \li{len} è¿”å›åˆ—è¡¨ä¸­çš„å…ƒç´ ä¸ªæ•°ã€‚  \li{range} è¿”å›ä¸€ä¸ªåŒ…å«ä» 0 åˆ° $n-1$ ä¸‹æ ‡çš„åˆ—è¡¨ï¼Œ å…¶ä¸­ $n$ æ˜¯åˆ—è¡¨çš„é•¿åº¦ã€‚
æ¯æ¬¡å¾ªç¯ä¸­ï¼Œ \li{i} å¾—åˆ°ä¸‹ä¸€ä¸ªå…ƒç´ çš„ä¸‹æ ‡ã€‚  å¾ªç¯ä¸»ä½“ä¸­çš„èµ‹å€¼è¯­å¥ä½¿ç”¨ \li{i} è¯»å–è¯¥å…ƒç´ çš„æ—§å€¼ï¼Œ å¹¶èµ‹äºˆå…¶ä¸€ä¸ªæ–°å€¼ã€‚
\index{item update}  \index{update!item}

%ğŸ% A {\tt for} loop over an empty list never runs the body:

å¯¹ä¸€ä¸ªç©ºåˆ—è¡¨æ‰§è¡Œ \li{for} å¾ªç¯æ—¶ï¼Œ å°†ä¸ä¼šæ‰§è¡Œå¾ªç¯çš„ä¸»ä½“ï¼š

\begin{lstlisting}
for x in []:
    print('This never happens.')
\end{lstlisting}

%
%ğŸ% Although a list can contain another list, the nested
%ğŸ% list still counts as a single element.  The length of this list is
%ğŸ% four:

å°½ç®¡ä¸€ä¸ªåˆ—è¡¨å¯ä»¥åŒ…å«å¦ä¸€ä¸ªåˆ—è¡¨ï¼Œ åµŒå¥—çš„åˆ—è¡¨æœ¬èº«è¿˜æ˜¯è¢«çœ‹ä½œä¸€ä¸ªå•ä¸ªå…ƒç´ ã€‚
ä¸‹é¢è¿™ä¸ªåˆ—è¡¨çš„é•¿åº¦æ˜¯4ï¼š
\index{nested list}  \index{list!nested}

\begin{lstlisting}
['spam', 1, ['Brie', 'Roquefort', 'Pol le Veq'], [1, 2, 3]]
\end{lstlisting}


%ğŸ% \section{List operations  |  åˆ—è¡¨æ“ä½œ}
\section{åˆ—è¡¨æ“ä½œ}
\index{list!operation}

%ğŸ% The {\tt +} operator concatenates lists:

{\em åŠ å·è¿ç®—ç¬¦}\li{+} æ‹¼æ¥å¤šä¸ªåˆ—è¡¨ï¼š

\index{concatenation!list}  \index{list!concatenation}

\begin{lstlisting}
>>> a = [1, 2, 3]
>>> b = [4, 5, 6]
>>> c = a + b
>>> c
[1, 2, 3, 4, 5, 6]
\end{lstlisting}

%
%ğŸ% The {\tt *} operator repeats a list a given number of times:

{\em ä¹˜å·è¿ç®—ç¬¦} \li{*} ä»¥ç»™å®šæ¬¡æ•°çš„é‡å¤ä¸€ä¸ªåˆ—è¡¨:
\index{repetition!list}  \index{list!repetition}

\begin{lstlisting}
>>> [0] * 4
[0, 0, 0, 0]
>>> [1, 2, 3] * 3
[1, 2, 3, 1, 2, 3, 1, 2, 3]
\end{lstlisting}

%
%ğŸ% The first example repeats {\tt [0]} four times.  The second example
%ğŸ% repeats the list {\tt [1, 2, 3]} three times.

ç¬¬ä¸€ä¸ªä¾‹å­é‡å¤ 4 æ¬¡ã€‚  ç¬¬äºŒä¸ªä¾‹å­é‡å¤äº†é‚£ä¸ªåˆ—è¡¨ 3 æ¬¡ã€‚

%ğŸ% \section{List slices  |  åˆ—è¡¨åˆ‡ç‰‡}
\section{åˆ—è¡¨åˆ‡ç‰‡}
\index{slice operator}  \index{operator!slice}  \index{index!slice}
\index{list!slice}  \index{slice!list}

%ğŸ% The slice operator also works on lists:

{\em åˆ‡ç‰‡} (slice) è¿ç®—ç¬¦åŒæ ·é€‚ç”¨äºåˆ—è¡¨ï¼š


\begin{lstlisting}
>>> t = ['a', 'b', 'c', 'd', 'e', 'f']
>>> t[1:3]
['b', 'c']
>>> t[:4]
['a', 'b', 'c', 'd']
>>> t[3:]
['d', 'e', 'f']
\end{lstlisting}
%
%ğŸ% If you omit the first index, the slice starts at the beginning.
%ğŸ% If you omit the second, the slice goes to the end.  So if you
%ğŸ% omit both, the slice is a copy of the whole list.

å¦‚æœä½ çœç•¥ç¬¬ä¸€ä¸ªç´¢å¼•ï¼Œ åˆ‡ç‰‡å°†ä»åˆ—è¡¨å¤´å¼€å§‹ã€‚  å¦‚æœä½ çœç•¥ç¬¬äºŒä¸ªç´¢å¼•ï¼Œ åˆ‡ç‰‡å°†ä¼šåˆ°åˆ—è¡¨å°¾ç»“æŸã€‚
æ‰€ä»¥å¦‚æœä½ ä¸¤è€…éƒ½çœç•¥ï¼Œ åˆ‡ç‰‡å°±æ˜¯æ•´ä¸ªåˆ—è¡¨çš„ä¸€ä¸ªæ‹·è´ã€‚
\index{list!copy}  \index{slice!copy}
\index{copy!slice}

\begin{lstlisting}
>>> t[:]
['a', 'b', 'c', 'd', 'e', 'f']
\end{lstlisting}

%
%ğŸ% Since lists are mutable, it is often useful to make a copy
%ğŸ% before performing operations that modify lists.

ç”±äºåˆ—è¡¨æ˜¯å¯å˜çš„ï¼Œ é€šå¸¸åœ¨ä¿®æ”¹åˆ—è¡¨ä¹‹å‰ï¼Œ å¯¹åˆ—è¡¨è¿›è¡Œæ‹·è´æ˜¯å¾ˆæœ‰ç”¨çš„ã€‚
\index{mutability}

%ğŸ% A slice operator on the left side of an assignment
%ğŸ% can update multiple elements:

åˆ‡ç‰‡è¿ç®—ç¬¦æ”¾åœ¨èµ‹å€¼è¯­å¥çš„å·¦è¾¹æ—¶ï¼Œ å¯ä»¥ä¸€æ¬¡æ›´æ–°å¤šä¸ªå…ƒç´ ï¼š
\index{slice!update}  \index{update!slice}

\begin{lstlisting}
>>> t = ['a', 'b', 'c', 'd', 'e', 'f']
>>> t[1:3] = ['x', 'y']
>>> t
['a', 'x', 'y', 'd', 'e', 'f']
\end{lstlisting}

%

% You can add elements to a list by squeezing them into an empty
% slice:

% % \begin{lstlisting}
% >>> t = ['a', 'd', 'e', 'f']
% >>> t[1:1] = ['b', 'c']
% >>> print t
% ['a', 'b', 'c', 'd', 'e', 'f']
% \end{lstlisting}
% \afterverb
%
% And you can remove elements from a list by assigning the empty list to
% them:

% % \begin{lstlisting}
% >>> t = ['a', 'b', 'c', 'd', 'e', 'f']
% >>> t[1:3] = []
% >>> print t
% ['a', 'd', 'e', 'f']
% \end{lstlisting}
% \afterverb
%
% But both of those operations can be expressed more clearly
% with list methods.


%ğŸ% \section{List methods  |  åˆ—è¡¨æ–¹æ³•}
\section{åˆ—è¡¨æ–¹æ³•}
\index{list!method}
\index{method, list}

%ğŸ% Python provides methods that operate on lists.  For example,
%ğŸ% {\tt append} adds a new element to the end of a list:

Pythonä¸ºåˆ—è¡¨æä¾›äº†ä¸€äº›æ–¹æ³•. ä¾‹å¦‚, \li{append} æ·»åŠ ä¸€ä¸ªæ–°å…ƒç´ åˆ°åˆ—è¡¨çš„æœ«ç«¯:

\index{append method}  \index{method!append}

\begin{lstlisting}
>>> t = ['a', 'b', 'c']
>>> t.append('d')
>>> t
['a', 'b', 'c', 'd']
\end{lstlisting}
%
%ğŸ% {\tt extend} takes a list as an argument and appends all of
%ğŸ% the elements:

\li{extend} å°†æ¥å—ä¸€ä¸ªåˆ—è¡¨ä½œä¸ºå‚æ•°ï¼Œ å¹¶å°†å…¶å…¶ä¸­çš„æ‰€æœ‰å…ƒç´ æ·»åŠ è‡³ç›®æ ‡åˆ—è¡¨ä¸­ï¼š
\index{extend method}  \index{method!extend}

\begin{lstlisting}
>>> t1 = ['a', 'b', 'c']
>>> t2 = ['d', 'e']
>>> t1.extend(t2)
>>> t1
['a', 'b', 'c', 'd', 'e']
\end{lstlisting}

%
%ğŸ% This example leaves {\tt t2} unmodified.

è¿™ä¸ªä¾‹å­ä¸­ \li{t2} æ²¡æœ‰æ”¹åŠ¨ã€‚

%ğŸ% {\tt sort} arranges the elements of the list from low to high:

\li{sort} å°†åˆ—è¡¨ä¸­çš„å…ƒç´ ä»å°åˆ°å¤§è¿›è¡Œæ’åºï¼š
\index{sort method}  \index{method!sort}

\begin{lstlisting}
>>> t = ['d', 'c', 'e', 'b', 'a']
>>> t.sort()
>>> t
['a', 'b', 'c', 'd', 'e']
\end{lstlisting}

%
%ğŸ% Most list methods are void; they modify the list and return {\tt None}.
%ğŸ% If you accidentally write {\tt t = t.sort()}, you will be disappointed
%ğŸ% with the result.

å¤§éƒ¨åˆ†çš„åˆ—è¡¨æ–¹æ³•éƒ½æ˜¯æ— è¿”å›å€¼çš„ï¼›å®ƒä»¬å¯¹åˆ—è¡¨è¿›è¡Œä¿®æ”¹ï¼Œ ç„¶åè¿”å›Noneã€‚
å¦‚æœä½ æ„å¤–çš„å†™äº† \li{t.sort()}ï¼Œ ä½ å°†ä¼šå¯¹ç»“æœæ„Ÿåˆ°å¤±æœ›çš„ã€‚
\index{void method}  \index{method!void}
\index{None special value}  \index{special value!None}


%ğŸ% \section{Map, filter and reduce  |  æ˜ å°„ã€ç­›é€‰å’Œå½’å¹¶}
\section{æ˜ å°„ã€ç­›é€‰å’Œå½’å¹¶}
\label{filter}

%ğŸ% To add up all the numbers in a list, you can use a loop like this:

ä½ å¯ä»¥è¿™æ ·ä½¿ç”¨å¾ªç¯ï¼Œ å¯¹åˆ—è¡¨ä¸­æ‰€æœ‰å…ƒç´ æ±‚å’Œ:

% see add.py

\begin{lstlisting}
def add_all(t):
    total = 0
    for x in t:
        total += x
    return total
\end{lstlisting}
%
%ğŸ% {\tt total} is initialized to 0.  Each time through the loop,
%ğŸ% {\tt x} gets one element from the list.  The {\tt +=} operator
%ğŸ% provides a short way to update a variable.  This {\bf augmented assignment %ğŸ% statement},

\li{total} è¢«åˆå§‹åŒ–ä¸º 0ã€‚  æ¯æ¬¡å¾ªç¯æ—¶, \li{x} ä»åˆ—è¡¨ä¸­è·å–ä¸€ä¸ªå…ƒç´ ã€‚
è¿ç®—ç¬¦ \li{+=} æä¾›äº†ä¸€ä¸ªå¿«æ·çš„æ›´æ–°å˜é‡çš„æ–¹æ³•ã€‚  è¿™ä¸ª {\em å¢é‡èµ‹å€¼è¯­å¥} (augmented assignment statement) ã€‚

\index{update operator}  \index{operator!update}
\index{assignment!augmented}  \index{augmented assignment}

\begin{lstlisting}
    total += x
\end{lstlisting}

%
%ğŸ% is equivalent to

ç­‰ä»·äº

\begin{lstlisting}
    total = total + x
\end{lstlisting}

%
%ğŸ% As the loop runs, {\tt total} accumulates the sum of the
%ğŸ% elements; a variable used this way is sometimes called an
%ğŸ% {\bf accumulator}.

å½“å¾ªç¯æ‰§è¡Œæ—¶ï¼Œ \li{total} å°†ç´¯è®¡å…ƒç´ çš„å’Œï¼›ä¸€ä¸ªè¿™æ ·çš„å˜é‡æœ‰æ—¶è¢«ç§°ä¸º {\em ç´¯åŠ å™¨} (accumulator) ã€‚

\index{accumulator!sum}

%ğŸ% Adding up the elements of a list is such a common operation
%ğŸ% that Python provides it as a built-in function, {\tt sum}:

æŠŠä¸€ä¸ªåˆ—è¡¨ä¸­çš„å…ƒç´ åŠ èµ·æ¥æ˜¯ä¸€ä¸ªå¾ˆå¸¸ç”¨çš„æ“ä½œï¼Œ
æ‰€ä»¥Pythonå°†å…¶è®¾ç½®ä¸ºä¸€ä¸ªå†…å»ºå†…ç½®å‡½æ•° \li{sum} ï¼š

\begin{lstlisting}
>>> t = [1, 2, 3]
>>> sum(t)
6
\end{lstlisting}
%
%ğŸ% An operation like this that combines a sequence of elements into
%ğŸ% a single value is sometimes called {\bf reduce}.

ä¸€ä¸ªåƒè¿™æ ·çš„å°†ä¸€ç³»åˆ—çš„å…ƒç´ åˆå¹¶æˆä¸€ä¸ªå•ä¸€å€¼çš„æ“ä½œæœ‰æ—¶ç§°ä¸º {\em å½’å¹¶} (reduce) ã€‚

\index{reduce pattern}  \index{pattern!reduce}
\index{traversal}

%ğŸ% Sometimes you want to traverse one list while building
%ğŸ% another.  For example, the following function takes a list of strings
%ğŸ% and returns a new list that contains capitalized strings:

æœ‰æ—¶ï¼Œ ä½ åœ¨æ„å»ºä¸€ä¸ªåˆ—è¡¨æ—¶è¿˜éœ€è¦éå†å¦ä¸€ä¸ªåˆ—è¡¨ã€‚   ä¾‹å¦‚ï¼Œ ä¸‹é¢çš„å‡½æ•°æ¥å—ä¸€ä¸ªå­—ç¬¦ä¸²åˆ—è¡¨

\begin{lstlisting}
def capitalize_all(t):
    res = []
    for s in t:
        res.append(s.capitalize())
    return res
\end{lstlisting}

%
%ğŸ% {\tt res} is initialized with an empty list; each time through
%ğŸ% the loop, we append the next element.  So {\tt res} is another
%ğŸ% kind of accumulator.

\li{res} è¢«åˆå§‹åŒ–ä¸ºä¸€ä¸ªç©ºåˆ—è¡¨ï¼›æ¯æ¬¡å¾ªç¯æ—¶ï¼Œ æˆ‘ä»¬æ·»åŠ ä¸‹ä¸€ä¸ªå…ƒç´ ã€‚
æ‰€ä»¥ \li{res} æ˜¯å¦ä¸€ç§å½¢å¼çš„ç´¯åŠ å™¨ã€‚

\index{accumulator!list}

%ğŸ% An operation like \verb"capitalize_all" is sometimes called a {\bf
%ğŸ% map} because it ``maps'' a function (in this case the method {\tt
%ğŸ% capitalize}) onto each of the elements in a sequence.

ç±»ä¼¼ \li{capitalize_all} è¿™æ ·çš„æ“ä½œæœ‰æ—¶è¢«ç§°ä¸º {\em æ˜ å°„} (map) ï¼Œ å› ä¸ºå®ƒ ``æ˜ å°„''ä¸€ä¸ªå‡½æ•°(åœ¨æœ¬ä¾‹ä¸­æ˜¯æ–¹æ³• \li{capitalize} )åˆ°åºåˆ—ä¸­çš„æ¯ä¸ªå…ƒç´ ä¸Šã€‚

\index{map pattern}  \index{pattern!map}
\index{filter pattern}  \index{pattern!filter}

%ğŸ% Another common operation is to select some of the elements from
%ğŸ% a list and return a sublist.  For example, the following
%ğŸ% function takes a list of strings and returns a list that contains
%ğŸ% only the uppercase strings:

å¦ä¸€ä¸ªå¸¸è§çš„æ“ä½œæ˜¯ä»åˆ—è¡¨ä¸­é€‰æ‹©ä¸€äº›å…ƒç´ ï¼Œ å¹¶è¿”å›ä¸€ä¸ªå­åˆ—è¡¨ã€‚  ä¾‹å¦‚ï¼Œ ä¸‹é¢çš„å‡½æ•°è¯»å–ä¸€ä¸ªå­—ç¬¦ä¸²åˆ—è¡¨ï¼Œ å¹¶è¿”å›ä¸€ä¸ªä»…åŒ…å«å¤§å†™å­—ç¬¦ä¸²çš„åˆ—è¡¨ï¼š

\begin{lstlisting}
def only_upper(t):
    res = []
    for s in t:
        if s.isupper():
            res.append(s)
    return res
\end{lstlisting}

%
%ğŸ% {\tt isupper} is a string method that returns {\tt True} if
%ğŸ% the string contains only upper case letters.

\li{isupper} æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²æ–¹æ³•ï¼Œ å¦‚æœå­—ç¬¦ä¸²ä»…å«æœ‰å¤§å†™å­—æ¯ï¼Œ åˆ™è¿”å› \li{True}ã€‚

%ğŸ% An operation like \verb"only_upper" is called a {\bf filter} because
%ğŸ% it selects some of the elements and filters out the others.

ç±»ä¼¼ \li{only_upper} è¿™æ ·çš„æ“ä½œè¢«ç§°ä¸º {\em ç­›é€‰} (filter) ï¼Œ å› ä¸ºå®ƒé€‰ä¸­æŸäº›å…ƒç´ ï¼Œ ç„¶åå‰”é™¤å‰©ä½™çš„å…ƒç´ ã€‚

%ğŸ% Most common list operations can be expressed as a combination
%ğŸ% of map, filter and reduce.

å¤§éƒ¨åˆ†å¸¸ç”¨åˆ—è¡¨æ“ä½œå¯ä»¥ç”¨æ˜ å°„ã€ç­›é€‰å’Œå½’å¹¶è¿™ä¸ªç»„åˆè¡¨ç¤ºã€‚


%ğŸ% \section{Deleting elements  |  åˆ é™¤å…ƒç´ }
\section{åˆ é™¤å…ƒç´ }
\index{element deletion}  \index{deletion, element of list}

%ğŸ% There are several ways to delete elements from a list.  If you
%ğŸ% know the index of the element you want, you can use
%ğŸ% {\tt pop}:

æœ‰å¤šç§æ–¹æ³•å¯ä»¥ä»åˆ—è¡¨ä¸­åˆ é™¤ä¸€ä¸ªå…ƒç´ ã€‚  å¦‚æœä½ çŸ¥é“å…ƒç´ çš„ä¸‹æ ‡ï¼Œ ä½ å¯ä»¥ä½¿ç”¨ \li{pop} ï¼š

\index{pop method}  \index{method!pop}

\begin{lstlisting}
>>> t = ['a', 'b', 'c']
>>> x = t.pop(1)
>>> t
['a', 'c']
>>> x
'b'
\end{lstlisting}

%
%ğŸ% {\tt pop} modifies the list and returns the element that was removed.
%ğŸ% If you don't provide an index, it deletes and returns the
%ğŸ% last element.

\li{pop} ä¿®æ”¹åˆ—è¡¨ï¼Œ å¹¶è¿”å›è¢«ç§»é™¤çš„å…ƒç´ ã€‚  å¦‚æœä½ ä¸æä¾›ä¸‹æ ‡ï¼Œ å®ƒå°†ç§»é™¤å¹¶è¿”å›æœ€åä¸€ä¸ªå…ƒç´ ã€‚

%ğŸ% If you don't need the removed value, you can use the {\tt del}
%ğŸ% operator:

å¦‚æœä½ ä¸éœ€è¦è¢«ç§»é™¤çš„å…ƒç´ ï¼Œ å¯ä»¥ä½¿ç”¨ \li{del} è¿ç®—ç¬¦ï¼š

\index{del operator}  \index{operator!del}

\begin{lstlisting}
>>> t = ['a', 'b', 'c']
>>> del t[1]
>>> t
['a', 'c']
\end{lstlisting}

%
%ğŸ% If you know the element you want to remove (but not the index), you
%ğŸ% can use {\tt remove}:

å¦‚æœä½ çŸ¥é“è¦åˆ é™¤çš„å€¼(ä½†æ˜¯ä¸çŸ¥é“å…¶ä¸‹æ ‡)ï¼Œ ä½ å¯ä»¥ä½¿ç”¨ \li{remove} ï¼š

\index{remove method}  \index{method!remove}

\begin{lstlisting}
>>> t = ['a', 'b', 'c']
>>> t.remove('b')
>>> t
['a', 'c']
\end{lstlisting}
%
%ğŸ% The return value from {\tt remove} is {\tt None}.

\li{remove} çš„è¿”å›å€¼æ˜¯ \li{None}ã€‚

\index{None special value}  \index{special value!None}

%ğŸ% To remove more than one element, you can use {\tt del} with
%ğŸ% a slice index:

è¦ç§»é™¤å¤šä¸ªå…ƒç´ ï¼Œ ä½ å¯ä»¥ç»“åˆåˆ‡ç‰‡ç´¢å¼•ä½¿ç”¨ \li{del} ï¼š

\begin{lstlisting}
>>> t = ['a', 'b', 'c', 'd', 'e', 'f']
>>> del t[1:5]
>>> t
['a', 'f']
\end{lstlisting}

%
%ğŸ% As usual, the slice selects all the elements up to but not
%ğŸ% including the second index.

åŒæ ·çš„ï¼Œ åˆ‡ç‰‡é€‰æ‹©åˆ°ç¬¬äºŒä¸ªä¸‹æ ‡(ä¸åŒ…å«ç¬¬äºŒä¸ªä¸‹æ ‡)å¤„çš„æ‰€æœ‰å…ƒç´ ã€‚


%ğŸ% \section{Lists and strings  |  åˆ—è¡¨å’Œå­—ç¬¦ä¸²}
\section{åˆ—è¡¨å’Œå­—ç¬¦ä¸²}
\index{list}  \index{string}
\index{sequence}

%ğŸ% A string is a sequence of characters and a list is a sequence
%ğŸ% of values, but a list of characters is not the same as a
%ğŸ% string.  To convert from a string to a list of characters,
%ğŸ% you can use {\tt list}:

ä¸€ä¸ªå­—ç¬¦ä¸²æ˜¯å¤šä¸ªå­—ç¬¦ç»„æˆçš„åºåˆ—ï¼Œ ä¸€ä¸ªåˆ—è¡¨æ˜¯å¤šä¸ªå€¼ç»„æˆçš„åºåˆ—ã€‚  ä½†æ˜¯ä¸€ä¸ªç”±å­—ç¬¦ç»„æˆçš„åˆ—è¡¨ä¸åŒäºå­—ç¬¦ä¸²ã€‚  å¯ä»¥ä½¿ç”¨ \li{list} å°†ä¸€ä¸ªå­—ç¬¦ä¸²è½¬æ¢ä¸ºå­—ç¬¦çš„åˆ—è¡¨:

\index{list!function}  \index{function!list}

\begin{lstlisting}
>>> s = 'spam'
>>> t = list(s)
>>> t
['s', 'p', 'a', 'm']
\end{lstlisting}

%
%ğŸ% Because {\tt list} is the name of a built-in function, you should
%ğŸ% avoid using it as a variable name.  I also avoid {\tt l} because
%ğŸ% it looks too much like {\tt 1}.  So that's why I use {\tt t}.

ç”±äº \li{list} æ˜¯å†…ç½®å‡½æ•°çš„åç§°ï¼Œ ä½ åº”é¿å…å°†å®ƒç”¨ä½œå˜é‡åã€‚  æˆ‘åŒæ ·é¿å…ä½¿ç”¨ \li{l} ï¼Œ å› ä¸ºå®ƒçœ‹èµ·æ¥å¾ˆåƒ \li{1}ã€‚  è¿™å°±æ˜¯ä¸ºä»€ä¹ˆæˆ‘ç”¨äº† \li{t} ã€‚

%ğŸ% The {\tt list} function breaks a string into individual letters.  If
%ğŸ% you want to break a string into words, you can use the {\tt split}
%ğŸ% method:

\li{list} å‡½æ•°å°†å­—ç¬¦ä¸²åˆ†å‰²æˆå•ç‹¬çš„å­—ç¬¦ã€‚  å¦‚æœä½ æƒ³å°†ä¸€ä¸ªå­—ç¬¦ä¸²åˆ†å‰²æˆä¸€äº›å•è¯ï¼Œ ä½ å¯ä»¥ä½¿ç”¨ \li{split} æ–¹æ³•ï¼š

\index{split method}  \index{method!split}

\begin{lstlisting}
>>> s = 'pining for the fjords'
>>> t = s.split()
>>> t
['pining', 'for', 'the', 'fjords']
\end{lstlisting}

%
%ğŸ% An optional argument called a {\bf delimiter} specifies which
%ğŸ% characters to use as word boundaries.
%ğŸ% The following example
%ğŸ% uses a hyphen as a delimiter:

å¯ä»¥æé«˜ä¸€ä¸ªå«åš {\em åˆ†éš”ç¬¦} (delimiter) çš„å¯é€‰å‚æ•°ï¼Œ æŒ‡å®šä»€ä¹ˆå­—ç¬¦ä½œä¸ºå•è¯ä¹‹é—´çš„åˆ†ç•Œçº¿ã€‚  ä¸‹é¢çš„ä¾‹å­ä½¿ç”¨è¿å­—ç¬¦ä½œä¸ºåˆ†éš”ç¬¦ï¼š

\index{optional argument}  \index{argument!optional}
\index{delimiter}

\begin{lstlisting}
>>> s = 'spam-spam-spam'
>>> delimiter = '-'
>>> t = s.split(delimiter)
>>> t
['spam', 'spam', 'spam']
\end{lstlisting}

%
%ğŸ% {\tt join} is the inverse of {\tt split}.  It
%ğŸ% takes a list of strings and
%ğŸ% concatenates the elements.  {\tt join} is a string method,
%ğŸ% so you have to invoke it on the delimiter and pass the
%ğŸ% list as a parameter:

\li{join} çš„åŠŸèƒ½å’Œ \li{split} ç›¸åã€‚  å®ƒå°†ä¸€ä¸ªå­—ç¬¦ä¸²åˆ—è¡¨çš„å…ƒç´ æ‹¼æ¥èµ·æ¥ã€‚  \li{join} æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²æ–¹æ³•ï¼Œ æ‰€ä»¥ä½ éœ€è¦åœ¨ä¸€ä¸ªåˆ†éš”ç¬¦ä¸Šè°ƒç”¨å®ƒï¼Œ å¹¶ä¼ å…¥ä¸€ä¸ªåˆ—è¡¨ä½œä¸ºå‚æ•°ï¼š

\index{join method}  \index{method!join}
\index{concatenation}

\begin{lstlisting}
>>> t = ['pining', 'for', 'the', 'fjords']
>>> delimiter = ' '
>>> s = delimiter.join(t)
>>> s
'pining for the fjords'
\end{lstlisting}

%
%ğŸ% In this case the delimiter is a space character, so
%ğŸ% {\tt join} puts a space between words.  To concatenate
%ğŸ% strings without spaces, you can use the empty string,
%ğŸ% \verb"''", as a delimiter.

åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œ åˆ†éš”ç¬¦æ˜¯ä¸€ä¸ªç©ºæ ¼ï¼Œ æ‰€ä»¥ \li{join} åœ¨å•è¯ä¹‹é—´æ·»åŠ ä¸€ä¸ªç©ºæ ¼ã€‚  å¦‚æœä¸ä½¿ç”¨ç©ºæ ¼æ‹¼æ¥å­—ç¬¦ä¸²ï¼Œ ä½ å¯ä»¥ä½¿ç”¨ç©ºå­—ç¬¦ä¸² \li{''} ä½œä¸ºåˆ†éš”ç¬¦ã€‚

\index{empty string}  \index{string!empty}


%ğŸ% \section{Objects and values  |  å¯¹è±¡å’Œå€¼}
\section{å¯¹è±¡å’Œå€¼}
\label{equivalence}
\index{object}  \index{value}

%ğŸ% If we run these assignment statements:

å¦‚æœæˆ‘ä»¬æ‰§è¡Œä¸‹é¢çš„èµ‹å€¼è¯­å¥ï¼š

\begin{lstlisting}
a = 'banana'
b = 'banana'
\end{lstlisting}

%
%ğŸ% We know that {\tt a} and {\tt b} both refer to a
%ğŸ% string, but we don't
%ğŸ% know whether they refer to the {\em same} string.
%ğŸ% There are two possible states, shown in Figure~\ref{fig.list1}.

æˆ‘ä»¬çŸ¥é“ \li{a} å’Œ \li{b} éƒ½æŒ‡å‘ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œ ä½†æ˜¯æˆ‘ä»¬ä¸çŸ¥é“æ˜¯å¦ä»–ä»¬æŒ‡å‘ {\bf åŒä¸€ä¸ª} å­—ç¬¦ä¸²ã€‚  è¿™é‡Œæœ‰ä¸¤ç§å¯èƒ½çš„çŠ¶æ€ï¼Œ å¦‚ å›¾~\ref{fig.list1} æ‰€ç¤ºã€‚

\index{aliasing}

\begin{figure}
\centerline
{\includegraphics[scale=0.8]{../source/figs/list1.pdf}}
\caption{çŠ¶æ€å›¾ã€‚}
\label{fig.list1}
\end{figure}

%ğŸ% In one case, {\tt a} and {\tt b} refer to two different objects that
%ğŸ% have the same value.  In the second case, they refer to the same
%ğŸ% object.

ä¸€ç§æƒ…å†µæ˜¯ï¼Œ \li{a} å’Œ \li{b} æŒ‡å‘ä¸¤ä¸ªæœ‰ç›¸åŒå€¼çš„ä¸åŒå¯¹è±¡ã€‚
ç¬¬äºŒç§æƒ…å†µæ˜¯ï¼Œ å®ƒä»¬æŒ‡å‘åŒä¸€ä¸ªå¯¹è±¡ã€‚

\index{is operator}  \index{operator!is}

%ğŸ% To check whether two variables refer to the same object, you can
%ğŸ% use the {\tt is} operator.

ä¸ºäº†æŸ¥çœ‹ä¸¤ä¸ªå˜é‡æ˜¯å¦æŒ‡å‘åŒä¸€ä¸ªå¯¹è±¡ï¼Œ ä½ å¯ä»¥ä½¿ç”¨ \li{is} è¿ç®—ç¬¦ã€‚

\begin{lstlisting}
>>> a = 'banana'
>>> b = 'banana'
>>> a is b
True
\end{lstlisting}

%
%ğŸ% In this example, Python only created one string object, and both {\tt
%ğŸ%   a} and {\tt b} refer to it.  But when you create two lists, you get
%ğŸ% two objects:

åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œ Pythonä»…ç”Ÿæˆäº†ä¸€ä¸ªå­—ç¬¦ä¸²å¯¹è±¡ï¼Œ \li{a} å’Œ \li{b} éƒ½æŒ‡å‘å®ƒã€‚  ä½†æ˜¯å½“ä½ åˆ›å»ºä¸¤ä¸ªåˆ—è¡¨æ—¶ï¼Œ ä½ å¾—åˆ°çš„æ˜¯ä¸¤ä¸ªå¯¹è±¡ï¼š

\begin{lstlisting}
>>> a = [1, 2, 3]
>>> b = [1, 2, 3]
>>> a is b
False
\end{lstlisting}

%
%ğŸ% So the state diagram looks like Figure~\ref{fig.list2}.

æ‰€ä»¥çŠ¶æ€å›¾å¦‚å›¾~\ref{fig.list2}æ‰€ç¤ºã€‚

\index{state diagram}  \index{diagram!state}

\begin{figure}
\centerline
{\includegraphics[scale=0.8]{../source/figs/list2.pdf}}
\caption{çŠ¶æ€å›¾ã€‚}
\label{fig.list2}
\end{figure}

%ğŸ% In this case we would say that the two lists are {\bf equivalent},
%ğŸ% because they have the same elements, but not {\bf identical}, because
%ğŸ% they are not the same object.  If two objects are identical, they are
%ğŸ% also equivalent, but if they are equivalent, they are not necessarily
%ğŸ% identical.

åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œ æˆ‘ä»¬ç§°è¿™ä¸¤ä¸ªåˆ—è¡¨æ˜¯ {\bf ç›¸ç­‰\footnote{equivalent}}çš„ï¼Œ å› ä¸ºå®ƒä»¬æœ‰ç›¸åŒçš„å…ƒç´ ã€‚  ä½†å®ƒä»¬å¹¶ä¸ {\bf ç›¸åŒ\footnote{identical}} ï¼Œ å› ä¸ºä»–ä»¬ä¸æ˜¯åŒä¸€ä¸ªå¯¹è±¡ã€‚  å¦‚æœä¸¤ä¸ªå¯¹è±¡ {\bf ç›¸åŒ}ï¼Œ å®ƒä»¬ä¹Ÿæ˜¯ç›¸ç­‰çš„ï¼Œ ä½†æ˜¯å¦‚æœå®ƒä»¬æ˜¯ç›¸ç­‰çš„ï¼Œ å®ƒä»¬ä¸ä¸€å®šæ˜¯ç›¸åŒçš„ã€‚

\index{equivalence}  \index{identity}

%ğŸ% Until now, we have been using ``object'' and ``value''
%ğŸ% interchangeably, but it is more precise to say that an object has a
%ğŸ% value.  If you evaluate {\tt [1, 2, 3]}, you get a list
%ğŸ% object whose value is a sequence of integers.  If another
%ğŸ% list has the same elements, we say it has the same value, but
%ğŸ% it is not the same object.

è‡³æ­¤ï¼Œ æˆ‘ä»¬ä¸€ç›´åœ¨ç­‰ä»·åœ°ä½¿ç”¨``å¯¹è±¡'' å’Œ ``å€¼''ï¼Œ ä½†æ˜¯æ›´å‡†ç¡®çš„è¯´ï¼Œ ä¸€ä¸ªå¯¹è±¡æ‹¥æœ‰ä¸€ä¸ªå€¼ã€‚  å¦‚æœä½ å¯¹ \li{[1, 2, 3]} æ±‚å€¼ï¼Œ ä¼šå¾—åˆ°ä¸€ä¸ªå€¼ä¸ºæ•´æ•°åºåˆ—çš„åˆ—è¡¨å¯¹è±¡ã€‚
å¦‚æœå¦ä¸€ä¸ªåˆ—è¡¨æœ‰åŒæ ·çš„å…ƒç´ ï¼Œ æˆ‘ä»¬è¯´å®ƒä»¬æœ‰ç›¸åŒçš„å€¼ï¼Œ ä½†æ˜¯å®ƒä»¬å¹¶ä¸æ˜¯åŒä¸€ä¸ªå¯¹è±¡ã€‚

\index{object}  \index{value}


%ğŸ% \section{Aliasing  |  åˆ«å}
\section{åˆ«å}
\index{aliasing}  \index{reference!aliasing}

%ğŸ% If {\tt a} refers to an object and you assign {\tt b = a},
%ğŸ% then both variables refer to the same object:

å¦‚æœ \li{a} æŒ‡å‘ä¸€ä¸ªå¯¹è±¡ï¼Œ ç„¶åä½ èµ‹å€¼ \li{b = a} ï¼Œ é‚£ä¹ˆä¸¤ä¸ªå˜é‡æŒ‡å‘åŒä¸€ä¸ªå¯¹è±¡ï¼š

\begin{lstlisting}
>>> a = [1, 2, 3]
>>> b = a
>>> b is a
True
\end{lstlisting}

%
%ğŸ% The state diagram looks like Figure~\ref{fig.list3}.

çŠ¶æ€å›¾å¦‚å›¾~\ref{fig.list3} æ‰€ç¤ºã€‚

\index{state diagram}  \index{diagram!state}

\begin{figure}
\centerline
{\includegraphics[scale=0.8]{../source/figs/list3.pdf}}
\caption{çŠ¶æ€å›¾ã€‚}
\label{fig.list3}
\end{figure}

%ğŸ% The association of a variable with an object is called a {\bf
%ğŸ% reference}.  In this example, there are two references to the same
%ğŸ% object.

å˜é‡å’Œå¯¹è±¡ä¹‹é—´çš„å…³è”ç§°ä¸º {\em å¼•ç”¨} (reference) ã€‚
åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œ æœ‰ä¸¤ä¸ªå¯¹åŒä¸€ä¸ªå¯¹è±¡çš„å¼•ç”¨ã€‚

\index{reference}

%ğŸ% An object with more than one reference has more
%ğŸ% than one name, so we say that the object is {\bf aliased}.

å¦‚æœä¸€ä¸ªå¯¹è±¡æœ‰å¤šäºä¸€ä¸ªå¼•ç”¨ï¼Œ é‚£å®ƒä¹Ÿä¼šæœ‰å¤šä¸ªåç§°ï¼Œ
æˆ‘ä»¬ç§°è¿™ä¸ªå¯¹è±¡æ˜¯ {\bf æœ‰åˆ«å\footnote{aliased; åˆ«å, aliasã€‚}çš„} ã€‚

\index{mutability}

%ğŸ% If the aliased object is mutable, changes made with one alias affect
%ğŸ% the other:

å¦‚æœä¸€ä¸ªæœ‰åˆ«åçš„å¯¹è±¡æ˜¯å¯å˜çš„ï¼Œ å¯¹å…¶ä¸­ä¸€ä¸ªåˆ«åçš„æ”¹å˜å¯¹å½±å“åˆ°å…¶å®ƒçš„åˆ«åï¼š

\begin{lstlisting}
>>> b[0] = 42
>>> a
[42, 2, 3]
\end{lstlisting}

%
%ğŸ% Although this behavior can be useful, it is error-prone.  In general,
%ğŸ% it is safer to avoid aliasing when you are working with mutable
%ğŸ% objects.

å°½ç®¡è¿™ä¸ªè¡Œä¸ºå¾ˆæœ‰ç”¨ï¼Œ ä½†æ˜¯å®¹æ˜“å¯¼è‡´å‡ºç°é”™è¯¯ã€‚
é€šå¸¸ï¼Œ é¿å…å¯¹äºå¯å˜å¯¹è±¡ä½¿ç”¨åˆ«åç›¸å¯¹æ›´å®‰å…¨ã€‚

\index{immutability}

%ğŸ% For immutable objects like strings, aliasing is not as much of a
%ğŸ% problem.  In this example:

å¯¹äºåƒå­—ç¬¦ä¸²è¿™æ ·çš„ä¸å¯å˜å¯¹è±¡ï¼Œ ä½¿ç”¨åˆ«åæ²¡æœ‰ä»€ä¹ˆé—®é¢˜ã€‚  ä¾‹å¦‚ï¼š

\begin{lstlisting}
a = 'banana'
b = 'banana'
\end{lstlisting}

%
%ğŸ% It almost never makes a difference whether {\tt a} and {\tt b} refer
%ğŸ% to the same string or not.

\li{a} å’Œ \li{b} æ˜¯å¦æŒ‡å‘åŒä¸€ä¸ªå­—ç¬¦ä¸²åŸºæœ¬ä¸Šæ²¡æœ‰ä»€ä¹ˆå½±å“ã€‚


%ğŸ% \section{List arguments  |  åˆ—è¡¨å‚æ•°}
\section{åˆ—è¡¨å‚æ•°}
\label{list.arguments}
\index{list!as argument}  \index{argument}
\index{argument!list}  \index{reference}
\index{parameter}

\index{åˆ—è¡¨!å‚æ•°}  \index{å®å‚}
\index{å‚æ•°!åˆ—è¡¨}  \index{å¼•ç”¨}
\index{å‚æ•°}

%ğŸ% When you pass a list to a function, the function gets a reference to
%ğŸ% the list.  If the function modifies the list, the caller sees
%ğŸ% the change.  For example, \verb"delete_head" removes the first element
%ğŸ% from a list:

å½“ä½ å°†ä¸€ä¸ªåˆ—è¡¨ä½œä¸ºå‚æ•°ä¼ ç»™ä¸€ä¸ªå‡½æ•°ï¼Œ å‡½æ•°å°†å¾—åˆ°è¿™ä¸ªåˆ—è¡¨çš„ä¸€ä¸ªå¼•ç”¨ã€‚  å¦‚æœå‡½æ•°å¯¹è¿™ä¸ªåˆ—è¡¨è¿›è¡Œäº†ä¿®æ”¹ï¼Œ ä¼šåœ¨è°ƒç”¨è€…ä¸­æœ‰æ‰€ä½“ç°ã€‚  ä¾‹å¦‚ï¼Œ ``delete\_head'' åˆ é™¤åˆ—è¡¨çš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼š

\begin{lstlisting}
def delete_head(t):
    del t[0]
\end{lstlisting}

%
%ğŸ% Here's how it is used:

è¿™æ ·ä½¿ç”¨è¿™ä¸ªå‡½æ•°ï¼š

\begin{lstlisting}
>>> letters = ['a', 'b', 'c']
>>> delete_head(letters)
>>> letters
['b', 'c']
\end{lstlisting}

%
%ğŸ% The parameter {\tt t} and the variable {\tt letters} are
%ğŸ% aliases for the same object.  The stack diagram looks like
%ğŸ% Figure~\ref{fig.stack5}.

å‚æ•° \li{t} å’Œå˜é‡ \li{letters} æ˜¯åŒä¸€ä¸ªå¯¹è±¡çš„åˆ«åã€‚
å…¶å †æ ˆå›¾å¦‚å›¾~\ref{fig.stack5}æ‰€ç¤ºã€‚

\index{stack diagram}  \index{diagram!stack}

\begin{figure}
\centerline
{\includegraphics[scale=0.8]{../source/figs/stack5.pdf}}
\caption{Stack diagram.}
\label{fig.stack5}
\end{figure}

%ğŸ% Since the list is shared by two frames, I drew
%ğŸ% it between them.

ç”±äºåˆ—è¡¨è¢«ä¸¤ä¸ªå¸§å…±äº«ï¼Œ æˆ‘æŠŠå®ƒç”»åœ¨å®ƒä»¬ä¸­é—´ã€‚

%ğŸ% It is important to distinguish between operations that
%ğŸ% modify lists and operations that create new lists.  For
%ğŸ% example, the {\tt append} method modifies a list, but the
%ğŸ% {\tt +} operator creates a new list:

éœ€è¦æ³¨æ„çš„æ˜¯ä¿®æ”¹åˆ—è¡¨æ“ä½œå’Œåˆ›å»ºåˆ—è¡¨æ“ä½œé—´çš„åŒºåˆ«ã€‚
ä¾‹å¦‚ï¼Œ \li{append} æ–¹æ³•æ˜¯ä¿®æ”¹ä¸€ä¸ªåˆ—è¡¨ï¼Œ è€Œ \li{+} è¿ç®—ç¬¦æ˜¯åˆ›å»ºä¸€ä¸ªæ–°çš„åˆ—è¡¨ï¼š

\index{append method}  \index{method!append}
\index{list!concatenation}  \index{concatenation!list}

%
\begin{lstlisting}
>>> t1 = [1, 2]
>>> t2 = t1.append(3)
>>> t1
[1, 2, 3]
>>> t2
None
\end{lstlisting}

%
%ğŸ% {\tt append} modifies the list and returns {\tt None}.

\li{append} ä¿®æ”¹åˆ—è¡¨å¹¶è¿”å› \li{None}ã€‚

%
\begin{lstlisting}
>>> t3 = t1 + [4]
>>> t1
[1, 2, 3]
>>> t3
[1, 2, 3, 4]
>>> t1
\end{lstlisting}

%
%ğŸ% The {\tt +} operator creates a new list and leaves the
%ğŸ% original list unchanged.

è¿ç®—ç¬¦ \li{+} åˆ›å»ºäº†ä¸€ä¸ªæ–°åˆ—è¡¨ï¼Œ è€Œä¸æ”¹å˜åŸå§‹çš„åˆ—è¡¨ã€‚

%ğŸ% This difference is important when you write functions that
%ğŸ% are supposed to modify lists.  For example, this function
%ğŸ% {\em does not} delete the head of a list:

å¦‚æœä½ è¦ç¼–å†™ä¸€ä¸ªä¿®æ”¹åˆ—è¡¨çš„å‡½æ•°ï¼Œ è¿™ä¸€ç‚¹å°±å¾ˆé‡è¦ã€‚
ä¾‹å¦‚ï¼Œ è¿™ä¸ªå‡½æ•° {\em ä¸ä¼š} åˆ é™¤åˆ—è¡¨çš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼š

%
\begin{lstlisting}
def bad_delete_head(t):
    t = t[1:]              # WRONG!
\end{lstlisting}

%
%ğŸ% The slice operator creates a new list and the assignment
%ğŸ% makes {\tt t} refer to it, but that doesn't affect the caller.

åˆ‡ç‰‡è¿ç®—ç¬¦åˆ›å»ºäº†ä¸€ä¸ªæ–°åˆ—è¡¨ï¼Œ ç„¶åè¿™ä¸ªè¡¨è¾¾å¼è®© \li{t} æŒ‡å‘äº†å®ƒï¼Œ
ä½†æ˜¯å¹¶ä¸ä¼šå½±å“åŸæ¥è¢«è°ƒç”¨çš„åˆ—è¡¨ã€‚

\index{slice operator}  \index{operator!slice}

%
\begin{lstlisting}
>>> t4 = [1, 2, 3]
>>> bad_delete_head(t4)
>>> t4
[1, 2, 3]
\end{lstlisting}

%
%ğŸ% At the beginning of \verb"bad_delete_head", {\tt t} and {\tt t4}
%ğŸ% refer to the same list.  At the end, {\tt t} refers to a new list,
%ğŸ% but {\tt t4} still refers to the original, unmodified list.

åœ¨ \li{bad_delete_head} çš„å¼€å§‹å¤„ï¼Œ \li{t} å’Œ \li{t4} æŒ‡å‘åŒä¸€ä¸ªåˆ—è¡¨ã€‚  åœ¨ç»“æŸæ—¶ï¼Œ \li{t} æŒ‡å‘ä¸€ä¸ªæ–°åˆ—è¡¨ï¼Œ ä½†æ˜¯ \li{t4} ä»ç„¶æŒ‡å‘åŸæ¥çš„ã€æ²¡æœ‰è¢«æ”¹åŠ¨çš„åˆ—è¡¨ã€‚

%ğŸ% An alternative is to write a function that creates and
%ğŸ% returns a new list.  For example, {\tt tail} returns all but the first
%ğŸ% element of a list:

ä¸€ä¸ªæ›¿ä»£çš„å†™æ³•æ˜¯ï¼Œ å†™ä¸€ä¸ªåˆ›å»ºå¹¶è¿”å›ä¸€ä¸ªæ–°åˆ—è¡¨çš„å‡½æ•°ã€‚
ä¾‹å¦‚ï¼Œ \li{tail} è¿”å›åˆ—è¡¨ä¸­é™¤äº†ç¬¬ä¸€ä¸ªä¹‹å¤–çš„æ‰€æœ‰å…ƒç´ ï¼š

\begin{lstlisting}
def tail(t):
    return t[1:]
\end{lstlisting}

%
%ğŸ% This function leaves the original list unmodified.
%ğŸ% Here's how it is used:

è¿™ä¸ªå‡½æ•°ä¸ä¼šä¿®æ”¹åŸæ¥çš„åˆ—è¡¨ã€‚  ä¸‹é¢æ˜¯å‡½æ•°çš„ä½¿ç”¨æ–¹æ³•ï¼š

\begin{lstlisting}
>>> letters = ['a', 'b', 'c']
>>> rest = tail(letters)
>>> rest
['b', 'c']
\end{lstlisting}


%ğŸ% \section{Debugging  |  è°ƒè¯•}
\section{è°ƒè¯•}
\index{debugging}

%ğŸ% Careless use of lists (and other mutable objects)
%ğŸ% can lead to long hours of debugging.  Here are some common
%ğŸ% pitfalls and ways to avoid them:

ç²—å¿ƒåœ°ä½¿ç”¨åˆ—è¡¨(ä»¥åŠå…¶ä»–å¯å˜å¯¹è±¡)ä¼šå¯¼è‡´é•¿æ—¶é—´çš„è°ƒè¯•ã€‚
ä¸‹é¢åˆ—ä¸¾ä¸€äº›å¸¸è§çš„é™·é˜±ä»¥åŠé¿å…å®ƒä»¬çš„æ–¹æ³•ï¼š

%ğŸ% \begin{enumerate}
%ğŸ%
%ğŸ% \item Most list methods modify the argument and
%ğŸ%   return {\tt None}.  This is the opposite of the string methods,
%ğŸ%   which return a new string and leave the original alone.
%ğŸ%
%ğŸ% If you are used to writing string code like this:
%ğŸ%
%ğŸ% \begin{lstlisting}
%ğŸ% word = word.strip()
%ğŸ% \end{lstlisting}
%ğŸ%
%ğŸ% It is tempting to write list code like this:
%ğŸ%
%ğŸ% \begin{lstlisting}
%ğŸ% t = t.sort()           # WRONG!
%ğŸ% \end{lstlisting}
%ğŸ% \index{sort method}
%ğŸ% \index{method!sort}
%ğŸ%
%ğŸ% Because {\tt sort} returns {\tt None}, the
%ğŸ% next operation you perform with {\tt t} is likely to fail.
%ğŸ%
%ğŸ% Before using list methods and operators, you should read the
%ğŸ% documentation carefully and then test them in interactive mode.
%ğŸ%
%ğŸ% \item Pick an idiom and stick with it.
%ğŸ%
%ğŸ% Part of the problem with lists is that there are too many
%ğŸ% ways to do things.  For example, to remove an element from
%ğŸ% a list, you can use {\tt pop}, {\tt remove}, {\tt del},
%ğŸ% or even a slice assignment.
%ğŸ%
%ğŸ% To add an element, you can use the {\tt append} method or
%ğŸ% the {\tt +} operator.  Assuming that {\tt t} is a list and
%ğŸ% {\tt x} is a list element, these are correct:
%ğŸ%
%ğŸ% \begin{lstlisting}
%ğŸ% t.append(x)
%ğŸ% t = t + [x]
%ğŸ% t += [x]
%ğŸ% \end{lstlisting}
%ğŸ%
%ğŸ% And these are wrong:
%ğŸ%
%ğŸ% \begin{lstlisting}
%ğŸ% t.append([x])          # WRONG!
%ğŸ% t = t.append(x)        # WRONG!
%ğŸ% t + [x]                # WRONG!
%ğŸ% t = t + x              # WRONG!
%ğŸ% \end{lstlisting}
%ğŸ%
%ğŸ% Try out each of these examples in interactive mode to make sure
%ğŸ% you understand what they do.  Notice that only the last
%ğŸ% one causes a runtime error; the other three are legal, but they
%ğŸ% do the wrong thing.
%ğŸ%
%ğŸ%
%ğŸ% \item Make copies to avoid aliasing.
%ğŸ% \index{aliasing!copying to avoid}
%ğŸ% \index{copy!to avoid aliasing}
%ğŸ%
%ğŸ% If you want to use a method like {\tt sort} that modifies
%ğŸ% the argument, but you need to keep the original list as
%ğŸ% well, you can make a copy.
%ğŸ%
%ğŸ% \begin{lstlisting}
%ğŸ% >>> t = [3, 1, 2]
%ğŸ% >>> t2 = t[:]
%ğŸ% >>> t2.sort()
%ğŸ% >>> t
%ğŸ% [3, 1, 2]
%ğŸ% >>> t2
%ğŸ% [1, 2, 3]
%ğŸ% \end{lstlisting}
%ğŸ%
%ğŸ% In this example you could also use the built-in function {\tt sorted},
%ğŸ% which returns a new, sorted list and leaves the original alone.
%ğŸ%
%ğŸ% \begin{lstlisting}
%ğŸ% >>> t2 = sorted(t)
%ğŸ% >>> t
%ğŸ% [3, 1, 2]
%ğŸ% >>> t2
%ğŸ% [1, 2, 3]
%ğŸ% \end{lstlisting}
%ğŸ%
%ğŸ% \end{enumerate}


\begin{enumerate}

\item å¤§å¤šæ•°çš„åˆ—è¡¨æ–¹æ³•ä¼šå¯¹å‚æ•°è¿›è¡Œä¿®æ”¹ï¼Œ ç„¶åè¿”å› \li{None} ã€‚  è¿™å’Œå­—ç¬¦ä¸²æ–¹æ³•ç›¸åï¼Œ åè€…ä¿ç•™åŸå§‹çš„å­—ç¬¦ä¸²å¹¶è¿”å›ä¸€ä¸ªæ–°çš„å­—ç¬¦ä¸²ã€‚

å¦‚æœä½ ä¹ æƒ¯è¿™æ ·å†™å­—ç¬¦ä¸²ä»£ç ï¼š

\begin{lstlisting}
word = word.strip()
\end{lstlisting}

é‚£ä¹ˆä½ å¾ˆå¯èƒ½ä¼šå†™å‡ºä¸‹é¢çš„åˆ—è¡¨ä»£ç ï¼š

\begin{lstlisting}
t = t.sort()           # WRONG!
\end{lstlisting}
\index{sort method}
\index{method!sort}

å› ä¸º \li{sort} è¿”å› \li{None} ï¼Œ æ‰€ä»¥ä½ çš„ä¸‹ä¸€ä¸ªå¯¹ \li{t} æ‰§è¡Œçš„æ“ä½œå¾ˆå¯èƒ½ä¼šå¤±è´¥ã€‚

åœ¨ä½¿ç”¨ \li{list} æ–¹æ³•å’Œæ“ä½œç¬¦ä¹‹å‰ï¼Œ ä½ åº”è¯¥ä»”ç»†é˜…è¯»æ–‡æ¡£ï¼Œ ç„¶ååœ¨äº¤äº’æ¨¡å¼ä¸‹æµ‹è¯•ã€‚

\item é€‰æ‹©ä¸€ç§å†™æ³•ï¼Œ åšæŒä¸‹å»ã€‚

åˆ—è¡¨çš„ä¸€ä¸ªé—®é¢˜å°±æ˜¯æœ‰å¤ªå¤šæ–¹æ³•å¯ä»¥åšåŒæ ·çš„äº‹æƒ…ã€‚   ä¾‹å¦‚ï¼Œ è¦åˆ é™¤åˆ—è¡¨ä¸­çš„ä¸€ä¸ªå…ƒç´ ï¼Œ ä½ å¯ä»¥ä½¿ç”¨ \li{pop} ã€ \li{remove} ã€ \li{del} ç”šè‡³æ˜¯åˆ‡ç‰‡èµ‹å€¼ã€‚

 è¦æ·»åŠ ä¸€ä¸ªå…ƒç´ ï¼Œ ä½ å¯ä»¥ä½¿ç”¨ \li{append} æ–¹æ³•æˆ–è€… \li{+} è¿ç®—ç¬¦ã€‚  å‡è®¾ \li{t} æ˜¯ä¸€ä¸ªåˆ—è¡¨ï¼Œ \li{x} æ˜¯ä¸€ä¸ªåˆ—è¡¨å…ƒç´ ï¼Œ ä»¥ä¸‹è¿™äº›å†™æ³•éƒ½æ˜¯æ­£ç¡®çš„ï¼š

\begin{lstlisting}
t.append(x)
t = t + [x]
t += [x]
\end{lstlisting}

è€Œè¿™äº›æ˜¯é”™è¯¯çš„ï¼š

\begin{lstlisting}
t.append([x])          # WRONG!
t = t.append(x)        # WRONG!
t + [x]                # WRONG!
t = t + x              # WRONG!
\end{lstlisting}

åœ¨äº¤äº’æ¨¡å¼ä¸‹å°è¯•æ¯ä¸€ä¸ªä¾‹å­ï¼Œ ä¿è¯ä½ æ˜ç™½å®ƒä»¬åšäº†ä»€ä¹ˆã€‚   æ³¨æ„åªæœ‰æœ€åä¸€ä¸ªä¼šå¯¼è‡´è¿è¡Œæ—¶é”™è¯¯ï¼›å…¶ä»–çš„éƒ½æ˜¯åˆä¹è§„èŒƒçš„çš„ï¼Œ ä½†ç»“æœå´æ˜¯é”™çš„ã€‚


\item é€šè¿‡åˆ›å»ºæ‹·è´æ¥é¿å…åˆ«å.
\index{aliasing!copying to avoid}  \index{copy!to avoid aliasing}

å¦‚æœä½ è¦ä½¿ç”¨ç±»ä¼¼ \li{sort} è¿™æ ·çš„æ–¹æ³•æ¥ä¿®æ”¹å‚æ•°ï¼Œ
   ä½†åŒæ—¶æœ‰è¦ä¿ç•™åŸåˆ—è¡¨ï¼Œ ä½ å¯ä»¥åˆ›å»ºä¸€ä¸ªæ‹·è´ã€‚


\begin{lstlisting}
>>> t = [3, 1, 2]
>>> t2 = t[:]
>>> t2.sort()
>>> t
[3, 1, 2]
>>> t2
[1, 2, 3]
\end{lstlisting}

åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œ ä½ è¿˜å¯ä»¥ä½¿ç”¨å†…ç½®å‡½æ•° \li{sorted}ï¼Œ å®ƒå°†è¿”å›ä¸€ä¸ªæ–°çš„å·²æ’åºçš„åˆ—è¡¨ï¼Œ åŸåˆ—è¡¨å°†ä¿æŒä¸å˜ã€‚

\begin{lstlisting}
>>> t2 = sorted(t)
>>> t
[3, 1, 2]
>>> t2
[1, 2, 3]
\end{lstlisting}

\end{enumerate}


%ğŸ% \section{Glossary  |  æœ¯è¯­è¡¨}
\section{æœ¯è¯­è¡¨}

\begin{description}

%ğŸ% \item[list:] A sequence of values.
%ğŸ% \index{list}

\item[åˆ—è¡¨ (list):] å¤šä¸ªå€¼ç»„æˆçš„åºåˆ—ã€‚
\index{list}

%ğŸ% \item[element:] One of the values in a list (or other sequence),
%ğŸ% also called items.
%ğŸ% \index{element}

\item[å…ƒç´  (element):] åˆ—è¡¨(æˆ–åºåˆ—)ä¸­çš„ä¸€ä¸ªå€¼ï¼Œ ä¹Ÿç§°ä¸ºé¡¹ã€‚
\index{element}

%ğŸ% \item[nested list:] A list that is an element of another list.
%ğŸ% \index{nested list}

\item[åµŒå¥—åˆ—è¡¨ (nested list):] ä½œä¸ºå¦ä¸€ä¸ªåˆ—è¡¨çš„å…ƒç´ çš„åˆ—è¡¨ã€‚
\index{nested list}

%ğŸ% \item[accumulator:] A variable used in a loop to add up or
%ğŸ% accumulate a result.
%ğŸ% \index{accumulator}

\item[ç´¯åŠ å™¨ (accumulator):] å¾ªç¯ä¸­ç”¨äºç›¸åŠ æˆ–ç´¯ç§¯å‡ºä¸€ä¸ªç»“æœçš„å˜é‡ã€‚
\index{accumulator}

%ğŸ% \item[augmented assignment:] A statement that updates the value
%ğŸ% of a variable using an operator like \verb"+=".
%ğŸ% \index{assignment!augmented}  \index{augmented assignment}
%ğŸ% \index{traversal}

\item[å¢é‡èµ‹å€¼è¯­å¥ (augmented assignment):] ä¸€ä¸ªä½¿ç”¨ç±»ä¼¼ \li{+=} æ“ä½œç¬¦æ¥æ›´æ–°ä¸€ä¸ªå˜é‡çš„å€¼çš„è¯­å¥ã€‚
\index{assignment!augmented}  \index{augmented assignment}
\index{traversal}

%ğŸ% \item[reduce:] A processing pattern that traverses a sequence
%ğŸ% and accumulates the elements into a single result.
%ğŸ% \index{reduce pattern}  \index{pattern!reduce}

\item[å½’å¹¶ (reduce):] éå†åºåˆ—ï¼Œ å°†æ‰€æœ‰å…ƒç´ æ±‚å’Œä¸ºä¸€ä¸ªå€¼çš„å¤„ç†æ¨¡å¼ã€‚
\index{reduce pattern}  \index{pattern!reduce}

%ğŸ% \item[map:] A processing pattern that traverses a sequence and
%ğŸ% performs an operation on each element.
%ğŸ% \index{map pattern}  \index{pattern!map}

\item[æ˜ å°„ (map):] éå†åºåˆ—ï¼Œ å¯¹æ¯ä¸ªå…ƒç´ æ‰§è¡Œæ“ä½œçš„å¤„ç†æ¨¡å¼ã€‚
\index{map pattern}  \index{pattern!map}

%ğŸ% \item[filter:] A processing pattern that traverses a list and
%ğŸ% selects the elements that satisfy some criterion.
%ğŸ% \index{filter pattern}  \index{pattern!filter}

\item[ç­›é€‰ (filter):] éå†åºåˆ—ï¼Œ é€‰å‡ºæ»¡è¶³ä¸€å®šæ ‡å‡†çš„å…ƒç´ çš„å¤„ç†æ¨¡å¼ã€‚
\index{filter pattern}  \index{pattern!filter}

%ğŸ% \item[object:] Something a variable can refer to.  An object
%ğŸ% has a type and a value.
%ğŸ% \index{object}

\item[å¯¹è±¡ (object)] å˜é‡å¯ä»¥æŒ‡å‘çš„ä¸œè¥¿ã€‚  ä¸€ä¸ªå¯¹è±¡æœ‰æ•°æ®ç±»å‹å’Œå€¼ã€‚
\index{object}

%ğŸ% \item[equivalent:] Having the same value.
%ğŸ% \index{equivalent}

\item[ç›¸ç­‰ (equivalent):] æœ‰ç›¸åŒçš„å€¼ã€‚
\index{equivalent}

%ğŸ% \item[identical:] Being the same object (which implies equivalence).
%ğŸ% \index{identical}

\item[ç›¸åŒ (identical):] æ˜¯åŒä¸€ä¸ªå¯¹è±¡(éšå«ç€ç›¸ç­‰)ã€‚
\index{identical}

%ğŸ% \item[reference:] The association between a variable and its value.
%ğŸ% \index{reference}

\item[å¼•ç”¨ (reference):] ä¸€ä¸ªå˜é‡å’Œå®ƒçš„å€¼ä¹‹é—´çš„å…³è”ã€‚
\index{reference}

%ğŸ% \item[aliasing:] A circumstance where two or more variables refer to the same
%ğŸ% object.
%ğŸ% \index{aliasing}

\item[åˆ«åä½¿ç”¨:] ä¸¤ä¸ªæˆ–è€…ä¸¤ä¸ªä»¥ä¸Šå˜é‡æŒ‡å‘åŒä¸€ä¸ªå¯¹è±¡çš„æƒ…å†µã€‚
\index{aliasing}

%ğŸ% \item[delimiter:] A character or string used to indicate where a
%ğŸ% string should be split.
%ğŸ% \index{delimiter}

\item[åˆ†éš”ç¬¦ (delimiter):] ä¸€ä¸ªç”¨äºæŒ‡ç¤ºå­—ç¬¦ä¸²åˆ†å‰²ä½ç½®çš„å­—ç¬¦æˆ–è€…å­—ç¬¦ä¸²ã€‚
\index{delimiter}

\end{description}


%ğŸ% \section{Exercises  |  ç»ƒä¹ }
\section{ç»ƒä¹ }

%ğŸ% You can download solutions to these exercises from
%ğŸ% \url{http://thinkpython2.com/code/list_exercises.py}.

ä½ å¯ä»¥ä» \href{http://thinkpython2.com/code/list_exercises.py}{æ­¤å¤„} ä¸‹è½½è¿™äº›ç»ƒä¹ çš„ç­”æ¡ˆã€‚

\begin{exercise}

%ğŸ% Write a function called \verb"nested_sum" that takes a list of lists
%ğŸ% of integers and adds up the elements from all of the nested lists.
%ğŸ% For example:

ç¼–å†™ä¸€ä¸ªå«åš {\em \li{nested_sum}} çš„å‡½æ•°ï¼Œ æ¥å—ä¸€ä¸ªç”±ä¸€äº›æ•´æ•°åˆ—è¡¨æ„æˆçš„åˆ—è¡¨ä½œä¸ºå‚æ•°ï¼Œ å¹¶å°†æ‰€æœ‰åµŒå¥—åˆ—è¡¨ä¸­çš„å…ƒç´ ç›¸åŠ ã€‚  ä¾‹å¦‚ï¼š

\begin{em}
\begin{lstlisting}
>>> t = [[1, 2], [3], [4, 5, 6]]
>>> nested_sum(t)
21
\end{lstlisting}
\end{em}

\end{exercise}

\begin{exercise}
\label{cumulative}
\index{cumulative sum}

%ğŸ% Write a function called {\tt cumsum} that takes a list of numbers and
%ğŸ% returns the cumulative sum; that is, a new list where the $i$th
%ğŸ% element is the sum of the first $i+1$ elements from the original list.
%ğŸ% For example:

ç¼–å†™ä¸€ä¸ªå«åš {\em \li{cumsum}} çš„å‡½æ•°ï¼Œ æ¥å—ä¸€ä¸ªç”±æ•°å€¼ç»„æˆçš„åˆ—è¡¨ï¼Œ å¹¶è¿”å›ç´¯åŠ å’Œï¼›
å³ä¸€ä¸ªæ–°åˆ—è¡¨ï¼Œ å…¶ä¸­ç¬¬ $i+1$ ä¸ªå…ƒç´ æ˜¯åŸåˆ—è¡¨ä¸­å‰ $i$ ä¸ªå…ƒç´ çš„å’Œã€‚
ä¾‹å¦‚ï¼š

\begin{em}
\begin{lstlisting}
>>> t = [1, 2, 3]
>>> cumsum(t)
[1, 3, 6]
\end{lstlisting}
\end{em}

\end{exercise}

\begin{exercise}

%ğŸ% Write a function called \verb"middle" that takes a list and
%ğŸ% returns a new list that contains all but the first and last
%ğŸ% elements.  For example:

ç¼–å†™ä¸€ä¸ªå«åš {\em \li{middle}} çš„å‡½æ•°ï¼Œ æ¥å—ä¸€ä¸ªåˆ—è¡¨ä½œä¸ºå‚æ•°ï¼Œ å¹¶è¿”å›ä¸€ä¸ªé™¤äº†ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªå…ƒç´ çš„åˆ—è¡¨ã€‚
ä¾‹å¦‚ï¼š

\begin{em}
\begin{lstlisting}
>>> t = [1, 2, 3, 4]
>>> middle(t)
[2, 3]
\end{lstlisting}
\end{em}

\end{exercise}

\begin{exercise}

%ğŸ% Write a function called \verb"chop" that takes a list, modifies it
%ğŸ% by removing the first and last elements, and returns {\tt None}.
%ğŸ% For example:

ç¼–å†™ä¸€ä¸ªå«åš {\em \li{chop}} çš„å‡½æ•°ï¼Œ æ¥å—ä¸€ä¸ªåˆ—è¡¨ä½œä¸ºå‚æ•°ï¼Œ ç§»é™¤ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªå…ƒç´ ï¼Œ å¹¶è¿”å› {\em \li{None}}ã€‚
ä¾‹å¦‚ï¼š

\begin{em}
\begin{lstlisting}
>>> t = [1, 2, 3, 4]
>>> chop(t)
>>> t
[2, 3]
\end{lstlisting}
\end{em}

\end{exercise}


\begin{exercise}
%ğŸ% Write a function called \verb"is_sorted" that takes a list as a
%ğŸ% parameter and returns {\tt True} if the list is sorted in ascending
%ğŸ% order and {\tt False} otherwise.  For example:

ç¼–å†™ä¸€ä¸ªå«åš {\em \li{is_sorted}} çš„å‡½æ•°ï¼Œ æ¥å—ä¸€ä¸ªåˆ—è¡¨ä½œä¸ºå‚æ•°ï¼Œ
å¦‚æœåˆ—è¡¨æ˜¯é€’å¢æ’åˆ—çš„åˆ™è¿”å› {\em \li{True}} ï¼Œ å¦åˆ™è¿”å› {\em \li{False}}ã€‚
ä¾‹å¦‚ï¼š

\begin{em}
\begin{lstlisting}
>>> is_sorted([1, 2, 2])
True
>>> is_sorted(['b', 'a'])
False
\end{lstlisting}
\end{em}

\end{exercise}


\begin{exercise}
\label{anagram}
\index{anagram}

%ğŸ% Two words are anagrams if you can rearrange the letters from one
%ğŸ% to spell the other.  Write a function called \verb"is_anagram"
%ğŸ% that takes two strings and returns {\tt True} if they are anagrams.


å¦‚æœå¯ä»¥é€šè¿‡é‡æ’ä¸€ä¸ªå•è¯ä¸­å­—æ¯çš„é¡ºåºï¼Œ å¾—åˆ°å¦å¤–ä¸€ä¸ªå•è¯ï¼Œ é‚£ä¹ˆç§°è¿™ä¸¤ä¸ªå•è¯æ˜¯å˜ä½è¯ã€‚
ç¼–å†™ä¸€ä¸ªå«åš {\em \li{is_anagram}} çš„å‡½æ•°ï¼Œ æ¥å—ä¸¤ä¸ªå­—ç¬¦ä¸²ä½œä¸ºå‚æ•°ï¼Œ
å¦‚æœå®ƒä»¬æ˜¯å˜ä½è¯åˆ™è¿”å› {\em \li{True}} ã€‚
\end{exercise}



\begin{exercise}
\label{duplicate}
\index{duplicate}  \index{uniqueness}

%ğŸ% Write a function called \verb"has_duplicates" that takes
%ğŸ% a list and returns {\tt True} if there is any element that
%ğŸ% appears more than once.  It should not modify the original
%ğŸ% list.

ç¼–å†™ä¸€ä¸ªå«åš {\em \li{has_duplicates}} çš„å‡½æ•°ï¼Œ æ¥å—ä¸€ä¸ªåˆ—è¡¨ä½œä¸ºå‚æ•°ï¼Œ
å¦‚æœä¸€ä¸ªå…ƒç´ åœ¨åˆ—è¡¨ä¸­å‡ºç°äº†ä¸æ­¢ä¸€æ¬¡ï¼Œ åˆ™è¿”å› {\em \li{True}} ã€‚
è¿™ä¸ªå‡½æ•°ä¸èƒ½æ”¹å˜åŸåˆ—è¡¨ã€‚

\end{exercise}


\begin{exercise}

%ğŸ% This exercise pertains to the so-called Birthday Paradox, which you
%ğŸ% can read about at \url{http://en.wikipedia.org/wiki/Birthday_paradox}.
\index{birthday paradox}

è¿™ä¸ªä¹ é¢˜ä¸æ‰€è°“çš„ç”Ÿæ—¥æ‚–è®ºæœ‰å…³ã€‚
ä½ å¯ä»¥åœ¨ \href{http://en.wikipedia.org/wiki/Birthday_paradox}{ç»´åŸºç™¾ç§‘}äº†è§£æ›´å¤šç›¸å…³çš„å†…å®¹ã€‚
\index{ç»´åŸºç™¾ç§‘}

%ğŸ% If there are 23 students in your class, what are the chances
%ğŸ% that two of you have the same birthday?  You can estimate this
%ğŸ% probability by generating random samples of 23 birthdays
%ğŸ% and checking for matches.  Hint: you can generate random birthdays
%ğŸ% with the {\tt randint} function in the {\tt random} module.

å¦‚æœä½ çš„ç­çº§ä¸Šæœ‰ {\em 23} ä¸ªå­¦ç”Ÿï¼Œ {\em 2} ä¸ªå­¦ç”Ÿç”Ÿæ—¥ç›¸åŒçš„æ¦‚ç‡æ˜¯å¤šå°‘ï¼Ÿ
ä½ å¯ä»¥é€šè¿‡éšæœºäº§ç”Ÿ {\em 23} ä¸ªç”Ÿæ—¥ï¼Œ å¹¶æ£€æŸ¥åŒ¹é…æ¥ä¼°ç®—æ¦‚ç‡ã€‚
æç¤ºï¼šä½ å¯ä»¥ä½¿ç”¨ {\em \li{random}} æ¨¡å—ä¸­çš„ {\em \li{randint}} å‡½
æ•°æ¥ç”Ÿæˆéšæœºç”Ÿæ—¥ã€‚

\index{random module}  \index{module!random}
\index{randint function}  \index{function!randint}

%ğŸ% You can download my
%ğŸ% solution from \url{http://thinkpython2.com/code/birthday.py}.

ä½ å¯ä»¥å‚è€ƒ \href{http://thinkpython2.com/code/birthday.py}{æˆ‘çš„ç­”æ¡ˆ}ã€‚

\end{exercise}



\begin{exercise}
\index{append method}  \index{method append}
\index{list!concatenation}  \index{concatenation!list}

%ğŸ% Write a function that reads the file {\tt words.txt} and builds
%ğŸ% a list with one element per word.  Write two versions of
%ğŸ% this function, one using the {\tt append} method and the
%ğŸ% other using the idiom {\tt t = t + [x]}.  Which one takes
%ğŸ% longer to run?  Why?

ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œ è¯»å–æ–‡ä»¶ {\em \li{words.txt}}ï¼Œ å»ºç«‹ä¸€ä¸ªåˆ—è¡¨ï¼Œ å…¶ä¸­æ¯ä¸ªå•è¯ä¸ºä¸€ä¸ªå…ƒç´ ã€‚
ç¼–å†™ä¸¤ä¸ªç‰ˆæœ¬ï¼Œ ä¸€ä¸ªä½¿ç”¨ {\em \li{append}} æ–¹æ³•ï¼Œ å¦ä¸€ä¸ªä½¿ç”¨ {\em \li{t = t + [x]}}ã€‚
é‚£ä¸ªç‰ˆæœ¬è¿è¡Œå¾—æ…¢ï¼Ÿä¸ºä»€ä¹ˆï¼Ÿ

%ğŸ% Solution: \url{http://thinkpython2.com/code/wordlist.py}.

\href{http://thinkpython2.com/code/wordlist.py}{å‚è€ƒç­”æ¡ˆ}

\index{time module}  \index{module!time}

\end{exercise}


\begin{exercise}
\label{wordlist1}
\label{bisection}
\index{membership!bisection search}  \index{bisection search}
\index{search, bisection}  \index{membership!binary search}
\index{binary search}  \index{search, binary}

\index{membership!bisection search}  \index{bisection search}
\index{search, bisection}  \index{membership!binary search}
\index{äºŒå‰æ ‘æœç´¢}  \index{æœç´¢, äºŒå‰æ ‘}


%ğŸ% To check whether a word is in the word list, you could use
%ğŸ% the {\tt in} operator, but it would be slow because it searches
%ğŸ% through the words in order.

ä½¿ç”¨ {\em \li{in}} è¿ç®—ç¬¦å¯ä»¥æ£€æŸ¥ä¸€ä¸ªå•è¯æ˜¯å¦åœ¨å•è¯è¡¨ä¸­ï¼Œ ä½†è¿™å¾ˆæ…¢ï¼Œ å› ä¸ºå®ƒæ˜¯æŒ‰é¡ºåºæŸ¥æ‰¾å•è¯ã€‚

%ğŸ% Because the words are in alphabetical order, we can speed things up
%ğŸ% with a bisection search (also known as binary search), which is
%ğŸ% similar to what you do when you look a word up in the dictionary.  You
%ğŸ% start in the middle and check to see whether the word you are looking
%ğŸ% for comes before the word in the middle of the list.  If so, you
%ğŸ% search the first half of the list the same way.  Otherwise you search
%ğŸ% the second half.

ç”±äºå•è¯æ˜¯æŒ‰ç…§å­—æ¯é¡ºåºæ’åºçš„ï¼Œ æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸¤åˆ†æ³•{\em (}ä¹Ÿç§°äºŒå‰æ ‘æœç´¢{\em)}æ¥åŠ å¿«é€Ÿåº¦ï¼Œ
ç±»ä¼¼äºåœ¨å­—å…¸ä¸­æŸ¥æ‰¾å•è¯çš„æ–¹æ³•ã€‚  ä½ ä»ä¸­é—´å¼€å§‹ï¼Œ å¦‚æœä½ è¦æ‰¾çš„å•è¯åœ¨ä¸­é—´çš„å•è¯ä¹‹å‰ï¼Œ ä½ æŸ¥æ‰¾å‰åŠéƒ¨åˆ†ï¼Œ å¦åˆ™ä½ æŸ¥æ‰¾ååŠéƒ¨åˆ†ã€‚

%ğŸ% Either way, you cut the remaining search space in half.  If the
%ğŸ% word list has 113,809 words, it will take about 17 steps to
%ğŸ% find the word or conclude that it's not there.

ä¸ç®¡æ€æ ·ï¼Œ ä½ éƒ½ä¼šå°†æœç´¢èŒƒå›´å‡å°ä¸€åŠã€‚
å¦‚æœå•è¯è¡¨æœ‰ {\em 113,809} ä¸ªå•è¯ï¼Œ ä½ åªéœ€è¦ {\em 17} æ­¥å°±å¯ä»¥æ‰¾åˆ°è¿™ä¸ªå•è¯ï¼Œ æˆ–ç€å¾—å‡ºå•è¯ä¸å­˜åœ¨çš„ç»“è®ºã€‚

%ğŸ% Write a function called \verb"in_bisect" that takes a sorted list
%ğŸ% and a target value and returns the index of the value
%ğŸ% in the list if it's there, or {\tt None} if it's not.

ç¼–å†™ä¸€ä¸ªå«åš {\em \li{in_bisect}} çš„å‡½æ•°ï¼Œ æ¥å—ä¸€ä¸ªå·²æ’åºçš„åˆ—è¡¨å’Œä¸€ä¸ªç›®æ ‡å€¼ä½œä¸ºå‚æ•°ï¼Œ
è¿”å›è¯¥å€¼åœ¨åˆ—è¡¨ä¸­çš„ä½ç½®ï¼Œ å¦‚æœä¸å­˜åœ¨åˆ™è¿”å› {\em \li{None}} ã€‚

\index{bisect module}  \index{module!bisect}

%ğŸ% Or you could read the documentation of the {\tt bisect} module
%ğŸ% and use that!  Solution: \url{http://thinkpython2.com/code/inlist.py}.

æˆ–è€…ä½ å¯ä»¥é˜…è¯» {\em \li{bisect}} æ¨¡å—çš„æ–‡æ¡£å¹¶ä½¿ç”¨å®ƒï¼

\href{http://thinkpython2.com/code/inlist.py}{å‚è€ƒç­”æ¡ˆ}

\end{exercise}

\begin{exercise}
\index{reverse word pair}

%ğŸ% Two words are a ``reverse pair'' if each is the reverse of the
%ğŸ% other.  Write a program that finds all the reverse pairs in the
%ğŸ% word list.  Solution: \url{http://thinkpython2.com/code/reverse_pair.py}.

ä¸¤ä¸ªå•è¯ä¸­å¦‚æœä¸€ä¸ªæ˜¯å¦ä¸€ä¸ªçš„åè½¬ï¼Œ åˆ™äºŒè€…è¢«ç§°ä¸ºæ˜¯``åè½¬è¯å¯¹''ã€‚
ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œ æ‰¾å‡ºå•è¯è¡¨ä¸­æ‰€æœ‰çš„åè½¬è¯å¯¹ã€‚

\href{http://thinkpython2.com/code/reverse_pair.py}{å‚è€ƒç­”æ¡ˆ}

\end{exercise}

\begin{exercise}
\index{interlocking words}

%ğŸ% Two words ``interlock'' if taking alternating letters from each forms
%ğŸ% a new word.  For example, ``shoe'' and ``cold''
%ğŸ% interlock to form ``schooled''.
%ğŸ% Solution: \url{http://thinkpython2.com/code/interlock.py}.
%ğŸ% Credit: This exercise is inspired by an example at \url{http://puzzlers.org}.

å¦‚æœäº¤æ›¿çš„ä»ä¸¤ä¸ªå•è¯ä¸­å–å‡ºå­—ç¬¦å°†ç»„æˆä¸€ä¸ªæ–°çš„å•è¯ï¼Œ è¿™ä¸¤ä¸ªå•è¯è¢«ç§°ä¸ºæ˜¯``è¿é”è¯''ã€‚
ä¾‹å¦‚ï¼Œ {\em ``shoe''} å’Œ {\em ``cold''} è¿é”åæˆä¸º {\em ``schooled''}ã€‚

\begin{enumerate}

%ğŸ% \item Write a program that finds all pairs of words that interlock.
%ğŸ%   Hint: don't enumerate all pairs!

\item ç¼–å†™ä¸€ä¸ªç¨‹åºï¼Œ æ‰¾å‡ºå•è¯è¡¨ä¸­æ‰€æœ‰çš„è¿é”è¯ã€‚  æç¤ºï¼šä¸è¦æšä¸¾æ‰€æœ‰çš„å•è¯å¯¹ã€‚

%ğŸ% \item Can you find any words that are three-way interlocked; that is,
%ğŸ%   every third letter forms a word, starting from the first, second or
%ğŸ%   third?

\item ä½ èƒ½å¤Ÿæ‰¾åˆ°ä¸‰é‡è¿é”çš„å•è¯å—ï¼Ÿå³æ¯ä¸ªå­—æ¯ä¾æ¬¡ä»3ä¸ªå•è¯å¾—åˆ°ã€‚

\end{enumerate}
\end{exercise}