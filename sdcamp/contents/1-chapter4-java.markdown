# 如何写好Java程序 #

写程序对每个软件开发者是个基本功，在企业中要考虑代码是给团队一起看的，因此质量的要求要更高一点。

首先你要有想把代码写好的意识，否则再怎么说都没用。可以经常想想你的代码几年以后还容易读吗？

如果你在用一些比较新的语言那就很幸运，因为有很多有效的工具支撑，Java程序看起来就比C/C++容易一点。

在个人环境下，如果用Eclipse，可以安装下面的很多插件来帮你自动做很多事情。主要考虑：

  1. 代码覆盖率，对Java来说，90%是一个不错的标杆，80%很勉强。
  2. 为了实现代码覆盖率，当然需要用到单元测试，JUnit 3/4都可以，TestNG也不错。不用说，100%通过是必须的。
  3. 代码风格和一些常见错误会有 Checkstyle和FindBUGs/PMD/CPD等工具。
  
怎么写好代码当然是更重要的事，你要熟悉基本的5大设计原则（SRP,OCP,LSP,DIP,ISP)，理解这些以后，就可以学习如何用重构，如何用mock来隔离外部依赖写出好的单元测试。

测试驱动开发（TDD-Test Driven Development)是一个很有效的开发实践，要注重依据行为来驱动测试，而不是根据你的函数来写。

在服务器端，Sonar是个非常好用的工具，它把需要的质量信息都归纳起来了。一个产品架设好以后，代码的质量就一目了然了。

![Sonar](img/18333fig0401-tn.png)

## 环境准备 ##

 * Eclipse IDE和相关的插件EcmEmma

## 代码风格和编程规范 ##

编程规范（代码风格）不需要自己去创立，继承别人现有代码就可以了，建议用`checkstyle`工具强制控制一些基本的。

下面列出一些常见的，不过重要的是理解，而不是事后检查。千万不要打印或制定厚厚的规范，没用的。可以翻翻[Java的编程规范][javacoding]，下面列出几个：
 
  * 所有类的开头都要有Java文档的注释，而且写有用的内容。
  * 常量应该全部大写，单词之间由下划线分隔（例如，MAX_WORK_HOURS）。
  * 内部变量声明时应该对它进行初始化。
  * 不能有Magic数字，如`if(input_length<8)`。        
 
## 安全代码 ##
有些时候还要考虑一下写出安全的代码，这和产品的性质有关，web类产品会考虑得多一点。可以翻翻[Java的安全代码编程规范][javasec]，下面列出几个：

  * 要对输入信息（参数、特殊字符、SQL注入）进行检查验证。
  * 不要到处保存敏感数据（在数据库、文件等地方），如果必须要对它们进行保存，那就保存它们加密后的结果。
  * 要记录所有的或是有疑问的操作的日志。
  
## 单元测试 ##

这个应该是最简单的，但还是发现好多人都不做，要养成习惯，每个公共方法都需要至少有一个测试用例。

单元测试是代码的一部分，要养成同时签入版本库的习惯。而且如果本地没有100%测试通过，也不允许提交代码。

良好的高度覆盖的单元测试是将来重构的保障。

## 代码覆盖率 ##
有了单元测试后，就可以来看看代码覆盖率，建议在Eclipse中安装[EclEmma][eclemma]，非常好用。

![Eclipse插件EclEmma](img/18333fig0402-tn.png)

服务器端不用Sonar的话，cobertura不错。

## 重构 ##
重构分好几层，这里主要考虑日常的重构，千万不要跟经理或项目经理要求时间，这个是对他们不可见的，当然团队可以了解你重构的内容。

不要把重构当成很复杂的东西，大多数是很简单的，在Eclipse中点几下就可以了。

![Eclipse中使用Refactor](img/18333fig0403-tn.png)

最常见的重构有：
 
  * Rename (改名字）
  * Extract Method （提取函数）
  * Extract Interface （提取接口）

关键的是看到坏代码，要养成习惯去重构，基础是有质量高的单元测试。  

## 测试驱动开发 TDD ##
很多人认为测试驱动开发会浪费时间，如果写完代码再写测试不更快捷吗？反正把覆盖率达到就好了。

代码覆盖率只是TDD的一个好处而已，以上正确的一个前提就是代码实现的是正确的需求，很多很多时候，我们写了很多的代码，但有部分是不必要的。代码的产量不重要，重要的是质量。过多的不必要的代码是浪费。

而且覆盖率补上往往是一种借口，大部分的人代码写完了，认为任务就完成了，单元测试是额外的工作，至少我看到蛮多项目经理就这么认为的。

测试驱动开发会把你写代码的速度慢下来，但确保你写出来的代码是有用的、干净的。

因此TDD会帮助我们让代码一直工作，并且保持干净。

### 测试驱动开发的步骤 ###
典型的步骤是这样的：

 1. 根据任务，新增一个单元测试用例（TestCase）。
 2. 编译代码，让刚刚写的那个测试编译通过，运行会失败，在IDE中显示红条(Red Bar)，因为还没有写实现代码。
 3. 实现（implement）为了这个测试用例通过的代码，并编译通过。
 4. 运行所有的测试，保证每个都能通过，在IDE中显示绿条(Green Bar)。
 5. 重构代码，保持干净代码。
 
### 单元测试就是文档 ###
如果你严格按照测试驱动开发方式来写代码，那么你的单元测试就应该是文档。

单元测试用例是为了实现某个功能而写的测试用例，因此它表明了代码的需求，读懂了这些需求，那就是很好的文档。

### 单元测试也要重构 ###
很多人只知道对实现代码进行重构，忘了单元测试也是很需要的。

所以建议你看看你的单元测试，是不是明白你的代码的作用了呢，如果不是，请重构。

## 测试模拟（Mock） ##
既然叫单元测试，那么它的目标一般就是一个方法，因此需要尽量小步、细粒度的来进行测试。这样单元测试才可以快速完成。

在现实情况下，很多方法往往依赖于其他一些难以操控的东西，这时就需要进行隔离，如网路、数据库连接等，这就需要使用Mock模拟。

同时Mock也保证了代码的可测性。

Mock一般都是通过接口（interface）来实现的，有很多Java工具来帮你Mock。老字号的有JMock、EasyMock，现在比较不错的工具[^41]是Mockito、JMockit、PowerMock。后面解决了一些EasyMock不能对复杂方法处理的弱点，特别是静态函数。

记住工具不是主要的，但是好的工具确实是很重要的。

## 课后练习 ##
 1. 学习体会5大设计原则
 2. 翻看代码规范，记住一些自己遗漏的地方。
 3. 用TDD的方式实现一些功能，不要忘了重构和检查覆盖率。
 4. 用JMockit工具来mock。

## 参考阅读 ##
 1. The Principles of OOD : <http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod>
 2. 重构：<http://book.douban.com/subject/4262627/>
 3. 测试驱动的面向对象软件开发：<http://book.douban.com/subject/4910582/>
 4. EclEmma: <http://www.eclemma.org/>
 5. 测试驱动开发全功略@爬树的泡泡: <http://www.blogjava.net/briansun/archive/2005/07/31/8813.html>
 
 [javacoding]: http://www.oracle.com/technetwork/java/codeconv-138413.html
 [javasec]:    http://www.oracle.com/technetwork/java/seccodeguide-139067.html
 [eclemma]:    http://www.eclemma.org/
 
[^41]:  Stackoverflow 上的对这些工具的比较 <http://stackoverflow.com/questions/4105592/comparison-between-mockito-vs-jmockit-why-is-mockito-voted-better-than-jmockit>

